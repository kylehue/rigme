!function(n){var r={};function i(t){if(r[t])return r[t].exports;var e=r[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,i),e.l=!0,e.exports}i.m=n,i.c=r,i.d=function(t,e,n){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)i.d(n,r,function(t){return e[t]}.bind(null,r));return n},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s="./src/client/js/app.js")}({"./node_modules/base64-js/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?")},"./node_modules/ieee754/index.js":function(module,exports){eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?")},"./node_modules/isarray/index.js":function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?")},"./node_modules/lodash.clonedeep/index.js":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/lodash.clonedeep/index.js?")},"./node_modules/node-libs-browser/node_modules/buffer/index.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/buffer/index.js?")},"./node_modules/process/browser.js":function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?")},"./node_modules/setimmediate/setImmediate.js":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?')},"./node_modules/streamsaver/StreamSaver.js":function(module,exports,__webpack_require__){eval("/* global chrome location ReadableStream define MessageChannel TransformStream */\n\n;((name, definition) => {\n   true\n    ? module.exports = definition()\n    : undefined\n})('streamSaver', () => {\n  'use strict'\n\n  const global = typeof window === 'object' ? window : this\n  if (!global.HTMLElement) console.warn('streamsaver is meant to run on browsers main thread')\n\n  let mitmTransporter = null\n  let supportsTransferable = false\n  const test = fn => { try { fn() } catch (e) {} }\n  const ponyfill = global.WebStreamsPolyfill || {}\n  const isSecureContext = global.isSecureContext\n  // TODO: Must come up with a real detection test (#69)\n  let useBlobFallback = /constructor/i.test(global.HTMLElement) || !!global.safari || !!global.WebKitPoint\n  const downloadStrategy = isSecureContext || 'MozAppearance' in document.documentElement.style\n    ? 'iframe'\n    : 'navigate'\n\n  const streamSaver = {\n    createWriteStream,\n    WritableStream: global.WritableStream || ponyfill.WritableStream,\n    supported: true,\n    version: { full: '2.0.5', major: 2, minor: 0, dot: 5 },\n    mitm: 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0'\n  }\n\n  /**\n   * create a hidden iframe and append it to the DOM (body)\n   *\n   * @param  {string} src page to load\n   * @return {HTMLIFrameElement} page to load\n   */\n  function makeIframe (src) {\n    if (!src) throw new Error('meh')\n    const iframe = document.createElement('iframe')\n    iframe.hidden = true\n    iframe.src = src\n    iframe.loaded = false\n    iframe.name = 'iframe'\n    iframe.isIframe = true\n    iframe.postMessage = (...args) => iframe.contentWindow.postMessage(...args)\n    iframe.addEventListener('load', () => {\n      iframe.loaded = true\n    }, { once: true })\n    document.body.appendChild(iframe)\n    return iframe\n  }\n\n  /**\n   * create a popup that simulates the basic things\n   * of what a iframe can do\n   *\n   * @param  {string} src page to load\n   * @return {object}     iframe like object\n   */\n  function makePopup (src) {\n    const options = 'width=200,height=100'\n    const delegate = document.createDocumentFragment()\n    const popup = {\n      frame: global.open(src, 'popup', options),\n      loaded: false,\n      isIframe: false,\n      isPopup: true,\n      remove () { popup.frame.close() },\n      addEventListener (...args) { delegate.addEventListener(...args) },\n      dispatchEvent (...args) { delegate.dispatchEvent(...args) },\n      removeEventListener (...args) { delegate.removeEventListener(...args) },\n      postMessage (...args) { popup.frame.postMessage(...args) }\n    }\n\n    const onReady = evt => {\n      if (evt.source === popup.frame) {\n        popup.loaded = true\n        global.removeEventListener('message', onReady)\n        popup.dispatchEvent(new Event('load'))\n      }\n    }\n\n    global.addEventListener('message', onReady)\n\n    return popup\n  }\n\n  try {\n    // We can't look for service worker since it may still work on http\n    new Response(new ReadableStream())\n    if (isSecureContext && !('serviceWorker' in navigator)) {\n      useBlobFallback = true\n    }\n  } catch (err) {\n    useBlobFallback = true\n  }\n\n  test(() => {\n    // Transfariable stream was first enabled in chrome v73 behind a flag\n    const { readable } = new TransformStream()\n    const mc = new MessageChannel()\n    mc.port1.postMessage(readable, [readable])\n    mc.port1.close()\n    mc.port2.close()\n    supportsTransferable = true\n    // Freeze TransformStream object (can only work with native)\n    Object.defineProperty(streamSaver, 'TransformStream', {\n      configurable: false,\n      writable: false,\n      value: TransformStream\n    })\n  })\n\n  function loadTransporter () {\n    if (!mitmTransporter) {\n      mitmTransporter = isSecureContext\n        ? makeIframe(streamSaver.mitm)\n        : makePopup(streamSaver.mitm)\n    }\n  }\n\n  /**\n   * @param  {string} filename filename that should be used\n   * @param  {object} options  [description]\n   * @param  {number} size     depricated\n   * @return {WritableStream<Uint8Array>}\n   */\n  function createWriteStream (filename, options, size) {\n    let opts = {\n      size: null,\n      pathname: null,\n      writableStrategy: undefined,\n      readableStrategy: undefined\n    }\n\n    let bytesWritten = 0 // by StreamSaver.js (not the service worker)\n    let downloadUrl = null\n    let channel = null\n    let ts = null\n\n    // normalize arguments\n    if (Number.isFinite(options)) {\n      [ size, options ] = [ options, size ]\n      console.warn('[StreamSaver] Depricated pass an object as 2nd argument when creating a write stream')\n      opts.size = size\n      opts.writableStrategy = options\n    } else if (options && options.highWaterMark) {\n      console.warn('[StreamSaver] Depricated pass an object as 2nd argument when creating a write stream')\n      opts.size = size\n      opts.writableStrategy = options\n    } else {\n      opts = options || {}\n    }\n    if (!useBlobFallback) {\n      loadTransporter()\n\n      channel = new MessageChannel()\n\n      // Make filename RFC5987 compatible\n      filename = encodeURIComponent(filename.replace(/\\//g, ':'))\n        .replace(/['()]/g, escape)\n        .replace(/\\*/g, '%2A')\n\n      const response = {\n        transferringReadable: supportsTransferable,\n        pathname: opts.pathname || Math.random().toString().slice(-6) + '/' + filename,\n        headers: {\n          'Content-Type': 'application/octet-stream; charset=utf-8',\n          'Content-Disposition': \"attachment; filename*=UTF-8''\" + filename\n        }\n      }\n\n      if (opts.size) {\n        response.headers['Content-Length'] = opts.size\n      }\n\n      const args = [ response, '*', [ channel.port2 ] ]\n\n      if (supportsTransferable) {\n        const transformer = downloadStrategy === 'iframe' ? undefined : {\n          // This transformer & flush method is only used by insecure context.\n          transform (chunk, controller) {\n            if (!(chunk instanceof Uint8Array)) {\n              throw new TypeError('Can only wirte Uint8Arrays')\n            }\n            bytesWritten += chunk.length\n            controller.enqueue(chunk)\n\n            if (downloadUrl) {\n              location.href = downloadUrl\n              downloadUrl = null\n            }\n          },\n          flush () {\n            if (downloadUrl) {\n              location.href = downloadUrl\n            }\n          }\n        }\n        ts = new streamSaver.TransformStream(\n          transformer,\n          opts.writableStrategy,\n          opts.readableStrategy\n        )\n        const readableStream = ts.readable\n\n        channel.port1.postMessage({ readableStream }, [ readableStream ])\n      }\n\n      channel.port1.onmessage = evt => {\n        // Service worker sent us a link that we should open.\n        if (evt.data.download) {\n          // Special treatment for popup...\n          if (downloadStrategy === 'navigate') {\n            mitmTransporter.remove()\n            mitmTransporter = null\n            if (bytesWritten) {\n              location.href = evt.data.download\n            } else {\n              downloadUrl = evt.data.download\n            }\n          } else {\n            if (mitmTransporter.isPopup) {\n              mitmTransporter.remove()\n              mitmTransporter = null\n              // Special case for firefox, they can keep sw alive with fetch\n              if (downloadStrategy === 'iframe') {\n                makeIframe(streamSaver.mitm)\n              }\n            }\n\n            // We never remove this iframes b/c it can interrupt saving\n            makeIframe(evt.data.download)\n          }\n        }\n      }\n\n      if (mitmTransporter.loaded) {\n        mitmTransporter.postMessage(...args)\n      } else {\n        mitmTransporter.addEventListener('load', () => {\n          mitmTransporter.postMessage(...args)\n        }, { once: true })\n      }\n    }\n\n    let chunks = []\n\n    return (!useBlobFallback && ts && ts.writable) || new streamSaver.WritableStream({\n      write (chunk) {\n        if (!(chunk instanceof Uint8Array)) {\n          throw new TypeError('Can only wirte Uint8Arrays')\n        }\n        if (useBlobFallback) {\n          // Safari... The new IE6\n          // https://github.com/jimmywarting/StreamSaver.js/issues/69\n          //\n          // even doe it has everything it fails to download anything\n          // that comes from the service worker..!\n          chunks.push(chunk)\n          return\n        }\n\n        // is called when a new chunk of data is ready to be written\n        // to the underlying sink. It can return a promise to signal\n        // success or failure of the write operation. The stream\n        // implementation guarantees that this method will be called\n        // only after previous writes have succeeded, and never after\n        // close or abort is called.\n\n        // TODO: Kind of important that service worker respond back when\n        // it has been written. Otherwise we can't handle backpressure\n        // EDIT: Transfarable streams solvs this...\n        channel.port1.postMessage(chunk)\n        bytesWritten += chunk.length\n\n        if (downloadUrl) {\n          location.href = downloadUrl\n          downloadUrl = null\n        }\n      },\n      close () {\n        if (useBlobFallback) {\n          const blob = new Blob(chunks, { type: 'application/octet-stream; charset=utf-8' })\n          const link = document.createElement('a')\n          link.href = URL.createObjectURL(blob)\n          link.download = filename\n          link.click()\n        } else {\n          channel.port1.postMessage('end')\n        }\n      },\n      abort () {\n        chunks = []\n        channel.port1.postMessage('abort')\n        channel.port1.onmessage = null\n        channel.port1.close()\n        channel.port2.close()\n        channel = null\n      }\n    }, opts.writableStrategy)\n  }\n\n  return streamSaver\n})\n\n\n//# sourceURL=webpack:///./node_modules/streamsaver/StreamSaver.js?")},"./node_modules/timers-browserify/main.js":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n            (typeof self !== "undefined" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n                       (typeof global !== "undefined" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n                         (typeof global !== "undefined" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?')},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},"./node_modules/webpack/buildin/module.js":function(module,exports){eval('module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, "loaded", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "id", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?')},"./node_modules/yieldable-json/index.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/* **************************************************************************\n *\n * (c) Copyright IBM Corp. 2017\n *\n *  This program and the accompanying materials are made available\n *  under the terms of the Apache License v2.0 which accompanies\n *  this distribution.\n *\n *      The Apache License v2.0 is available at\n *      http://www.opensource.org/licenses/apache2.0.php\n *\n * Contributors:\n *   Multiple authors (IBM Corp.) - initial implementation and documentation\n ***************************************************************************/\n\n\nconst pa = __webpack_require__(/*! ./yieldable-parser */ \"./node_modules/yieldable-json/yieldable-parser.js\");\nconst ps = __webpack_require__(/*! ./yieldable-stringify */ \"./node_modules/yieldable-json/yieldable-stringify.js\");\n\n/**\n * Checks whether the provided space\n * @param { string or number } space\n * @return { string or number }\n */\nlet validateSpace = (space) => {\n  if (typeof space === 'number') {\n    space = Math.round(space);\n    if (space >= 1 && space <= 10)\n      return space;\n    else if (space < 1)\n      return 0;\n    else\n      return 10;\n  } else {\n    if (space.length <= 10)\n      return space;\n    else\n    return space.substr(0, 9);\n  }\n};\n\n/**\n * Checks whether the provided intensity\n * @param { number } intensity\n * @return { number }\n */\nlet validateIntensity = (intensity) => {\n  intensity = Math.round(intensity);\n  if (intensity > 0 && intensity <= 32)\n    return intensity;\n  else if (intensity <= 0)\n    return 1;\n  else\n    return 32;\n};\n\nmodule.exports = {\n\n  /**\n  * Error checking  and call of appropriate functions for JSON parse\n  * @param { primitive data types } data\n  * @param { function or array } reviver\n  * @param { number } intensity\n  * @param { function } callback\n  * @return { function } parseWrapper\n  */\n  parseAsync(data, reviver, intensity, callback) {\n    const argv = arguments;\n\n    //Bring parity with the in-built parser, that takes both string and buffer\n    if(Buffer.isBuffer(data))\n      data = data.toString();\n\n    if (argv.length < 2)\n      throw new Error('Missing Callback');\n\n    if (typeof argv[argv.length - 1] === 'function') {\n      callback = argv[argv.length - 1];\n      reviver = null;\n      intensity = 1;\n    } else\n      throw new TypeError('Callback is not a function');\n\n    if (argv.length > 2) {\n      let i = 1;\n      if (typeof argv[i] === 'function')\n        reviver = argv[i++];\n      if (typeof argv[i] === 'number')\n        intensity = validateIntensity(argv[i]);\n    }\n    return pa.parseWrapper(data, reviver, intensity, callback);\n  },\n\n  /**\n  * Error checking  and call of appropriate functions for JSON stringify API\n  * @param { primitive data types } data\n  * @param { function or array } replacer\n  * @param { number or string } space\n  * @param { number } intensity\n  * @param { function } callback\n  * @return { function } stringifyWrapper\n  */\n  stringifyAsync(data, replacer, space, intensity, callback) {\n    const argv = arguments;\n    if (typeof argv[argv.length - 1] === 'function') {\n      callback = argv[argv.length - 1];\n      replacer = null;\n      intensity = 1;\n    } else\n      throw new TypeError('Callback is not a function');\n    if (argv.length > 2) {\n      let i = 1;\n      if (typeof argv[i] === 'function' || typeof argv[i] === 'object')\n        replacer = argv[i++];\n      if ((typeof argv[i] === 'number' || typeof argv[i] === 'string') &&\n           typeof argv[i++] === 'number')\n        space = validateSpace(argv[i++]);\n      if (typeof argv[i] === 'number')\n        intensity = validateIntensity(argv[i]);\n    }\n    return ps.stringifyWrapper(data, replacer, space, intensity, callback);\n  },\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/buffer/index.js */ \"./node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/yieldable-json/index.js?")},"./node_modules/yieldable-json/yieldable-parser.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {/* **************************************************************************\n *\n * (c) Copyright IBM Corp. 2017\n *\n *  This program and the accompanying materials are made available\n *  under the terms of the Apache License v2.0 which accompanies\n *  this distribution.\n *\n *      The Apache License v2.0 is available at\n *      http://www.opensource.org/licenses/apache2.0.php\n *\n * Contributors:\n *   Multiple authors (IBM Corp.) - initial implementation and documentation\n ***************************************************************************/\n\n\n/**\n * This method parses a JSON text to produce an object or array.\n * It can throw a SyntaxError exception, if the string is malformed.\n * @param { string } text\n * @param { function or array } reviver\n * @param { number } intensity\n * @param { function } cb\n * @return { function } yieldCPU\n */\nlet parseWrapper = (text, reviver, intensity, cb) => {\n  let counter = 0;\n  let keyN = 0;\n  let parseStr = text;\n  let at = 0;\n  let ch = ' ';\n  let word = '';\n  function ParseError(m) {\n    this.name = 'ParseError';\n    this.message = m;\n    this.text = parseStr;\n  }\n\n  // Seek to the next character, after skipping white spaces, if any.\n  let seek = () => {\n    ch = parseStr.charAt(at);\n    at++;\n    while (ch && ch <= ' ') {\n      seek();\n    }\n    return ch;\n  };\n\n  // Seek to the previous character, required in some special cases.\n  let unseek = () => {\n    ch = parseStr.charAt(--at);\n  };\n\n  // Match 'true', 'false' and  'null' built-ins.\n  let wordCheck = () => {\n    word = '';\n    do {\n      word += ch;\n      seek();\n    } while (ch.match(/[a-z]/i));\n    parseStr = parseStr.slice(at - 1);\n    at = 0;\n    return word;\n  };\n\n  // Process strings specially.\n  let normalizeUnicodedString = () => {\n    let inQuotes = ' ';\n    let tempIndex = at;\n    let index = 0;\n    let slash = 0;\n    let c = '\"';\n    while (c) {\n      index = parseStr.indexOf('\"', tempIndex + 1);\n      tempIndex = index;\n      ch = parseStr.charAt(tempIndex - 1);\n      while (ch === '\\\\') {\n        slash++;\n        ch = parseStr.charAt(tempIndex - (slash + 1));\n      }\n      if (slash % 2 === 0) {\n        inQuotes = parseStr.substring(at, index);\n        parseStr = parseStr.slice(++index);\n        slash = 0;\n        break;\n      } else\n        slash = 0;\n    }\n\n    // When parsing string values, look for \" and \\ characters.\n    index = inQuotes.indexOf('\\\\');\n    while (index >= 0) {\n      let escapee = {\n        '\"': '\"',\n        '\\'': '\\'',\n        '/': '/',\n        '\\\\': '\\\\',\n        b: '\\b',\n        f: '\\f',\n        n: '\\n',\n        r: '\\r',\n        t: '\\t',\n      };\n      let hex = 0;\n      let i = 0;\n      let uffff = 0;\n      at = index;\n      ch = inQuotes.charAt(++at);\n      if (ch === 'u') {\n        uffff = 0;\n        for (i = 0; i < 4; i += 1) {\n          hex = parseInt(ch = inQuotes.charAt(++at), 16);\n          if (!isFinite(hex)) {\n            break;\n          }\n          uffff = uffff * 16 + hex;\n        }\n        inQuotes = inQuotes.slice(0, index) +\n                   String.fromCharCode(uffff) + inQuotes.slice(index + 6);\n        at = index;\n      } else if (typeof escapee[ch] === 'string') {\n        inQuotes = inQuotes.slice(0, index) +\n                   escapee[ch] + inQuotes.slice(index + 2);\n        at = index + 1;\n      } else\n        break;\n      index = inQuotes.indexOf('\\\\', at);\n    }\n    at = 0;\n    return inQuotes;\n  };\n\n  /**\n  * This function parses the current string and returns the JavaScript\n  * Object, through recursive method, and yielding back occasionally\n  * based on the intensity parameter.\n  * @return { object } returnObj\n  */\n  function * parseYield() {\n    let key = '';\n    let returnObj = {};\n    let returnArr = [];\n    let v = '';\n    let inQuotes = '';\n    let num = 0;\n    let numHolder = '';\n    let addup = () => {\n      numHolder += ch;\n      seek();\n    };\n    // Handle premitive types. eg: JSON.parse(21)\n    if (typeof parseStr === 'number' || typeof parseStr === 'boolean' ||\n        parseStr === null) {\n      parseStr = '';\n      return text;\n    } else if (typeof parseStr === 'undefined') {\n      parseStr = undefined;\n      return text;\n    } else if (parseStr.charAt(0) === '[' && parseStr.charAt(1) === ']') {\n      parseStr = '';\n      return [];\n    } else if (parseStr.charAt(0) === '{' && parseStr.charAt(1) === '}') {\n      parseStr = '';\n      return {};\n    } else {\n      // Yield the parsing work at specified intervals.\n      if (++counter > 512 * intensity) {\n        counter = 0;\n        yield;\n      }\n      // Common case: non-premitive types.\n      if (keyN !== 1)\n        seek();\n      switch (ch) {\n        case '{':\n        // Object case\n          seek();\n          if (ch === '}') {\n            parseStr = parseStr.slice(at);\n            at = 0;\n            return returnObj;\n          }\n          do {\n            if (ch !== '\"')\n              seek();\n            keyN = 1;\n            key = yield *parseYield();\n            keyN = 0;\n            seek();\n            returnObj[key] = yield *parseYield();\n            seek();\n            if (ch === '}') {\n              parseStr = parseStr.slice(at);\n              at = 0;\n              return returnObj;\n            }\n          } while (ch === ',');\n          return new ParseError('Bad object');\n        case '[':\n        // Array case\n          seek();\n          if (ch === ']') {\n            parseStr = parseStr.slice(at);\n            at = 0;\n            return returnArr;\n          }\n          unseek();\n          do {\n            v = yield *parseYield();\n            returnArr.push(v);\n            seek();\n            if (ch === ']') {\n              parseStr = parseStr.slice(at);\n              at = 0;\n              return returnArr;\n            }\n          } while (ch === ',');\n          return new ParseError('Bad array');\n        case '\"':\n          parseStr = parseStr.slice(at - 1);\n          at = 0;\n          if (parseStr.charAt(0) === '\"' && parseStr.charAt(1) === '\"') {\n            parseStr = parseStr.slice(2);\n            at = 0;\n            return inQuotes;\n          } else {\n            seek();\n            return normalizeUnicodedString();\n          }\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n        case '-':\n          if (ch === '-') addup();\n          do {\n            addup();\n            if (ch === '.' || ch === 'e' || ch === 'E' ||\n              ch === '-' || ch === '+' ||\n              (ch >= String.fromCharCode(65) &&\n              ch <= String.fromCharCode(70)))\n              addup();\n          } while (ch === '-' || ch === '+' || (isFinite(ch) && ch !== ''));\n          num = Number(numHolder);\n          parseStr = parseStr.slice(at - 1);\n          at = 0;\n          return num;\n        case 't':\n          word = wordCheck();\n          if (word === 'true')\n            return true;\n          else return new ParseError('Unexpected character');\n        case 'f':\n          word = wordCheck();\n          if (word === 'false')\n            return false;\n          else return new ParseError('Unexpected character');\n        case 'n':\n          word = wordCheck();\n          if (word === 'null')\n            return null;\n          else return new ParseError('Unexpected character');\n        default:\n          return new ParseError('Unexpected character');\n      }\n    }\n  }\n\n  /**\n   * If there is a reviver function, we recursively walk the new structure,\n   * passing each name/value pair to the reviver function for possible\n   * transformation, starting with a temporary root object that holds the result\n   * in an empty key. If there is not a reviver function, we simply return the\n   * result.\n   * @param { object } yieldedObject\n   * @param { string } key\n   * @return { function } reviver\n   */\n  let revive = (yieldedObject, key) => {\n    let k = '';\n    let v = '';\n    let val = yieldedObject[key];\n    if (val && typeof val === 'object') {\n      for (k in val) {\n        if (Object.prototype.hasOwnProperty.call(val, k)) {\n          v = revive(val, k);\n          if (v !== undefined)\n            val[k] = v;\n          else\n            delete val[k];\n        }\n      }\n    }\n    return reviver.call(yieldedObject, key, val);\n  };\n\n  let yielding = '';\n  // To hold 'parseYield' genarator function\n  function * yieldBridge() {\n    yielding = yield* parseYield();\n  }\n  let rs = yieldBridge();\n  let gen = rs.next();\n\n  // Main yield control logic.\n  let yieldCPU = () => {\n    setImmediate(() => {\n      gen = rs.next();\n\n      if (gen && gen.done === true) {\n        let isEmpty = (value) => {\n          if (value.charAt(0) === '}' || value.charAt(0) === ']')\n            value = value.substring(1, value.length);\n          return typeof value === 'string' && !value.trim();\n        };\n        if (typeof yielding === 'undefined')\n          return cb(new ParseError('Unexpected Character'), null);\n        else if (yielding instanceof ParseError)\n          return cb(yielding, null);\n        else if (!isEmpty(parseStr))\n          return cb(new ParseError('Unexpected Character'), null);\n        else {\n          if (reviver !== null) {\n            if (typeof reviver === 'function') {\n              let result = revive({'': yielding}, '');\n              return cb(null, result);\n            }\n          } else\n            return cb(null, yielding);\n        }\n      }\n      yieldCPU();\n    });\n  };\n  return yieldCPU();\n};\n\nexports.parseWrapper = parseWrapper;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/yieldable-json/yieldable-parser.js?")},"./node_modules/yieldable-json/yieldable-stringify.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {/* **************************************************************************\n *\n * (c) Copyright IBM Corp. 2017\n *\n *  This program and the accompanying materials are made available\n *  under the terms of the Apache License v2.0 which accompanies\n *  this distribution.\n *\n *      The Apache License v2.0 is available at\n *      http://www.opensource.org/licenses/apache2.0.php\n *\n * Contributors:\n *   Multiple authors (IBM Corp.) - initial implementation and documentation\n ***************************************************************************/\n\n\nlet counter = 0;\nlet objStack = [];\nlet temp = '';\nconst limit = 100000;\n\nfunction StringifyError(m) {\n  this.name = 'Error';\n  this.message = m;\n}\n\n/**\n * Checking for unicode and backslash characters and replaces if any.\n * @param { string }\n * @return { string }\n */\n\nlet normalize = (string, flagN) => {\n  let retStr = '';\n  let transform = '';\n  let uc =\n  '/[\\\\\\'\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4' +\n  '\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g';\n  let unicode = new RegExp(uc);\n  // Taking '\\\\' out of the loop to avoid change in\n  // order of execution of object entries resulting\n  // in unwanted side effect\n  string = string.replace(/\\\\/gi, '\\\\\\\\');\n  let escape = {\n    '\\b': '\\\\b',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\"': '\\\\\"',\n  };\n  // Escape is implemented globally\n  for(var pattern in escape) {\n    var regex = new RegExp(pattern,'gi')\n    string = string.replace(regex, escape[pattern])\n  }\n  unicode.lastIndex = 0;\n  if (unicode.test(string)) {\n    // Unicode logic here\n    transform = string.replace(unicode, (a) => {\n      return '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    });\n    if (flagN === 1) {\n      transform += temp;\n      transform += transform;\n      temp = '';\n      return '\"' + transform + '\"';\n    } else if (flagN === 2) {\n      return '\"' + transform + '\"';\n    } else {\n      temp += transform;\n    }\n  } else {\n    if (flagN === 1) {\n      retStr += temp;\n      retStr += string;\n      temp = '';\n      return '\"' + retStr + '\"';\n    } else if (flagN === 2) {\n      return '\"' + string + '\"';\n    } else {\n      temp += string;\n      return;\n    }\n  }\n};\n\n/**\n * Obtain stringified value by yielding at required intensity\n * @param { string} field\n * @param { primitive data type } container\n * @param { function or array } replacer\n * @param { number or string } space\n * @param { number } intensity\n * @return { function } yieldCPU\n */\n\nfunction * stringifyYield(field, container, replacer, space, intensity) {\n  let itr = 0;\n  let key = '';\n  let val = '';\n  let length = 0;\n  let tempVal = '';\n  let result = '';\n  let value = container[field];\n  // Made scope local handling async issues\n  let flag1 = 0;\n  let returnStr = '';\n  let subStr = '';\n  let len = 0;\n\n  // Yield the stringification at definite intervals\n  if (++counter > 512 * intensity) {\n    counter = 0;\n    yield val;\n  }\n\n  // Call replacer if one is present (SPEC)\n  if (typeof replacer === 'function') {\n    value = replacer.call(container, field, value);\n  }\n\n  switch (typeof value) {\n    case 'string':\n      if (value.length > limit) {\n        for (let l = 0; l < value.length; l += limit) {\n          flag1 = 0;\n          yield value;\n          subStr = value.substr(l, limit);\n          len += subStr.length;\n          if (len === value.length)\n            flag1 = 1;\n          returnStr = normalize(subStr, flag1);\n        }\n      } else\n        returnStr = normalize(value, 2);\n      return returnStr;\n    case 'number':\n      return isFinite(value)\n        ? String(value)\n        : 'null';\n    case 'boolean':\n    case 'null':\n      return String(value);\n    case 'undefined':\n      return;\n    case 'object':\n      if (!value)\n        return 'null';\n\n    // Manage special cases of Arrays and Objects\n      let getResult = (decision) => {\n        if (result.length === 0)\n          if (decision)\n            return '{}';\n          else\n          return '[]';\n        else\n        if (decision)\n          if (space)\n            return '{\\n' + space + result.join(',\\n' + space) + '\\n' + '}';\n          else\n            return '{' + result.join(',') + '}';\n        else\n          if (space)\n            return '[\\n' + space + result.join(',\\n' + space) + '\\n' + ']';\n          else\n            return '[' + result.join(',') + ']';\n      };\n\n      result = [];\n    // If toJSON is present, invoke it (SPEC)\n      if (value && typeof value.toJSON === 'function') {\n        result.push('\"' + value.toJSON(field) + '\"');\n        if (result.length === 0)\n          return '{}';\n        else\n        if (space)\n          return space + result.join(',\\n' + space) + '\\n';\n        else\n          return result.join(',');\n      }\n    // Array case\n      if (value && value.constructor === Array) {\n        length = value.length;\n        for (itr = 0; itr < length; itr += 1) {\n          tempVal =\n          yield *stringifyYield(itr, value, replacer, space, intensity) ||\n          'null';\n          if (tempVal !== undefined)\n            result.push(tempVal);\n        }\n        return getResult(false);\n      }\n\n    // Manage replacing object scenario (SPEC)\n      if (replacer && typeof replacer === 'object') {\n        length = replacer.length;\n        for (itr = 0; itr < length; itr += 1) {\n          if (typeof replacer[itr] === 'string') {\n            key = replacer[itr];\n            val = yield *stringifyYield(key, value, replacer, space, intensity);\n            if (val !== undefined)\n              result.push(normalize(key, 2) + (space\n              ? ': '\n              : ':') + val);\n          }\n        }\n      } else {\n      // Object case\n        objStack.push(value);\n        for (key in value) {\n          if (typeof value[key] === 'object' && value[key] !== null &&\n          value[key] !== undefined) {\n            if (objStack.indexOf(value[key]) !== -1) {\n              return new StringifyError('Circular Structure Detected');\n            } else\n            objStack.push(value[key]);\n          }\n          if (Object.hasOwnProperty.call(value, key)) {\n            val = yield *stringifyYield(key, value, replacer, space, intensity);\n            if (val !== undefined)\n              result.push(normalize(key, 2) + (space\n              ? ': '\n              : ':') + val);\n          }\n          objStack = objStack.filter((v, i, a) => { return v !== value[key] });\n        }\n        objStack = objStack.filter((v, i, a) => { return v !== value });\n      }\n      return getResult(true);\n    default:\n      return new StringifyError('Unexpected Character');\n  }\n}\n\n/**\n * Calling appropriate functions each time.\n * @param { primitive data types } value\n * @param { function or array } replacer\n * @param { number or string } space\n * @param { number } intensity\n * @param { function } callback\n * @return { function } yieldCPU\n */\n\nlet stringifyWrapper = (value, replacer, space, intensity, callback) => {\n  let indent = '';\n  if (typeof space === 'number') {\n    indent = ' '.repeat(space);\n  } else if (typeof space === 'string') {\n    indent = space;\n  }\n\n  let yielding;\n\n  // To hold 'stringifyYield' genarator function\n  function * yieldBridge() {\n    yielding = yield *stringifyYield('', {'': value}, replacer, indent, 1);\n  }\n\n  let rs = yieldBridge();\n  let g = rs.next();\n\n  let yieldCPU = () => {\n    setImmediate(() => {\n      g = rs.next();\n      if (g && g.done === true) {\n        // Reinitializing the values at the end of API call\n        counter = 0;\n        temp = ''\n        objStack = [];\n        if (typeof yielding === 'object')\n          return callback(yielding, null);\n        else\n          return callback(null, yielding);\n      }\n      yieldCPU();\n    });\n  };\n  return yieldCPU();\n};\n\nexports.stringifyWrapper = stringifyWrapper;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/yieldable-json/yieldable-stringify.js?")},"./src/client/js/app.js":function(module,exports,__webpack_require__){eval('const streamSaver = __webpack_require__(/*! streamsaver */ "./node_modules/streamsaver/StreamSaver.js");\r\nconst yj = __webpack_require__(/*! yieldable-json */ "./node_modules/yieldable-json/index.js");\r\nconst renderer = __webpack_require__(/*! ./renderer.js */ "./src/client/js/renderer.js");\r\nconst dom = __webpack_require__(/*! ../../lib/dom.js */ "./src/lib/dom.js");\r\nconst events = __webpack_require__(/*! ../../lib/events.js */ "./src/lib/events.js");\r\nconst vector = __webpack_require__(/*! ../../lib/vector.js */ "./src/lib/vector.js");\r\nconst mouse = __webpack_require__(/*! ../../lib/mouse.js */ "./src/lib/mouse.js");\r\nconst key = __webpack_require__(/*! ../../lib/key.js */ "./src/lib/key.js");\r\nconst utils = __webpack_require__(/*! ../../lib/utils.js */ "./src/lib/utils.js");\r\nconst config = __webpack_require__(/*! ../../lib/config.js */ "./src/lib/config.js");\r\nconst vue = __webpack_require__(/*! ./vue/vue.js */ "./src/client/js/vue/vue.js");\r\nconst rigModel = __webpack_require__(/*! ./rig.model.js */ "./src/client/js/rig.model.js");\r\nconst history = __webpack_require__(/*! ./history.js */ "./src/client/js/history.js");\r\nconst extractKeyframes = __webpack_require__(/*! ./extract.keyframes.js */ "./src/client/js/extract.keyframes.js");\r\nevents.emit("loadedApps", vue);\r\n\r\nwindow.rigModel = rigModel;\r\n\r\nconst __development = false;\r\n\r\nlet jointCrop,\r\n\tactivePane,\r\n\tmaterials = [],\r\n\tsleep = false,\r\n\tshowOverlay = true,\r\n\tmirror = null,\r\n\tcameraDistance = config.world.zoom,\r\n\tcameraMovement = vector(),\r\n\tmouseLast = vector(),\r\n\tworldMouse = vector(),\r\n\tactions = {\r\n\t\tpan: "pan",\r\n\t\tselect: "select",\r\n\t\tadd: "add",\r\n\t\tmove: "move",\r\n\t\tremove: "remove"\r\n\t},\r\n\tshortcuts = {\r\n\t\tKeyQ: actions.pan,\r\n\t\tKeyW: actions.select,\r\n\t\tKeyE: actions.move,\r\n\t\tKeyR: actions.add,\r\n\t\tKeyT: actions.remove\r\n\t},\r\n\tactionIconPaths = {},\r\n\taction = actions.pan;\r\n\r\nactionIconPaths.add = "assets/svg/joint-plus.svg";\r\nactionIconPaths.select = "assets/svg/joint-click.svg";\r\nactionIconPaths.move = "assets/svg/joint-arrow.svg";\r\nactionIconPaths.remove = "assets/svg/joint-trash.svg";\r\nactionIconPaths.pan = "assets/svg/quad-arrow.svg";\r\n\r\n//Add action button click event\r\nconst actionButtons = {\r\n\tadd: dom.query("#addJoint"),\r\n\tselect: dom.query("#selectJoint"),\r\n\tmove: dom.query("#moveJoint"),\r\n\tremove: dom.query("#removeJoint"),\r\n\tpan: dom.query("#panCamera")\r\n};\r\n\r\nconst actionButtonNames = Object.keys(actionButtons);\r\n\r\nfunction setAction(_action) {\r\n\taction = _action;\r\n\trigModel.action = _action;\r\n\r\n\tdom.query("#toolApp button", true).removeClass("active-tool");\r\n\tdom.query(actionButtons[_action].node).addClass("active-tool");\r\n\tactionPreview.query("img").prop("src", actionIconPaths[_action]);\r\n}\r\n\r\nfor (let btn of actionButtonNames) {\r\n\tactionButtons[btn].on("click", () => {\r\n\t\tsetAction(actions[btn]);\r\n\t});\r\n}\r\n\r\n//Disable some default events\r\nconst _preventDefault = e => e.preventDefault();\r\ndom.query(document).on("contextmenu", _preventDefault);\r\ndom.query("div", true).on("drag", _preventDefault);\r\ndom.query("div", true).on("dragstart", _preventDefault);\r\n\r\n//Add material/images events\r\nconst materialApp = dom.query("#materialApp");\r\nconst materialsComboBox = dom.query("#propertyApp #materials");\r\n\r\nfunction configMaterial(id) {\r\n\tlet mat = materials.find(m => m.id === id);\r\n\tif (mat) {\r\n\t\tmaterialsComboBox.value(mat.src);\r\n\t\tmaterialsComboBox.query("label", true).text(mat.file.name, true);\r\n\t\tevents.emit("materialChange", materialsComboBox.value());\r\n\t}\r\n}\r\n\r\nfunction createMaterial(file) {\r\n\tconst id = utils.uid();\r\n\tlet fileURL = URL.createObjectURL(file);\r\n\tlet button = dom.create("button");\r\n\tlet img = button.create("img");\r\n\r\n\tbutton.addClass("item");\r\n\timg.attr("src", fileURL);\r\n\r\n\tbutton.node.addEventListener("click", () => {\r\n\t\tconfigMaterial(id);\r\n\t});\r\n\r\n\tmaterialApp.append(button);\r\n\r\n\tlet option = materialsComboBox.query(".options").create("p");\r\n\toption.node.dataset.value = fileURL;\r\n\toption.node.dataset.parentId = "#materials";\r\n\toption.text(file.name);\r\n\r\n\tmaterialApp.node.scrollTop = materialApp.node.scrollHeight;\r\n\r\n\treturn {\r\n\t\tid: id,\r\n\t\tfile: file,\r\n\t\tsrc: fileURL,\r\n\t\tel: button\r\n\t};\r\n}\r\n\r\nfunction handleMaterialFiles(files) {\r\n\tconst validImageTypes = ["image/gif", "image/jpeg", "image/png", "image/svg+xml"];\r\n\tfor (var i = 0; i < files.length; i++) {\r\n\t\tlet file = files[i];\r\n\t\tlet exists;\r\n\t\tfor (var j = 0; j < materials.length; j++) {\r\n\t\t\tlet mat = materials[j];\r\n\t\t\tif (mat.file.name == file.name && mat.file.lastModified == file.lastModified && mat.file.size == file.size && mat.file.type == file.type) {\r\n\t\t\t\texists = mat;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (validImageTypes.includes(file.type)) {\r\n\t\t\tlet material = createMaterial(file);\r\n\t\t\tmaterials.push(material);\r\n\t\t}\r\n\r\n\t\tif (exists) {\r\n\t\t\texists.el.remove();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//Custom checkbox\r\nlet checkBoxes = dom.query(".checkbox.checked", true);\r\nfor (var i = 0; i < checkBoxes.elements.length; i++) {\r\n\tlet chkbox = checkBoxes.elements[i];\r\n\tchkbox.node.parentNode.checked = true;\r\n}\r\n\r\ndom.query(".custom-checkbox", true).on("click", event => {\r\n\tlet el = dom.query(event.target).query(".checkbox");\r\n\tel.toggleClass("checked");\r\n\tdom.query(event.target).prop("checked", el.hasClass("checked"));\r\n\r\n\t//\r\n\tif (event.target.id == "animateSkin") {\r\n\t\tconfig.animateSkin = el.hasClass("checked");\r\n\t}\r\n});\r\n\r\n//Custom select\r\nconst selectOptions = dom.query("#selectOptions");\r\nselectOptions.on("mousedown", event => {\r\n\tlet value = event.target.dataset.value;\r\n\tlet parentId = event.target.dataset.parentId;\r\n\tlet parent = dom.query(parentId);\r\n\tparent.value(value);\r\n\tparent.query("label").text(event.target.innerText, true);\r\n\r\n\tif (parentId == "#materials") events.emit("materialChange", value);\r\n});\r\n\r\ndom.query("#propertyApp").on("mousewheel", () => {\r\n\tselectOptions.css("display", "none");\r\n});\r\n\r\ndom.query(".custom-select", true).on("mouseup", event => {\r\n\tlet options = dom.query(event.target, true).query(".options");\r\n\tselectOptions.html(options.html(), true);\r\n\tif (selectOptions.node.style.display != "flex") {\r\n\t\tlet parentBounds = options.node.parentNode.getBoundingClientRect();\r\n\r\n\t\tlet x = parentBounds.x;\r\n\t\tlet y = parentBounds.y + parentBounds.height + 5;\r\n\r\n\t\tselectOptions.css({\r\n\t\t\tdisplay: "flex",\r\n\t\t\tleft: `${x}px`,\r\n\t\t\ttop: `${y}px`,\r\n\t\t\twidth: `${parentBounds.width}px`\r\n\t\t});\r\n\r\n\t\tlet selectOptionBounds = selectOptions.node.getBoundingClientRect();\r\n\r\n\t\tif (y + selectOptionBounds.height >= innerHeight) {\r\n\t\t\tselectOptions.css("top", `${parentBounds.y - selectOptionBounds.height - 5}px`);\r\n\t\t}\r\n\r\n\t\tif (x + selectOptionBounds.width >= innerWidth) {\r\n\t\t\tselectOptions.css("left", `${parentBounds.x - selectOptionBounds.width + parentBounds.width}px`);\r\n\t\t}\r\n\t} else {\r\n\t\tselectOptions.css("display", "none");\r\n\t}\r\n});\r\n\r\nmaterialApp.on("drop", event => {\r\n\tevent.preventDefault();\r\n\tlet files = event.dataTransfer.files;\r\n\thandleMaterialFiles(files);\r\n\tdom.query("#dropIcon").css("visibility", "hidden");\r\n});\r\n\r\nconst addMaterialButton = dom.query("#addMaterial");\r\naddMaterialButton.on("change", () => {\r\n\tlet files = addMaterialButton.node.files;\r\n\thandleMaterialFiles(files);\r\n});\r\n\r\nmaterialApp.on("dragenter", event => {\r\n\tdom.query("#dropIcon").css("visibility", "visible");\r\n});\r\n\r\nmaterialApp.on("dragleave", event => {\r\n\tdom.query("#dropIcon").css("visibility", "hidden");\r\n});\r\n\r\nmaterialApp.on("dragover", event => {\r\n\tevent.preventDefault();\r\n});\r\n\r\nmaterialApp.on("mousedown", event => {\r\n\tfor (var i = 0; i < materialApp.node.children.length; i++) {\r\n\t\tlet child = materialApp.node.children[i];\r\n\t\tchild.classList.remove("selected");\r\n\t}\r\n});\r\n\r\nlet overlayFrames = [];\r\nevents.on("saveProject", filename => {\r\n\tlet btn = dom.query("#download");\r\n\tbtn.addClass("disabled");\r\n\tbtn.text("Processing...", true);\r\n\r\n\tlet model = rigModel.toJSON(null, true);\r\n\tlet config = {\r\n\t\tframeCount: vue.timeline.app.totalFrames,\r\n\t\tanimationSpeed: vue.timeline.app.animationSpeed,\r\n\t\tstart: vue.timeline.graph.playbackHandle.start.mark,\r\n\t\tend: vue.timeline.graph.playbackHandle.end.mark,\r\n\t\toverlay: {\r\n\t\t\topacity: vue.overlayConfigApp.opacity,\r\n\t\t\tscale: vue.overlayConfigApp.scale,\r\n\t\t\tangle: vue.overlayConfigApp.angle,\r\n\t\t\ttrimStart: vue.overlayConfigApp.trimStart,\r\n\t\t\ttrimEnd: vue.overlayConfigApp.trimEnd,\r\n\t\t\tstart: vue.overlayConfigApp.start\r\n\t\t}\r\n\t};\r\n\r\n\tlet overlay = [];\r\n\r\n\tfor (var i = 0; i < overlayFrames.length; i++) {\r\n\t\tlet img = overlayFrames[i];\r\n\t\toverlay.push(img.src);\r\n\t}\r\n\r\n\tlet data = {\r\n\t\tmodel: model,\r\n\t\tconfig: config,\r\n\t\toverlay: overlay\r\n\t};\r\n\r\n\tyj.stringifyAsync(data, (err, str) => {\r\n\t\ttry {\r\n\t\t\tconst uInt8 = new TextEncoder().encode(str);\r\n\t\t\tconst fileStream = streamSaver.createWriteStream(`${filename}.rigme`);\r\n\r\n\t\t\tnew Response(str).body\r\n\t\t\t\t.pipeTo(fileStream)\r\n\t\t\t\t.then(success => {\r\n\r\n\t\t\t\t}, error => {\r\n\t\t\t\t\tconsole.warn(error);\r\n\t\t\t\t});\r\n\t\t} catch (e) {\r\n\t\t\tconsole.warn(e);\r\n\t\t}\r\n\r\n\t\tdom.query("#download").removeClass("disabled");\r\n\t\tbtn.text("Save", true);\r\n\t});\r\n});\r\n\r\nwindow.onunload = () => {\r\n\twritableStream.abort();\r\n}\r\n\r\nevents.on("loadProject", data => {\r\n\tif (data.model) {\r\n\t\tlet model = rigModel.fromJSON(data.model);\r\n\t\trigModel.reset();\r\n\t\trigModel.import(model);\r\n\t} else {\r\n\t\tconsole.warn("Couldn\'t load model.");\r\n\t}\r\n\r\n\tif (data.config) {\r\n\t\tif (typeof data.config.frameCount == "number") {\r\n\t\t\tdocument.getElementById("frameCount").value = data.config.frameCount;\r\n\t\t}\r\n\r\n\t\tif (typeof data.config.animationSpeed == "number") {\r\n\t\t\tdocument.getElementById("animationSpeed").value = data.config.animationSpeed;\r\n\t\t}\r\n\r\n\t\tvue.timeline.app.fixData();\r\n\r\n\t\tif (typeof data.config.start == "number") {\r\n\t\t\tvue.timeline.graph.playbackHandle.start.mark = data.config.start;\r\n\t\t}\r\n\r\n\t\tif (typeof data.config.end == "number") {\r\n\t\t\tvue.timeline.graph.playbackHandle.end.mark = data.config.end;\r\n\t\t}\r\n\r\n\t\tvue.timeline.graph.redraw();\r\n\r\n\t\tif (typeof data.config.overlay.opacity == "number") {\r\n\t\t\tvue.overlayConfigApp.opacity = data.config.overlay.opacity;\r\n\t\t}\r\n\r\n\t\tif (typeof data.config.overlay.scale == "number") {\r\n\t\t\tvue.overlayConfigApp.scale = data.config.overlay.scale;\r\n\t\t}\r\n\r\n\t\tif (typeof data.config.overlay.angle == "number") {\r\n\t\t\tvue.overlayConfigApp.angle = data.config.overlay.angle;\r\n\t\t}\r\n\r\n\t\tvue.overlayConfigApp.updateSliders();\r\n\r\n\t\tif (typeof data.config.overlay.trimStart == "number") {\r\n\t\t\tvue.overlayConfigApp.trimStart = data.config.overlay.trimStart;\r\n\t\t}\r\n\r\n\t\tif (typeof data.config.overlay.trimEnd == "number") {\r\n\t\t\tvue.overlayConfigApp.trimEnd = data.config.overlay.trimEnd;\r\n\t\t}\r\n\r\n\t\tif (typeof data.config.overlay.start == "number") {\r\n\t\t\tvue.overlayConfigApp.start = data.config.overlay.start;\r\n\t\t}\r\n\t} else {\r\n\t\tconsole.warn("Couldn\'t load configurations.");\r\n\t}\r\n\r\n\tif (data.overlay) {\r\n\t\tif (data.overlay.length > 0) {\r\n\t\t\toverlayFrames = [];\r\n\t\t\tvue.optionApp.overlayConfigHidden = false;\r\n\t\t\tfor (var i = 0; i < data.overlay.length; i++) {\r\n\t\t\t\tlet src = data.overlay[i];\r\n\t\t\t\tlet img = new Image();\r\n\t\t\t\timg.src = src;\r\n\t\t\t\toverlayFrames.push(img);\r\n\t\t\t}\r\n\t\t\tevents.emit("overlayFrames", overlayFrames);\r\n\t\t}\r\n\t} else {\r\n\t\tconsole.warn("Couldn\'t load overlay.");\r\n\t}\r\n\r\n\thistory.add({\r\n\t\tlabel: "Load",\r\n\t\tvalue: rigModel.clone(),\r\n\t\tgroup: "keyframe"\r\n\t});\r\n});\r\n\r\nlet progressBarWrapper = dom.query("#progressBarWrapper");\r\nlet progressBar = dom.query("#progressBar");\r\nlet cancelButton = dom.query("#progressBarWrapper button");\r\nlet progressText = dom.query("#progressBarWrapper p");\r\n\r\nevents.on("loadProgress", (progress, text, cancelFn) => {\r\n\tif (progressBarWrapper.node.style.display != "flex") {\r\n\t\tprogressBarWrapper.css("display", "flex");\r\n\t}\r\n\r\n\tif (progressText.text() != text) {\r\n\t\tprogressText.text(text, true);\r\n\t}\r\n\r\n\tif (typeof cancelFn == "function") {\r\n\t\tif (cancelButton.node.onclick != cancelFn) {\r\n\t\t\tcancelButton.node.onclick = cancelFn;\r\n\t\t}\r\n\t}\r\n\r\n\tif (progress >= 100) {\r\n\t\tevents.emit("doneProgress");\r\n\t}\r\n\r\n\tprogressBar.css("width", `${progress}%`)\r\n});\r\n\r\nevents.on("doneProgress", () => {\r\n\tprogressBarWrapper.css("display", "none");\r\n\tprogressBar.css("width", "0");\r\n});\r\n\r\nevents.on("extractFrames", (url, options) => {\r\n\toverlayFrames = [];\r\n\tevents.emit("loadProgress", 0, "Extracting frames...");\r\n\r\n\tfunction done() {\r\n\t\tvue.optionApp.overlayConfigHidden = false;\r\n\t\tevents.emit("overlayFrames", overlayFrames);\r\n\t\tevents.emit("doneProgress");\r\n\t}\r\n\r\n\textractKeyframes(url, {\r\n\t\tframeCount: options.frameCount,\r\n\t\tframeRate: options.frameRate,\r\n\t\tstart: options.start,\r\n\t\tend: options.end,\r\n\t\tquality: options.quality,\r\n\t\tdrop: false,\r\n\t\tprogress: function(img, pct) {\r\n\t\t\tevents.emit("loadProgress", pct, "Extracting frames...", () => {\r\n\t\t\t\tthis.drop = true;\r\n\t\t\t\tdone();\r\n\t\t\t});\r\n\r\n\t\t\toverlayFrames.push(img);\r\n\t\t},\r\n\t\tdone: function(images) {\r\n\t\t\toverlayFrames = images;\r\n\t\t\tdone();\r\n\t\t}\r\n\t});\r\n});\r\n\r\nevents.on("removeOverlay", () => {\r\n\toverlayFrames = [];\r\n\tvue.optionApp.overlayConfigHidden = true;\r\n});\r\n\r\nevents.on("rotoscope", async() => {\r\n\tif (!overlayFrames.length) return;\r\n\tlet poseNet = posenet.load({\r\n\t\tarchitecture: "MobileNetV1",\r\n\t\toutputStride: 16,\r\n\t\tinputResolution: {\r\n\t\t\twidth: 257,\r\n\t\t\theight: 200\r\n\t\t},\r\n\t\tquantBytes: 2,\r\n\t\tmultiplier: 0.75,\r\n\t\tflipHorizontal: false\r\n\t});\r\n\r\n\tevents.emit("loadProgress", 0, "Feeding frames to PoseNet...");\r\n\tevents.emit("changeRiggingMode", "linear");\r\n\trigModel.reset();\r\n\r\n\tlet head = rigModel.addJoint(0, 0);\r\n\thead.name = "Head";\r\n\tlet chin = rigModel.addJoint(0, 0);\r\n\tchin.name = "Chin";\r\n\tlet neck = rigModel.addJoint(0, 0);\r\n\tneck.name = "Neck";\r\n\tlet abdomen = rigModel.addJoint(0, 0);\r\n\tabdomen.name = "Abdomen";\r\n\tlet groin = rigModel.addJoint(0, 0);\r\n\tgroin.name = "Groin";\r\n\trigModel.activeJoint = neck;\r\n\tlet leftShoulder = rigModel.addJoint(0, 0);\r\n\tleftShoulder.name = "Right Shoulder";\r\n\tlet leftElbow = rigModel.addJoint(0, 0);\r\n\tleftElbow.name = "Right Elbow";\r\n\tlet leftWrist = rigModel.addJoint(0, 0);\r\n\tleftWrist.name = "Right Wrist";\r\n\tlet leftHand = rigModel.addJoint(0, 0);\r\n\tleftHand.name = "Right Hand";\r\n\trigModel.activeJoint = neck;\r\n\tlet rightShoulder = rigModel.addJoint(0, 0);\r\n\trightShoulder.name = "Left Shoulder";\r\n\tlet rightElbow = rigModel.addJoint(0, 0);\r\n\trightElbow.name = "Left Elbow";\r\n\tlet rightWrist = rigModel.addJoint(0, 0);\r\n\trightWrist.name = "Left Wrist";\r\n\tlet rightHand = rigModel.addJoint(0, 0);\r\n\trightHand.name = "Left Hand";\r\n\trigModel.activeJoint = groin;\r\n\tlet leftHip = rigModel.addJoint(0, 0);\r\n\tleftHip.name = "Right Hip";\r\n\tlet leftKnee = rigModel.addJoint(0, 0);\r\n\tleftKnee.name = "Right Knee";\r\n\tlet leftAnkle = rigModel.addJoint(0, 0);\r\n\tleftAnkle.name = "Right Ankle";\r\n\tlet leftFoot = rigModel.addJoint(0, 0);\r\n\tleftFoot.name = "Right Foot";\r\n\trigModel.activeJoint = groin;\r\n\tlet rightHip = rigModel.addJoint(0, 0);\r\n\trightHip.name = "Left Hip";\r\n\tlet rightKnee = rigModel.addJoint(0, 0);\r\n\trightKnee.name = "Left Knee";\r\n\tlet rightAnkle = rigModel.addJoint(0, 0);\r\n\trightAnkle.name = "Left Ankle";\r\n\tlet rightFoot = rigModel.addJoint(0, 0);\r\n\trightFoot.name = "Left Foot";\r\n\tlet prevPose;\r\n\tfor (var i = 0; i < overlayFrames.length; i++) {\r\n\t\tlet frame = overlayFrames[i];\r\n\t\tawait poseNet.then(net => {\r\n\t\t\treturn net.estimateSinglePose(frame);\r\n\t\t}).then(pose => {\r\n\t\t\tlet pct = (i / (overlayFrames.length - 1)) * 100;\r\n\t\t\tevents.emit("loadProgress", pct, "Rotoscoping...", () => {\r\n\t\t\t\ti = overlayFrames.length;\r\n\t\t\t\tpct = 100;\r\n\t\t\t\tevents.emit("doneProgress");\r\n\t\t\t});\r\n\r\n\t\t\tif (pct == 100) return;\r\n\r\n\t\t\t//Get pose bounds\r\n\t\t\tlet xAxes = [];\r\n\t\t\tlet yAxes = [];\r\n\t\t\tfor (var j = 0; j < pose.keypoints.length; j++) {\r\n\t\t\t\tlet point = pose.keypoints[j];\r\n\t\t\t\txAxes.push(point.position.x);\r\n\t\t\t\tyAxes.push(point.position.y);\r\n\t\t\t}\r\n\r\n\t\t\tlet bounds = {\r\n\t\t\t\tmin: {\r\n\t\t\t\t\tx: Math.min(...xAxes),\r\n\t\t\t\t\ty: Math.min(...yAxes)\r\n\t\t\t\t},\r\n\t\t\t\tmax: {\r\n\t\t\t\t\tx: Math.max(...xAxes),\r\n\t\t\t\t\ty: Math.max(...yAxes)\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet poseX = (bounds.min.x + bounds.max.x) / 2;\r\n\t\t\tlet poseY = (bounds.min.y + bounds.max.y) / 2;\r\n\r\n\t\t\t//Scale/Rotate pose based on overlay configuration\r\n\r\n\t\t\t//Scale\r\n\t\t\tfor (var j = 0; j < pose.keypoints.length; j++) {\r\n\t\t\t\tlet point = pose.keypoints[j].position;\r\n\t\t\t\tlet vertexDelta = {\r\n\t\t\t\t\tx: point.x - poseX,\r\n\t\t\t\t\ty: point.y - poseY\r\n\t\t\t\t};\r\n\r\n\t\t\t\tpoint.x = point.x + vertexDelta.x * (vue.overlayConfigApp.scale - 1);\r\n\t\t\t\tpoint.y = point.y + vertexDelta.y * (vue.overlayConfigApp.scale - 1);\r\n\t\t\t}\r\n\r\n\t\t\t//Rotate\r\n\t\t\tfor (var j = 0; j < pose.keypoints.length; j++) {\r\n\t\t\t\tlet point = pose.keypoints[j].position;\r\n\t\t\t\tlet x = (point.x - poseX) * Math.cos(vue.overlayConfigApp.angle) - (point.y - poseY) * Math.sin(vue.overlayConfigApp.angle);\r\n\t\t\t\tlet y = (point.x - poseX) * Math.sin(vue.overlayConfigApp.angle) + (point.y - poseY) * Math.cos(vue.overlayConfigApp.angle);\r\n\r\n\t\t\t\tpoint.x = x + poseX;\r\n\t\t\t\tpoint.y = y + poseY;\r\n\t\t\t}\r\n\r\n\t\t\tfor (var j = 0; j < pose.keypoints.length; j++) {\r\n\t\t\t\tlet point = pose.keypoints[j];\r\n\t\t\t\t/*if (point.score < 0.4 && i > 0) continue;*/\r\n\t\t\t\tpoint.position.x -= frame.width / 2;\r\n\t\t\t\tpoint.position.y -= frame.height / 2;\r\n\t\t\t\tswitch (point.part) {\r\n\t\t\t\t\tcase "leftShoulder":\r\n\t\t\t\t\t\tleftShoulder = rigModel.moveJointById(leftShoulder.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "leftElbow":\r\n\t\t\t\t\t\tleftElbow = rigModel.moveJointById(leftElbow.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "leftWrist":\r\n\t\t\t\t\t\tleftWrist = rigModel.moveJointById(leftWrist.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "rightShoulder":\r\n\t\t\t\t\t\trightShoulder = rigModel.moveJointById(rightShoulder.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "rightElbow":\r\n\t\t\t\t\t\trightElbow = rigModel.moveJointById(rightElbow.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "rightWrist":\r\n\t\t\t\t\t\trightWrist = rigModel.moveJointById(rightWrist.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "leftHip":\r\n\t\t\t\t\t\tleftHip = rigModel.moveJointById(leftHip.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "leftKnee":\r\n\t\t\t\t\t\tleftKnee = rigModel.moveJointById(leftKnee.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "leftAnkle":\r\n\t\t\t\t\t\tleftAnkle = rigModel.moveJointById(leftAnkle.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "rightHip":\r\n\t\t\t\t\t\trightHip = rigModel.moveJointById(rightHip.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "rightKnee":\r\n\t\t\t\t\t\trightKnee = rigModel.moveJointById(rightKnee.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase "rightAnkle":\r\n\t\t\t\t\t\trightAnkle = rigModel.moveJointById(rightAnkle.id, point.position.x, point.position.y);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//Set misc joints position\r\n\r\n\t\t\t//Groin\r\n\t\t\tlet midpointHip = vector({\r\n\t\t\t\tx: (leftHip.position.x + rightHip.position.x) / 2,\r\n\t\t\t\ty: (leftHip.position.y + rightHip.position.y) / 2\r\n\t\t\t});\r\n\r\n\t\t\tgroin = rigModel.moveJointById(groin.id, midpointHip.x, midpointHip.y);\r\n\r\n\t\t\t//Abdomen\r\n\t\t\tlet bodyAngle = midpointHip.heading(neck.position);\r\n\t\t\tlet bodyLength = midpointHip.dist(neck.position);\r\n\t\t\tlet bodyX = midpointHip.x + Math.cos(bodyAngle) * (bodyLength / 2);\r\n\t\t\tlet bodyY = midpointHip.y + Math.sin(bodyAngle) * (bodyLength / 2);\r\n\r\n\t\t\tabdomen = rigModel.moveJointById(abdomen.id, bodyX, bodyY);\r\n\r\n\t\t\tlet midpointShoulder = vector({\r\n\t\t\t\tx: (leftShoulder.position.x + rightShoulder.position.x) / 2,\r\n\t\t\t\ty: (leftShoulder.position.y + rightShoulder.position.y) / 2\r\n\t\t\t});\r\n\r\n\t\t\t//Head, neck, chin\r\n\t\t\tlet shoulderAngle = leftShoulder.position.heading(rightShoulder.position);\r\n\t\t\tlet headAngle = shoulderAngle - Math.PI / 2;\r\n\t\t\tlet headLength = bodyLength / 2;\r\n\t\t\tlet neckLength = bodyLength / 6;\r\n\r\n\t\t\tneck = rigModel.moveJointById(neck.id, midpointShoulder.x, midpointShoulder.y);\r\n\t\t\tchin = rigModel.moveJointById(chin.id, midpointShoulder.x, midpointShoulder.y - neckLength);\r\n\t\t\tlet headX = chin.position.x - Math.cos(headAngle) * headLength;\r\n\t\t\tlet headY = chin.position.y - Math.sin(headAngle) * headLength;\r\n\t\t\thead = rigModel.moveJointById(head.id, headX, headY);\r\n\r\n\t\t\t//Left hand\r\n\t\t\tlet leftArmAngle = leftShoulder.position.heading(leftWrist.position);\r\n\t\t\tlet leftArmLength = leftElbow.position.dist(leftWrist.position) / 2;\r\n\t\t\tlet leftHandX = leftWrist.position.x + Math.cos(leftArmAngle) * leftArmLength;\r\n\t\t\tlet leftHandY = leftWrist.position.y + Math.sin(leftArmAngle) * leftArmLength;\r\n\t\t\tleftHand = rigModel.moveJointById(leftHand.id, leftHandX, leftHandY);\r\n\r\n\t\t\t//Right hand\r\n\t\t\tlet rightArmAngle = rightShoulder.position.heading(rightWrist.position);\r\n\t\t\tlet rightArmLength = rightElbow.position.dist(rightWrist.position) / 2;\r\n\t\t\tlet rightHandX = rightWrist.position.x + Math.cos(rightArmAngle) * rightArmLength;\r\n\t\t\tlet rightHandY = rightWrist.position.y + Math.sin(rightArmAngle) * rightArmLength;\r\n\t\t\trightHand = rigModel.moveJointById(rightHand.id, rightHandX, rightHandY);\r\n\r\n\t\t\t//Left Foot\r\n\t\t\tlet leftFootAngle = leftHip.position.heading(leftKnee.position);\r\n\t\t\tlet leftFootLength = leftAnkle.position.dist(leftKnee.position) / 4;\r\n\t\t\tlet leftFootX = leftAnkle.position.x + Math.cos(leftFootAngle) * leftFootLength;\r\n\t\t\tlet leftFootY = leftAnkle.position.y + Math.sin(leftFootAngle) * leftFootLength;\r\n\t\t\tleftFoot = rigModel.moveJointById(leftFoot.id, leftFootX, leftFootY);\r\n\r\n\t\t\t//Right Foot\r\n\t\t\tlet rightFootAngle = rightHip.position.heading(rightKnee.position);\r\n\t\t\tlet rightFootLength = rightAnkle.position.dist(rightKnee.position) / 4;\r\n\t\t\tlet rightFootX = rightAnkle.position.x + Math.cos(rightFootAngle) * rightFootLength;\r\n\t\t\tlet rightFootY = rightAnkle.position.y + Math.sin(rightFootAngle) * rightFootLength;\r\n\t\t\trightFoot = rigModel.moveJointById(rightFoot.id, rightFootX, rightFootY);\r\n\r\n\t\t\tif (prevPose) {\r\n\t\t\t\tfor (var j = 0; j < prevPose.keypoints.length; j++) {\r\n\t\t\t\t\tlet point = prevPose.keypoints[j];\r\n\t\t\t\t\tlet newPoint = pose.keypoints.find(k => k.part == point.part);\r\n\t\t\t\t\tif (newPoint) {\r\n\t\t\t\t\t\tlet pointA = vector(point.position);\r\n\t\t\t\t\t\tlet pointB = vector(newPoint.position);\r\n\t\t\t\t\t\tif (pointA.dist(pointB) > 10 * vue.overlayConfigApp.scale) {\r\n\t\t\t\t\t\t\tvue.timeline.graph.setCurrentMark(i);\r\n\t\t\t\t\t\t\tvue.timeline.graph.updateState();\r\n\t\t\t\t\t\t\trigModel.setKeyframe(i);\r\n\t\t\t\t\t\t\tprevPose = JSON.parse(JSON.stringify(pose));\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvue.timeline.graph.setCurrentMark(i);\r\n\t\t\t\trigModel.setKeyframe(i);\r\n\t\t\t\tprevPose = JSON.parse(JSON.stringify(pose));\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n});\r\n\r\nwindow.events = events;\r\n\r\nevents.on("exportSpritesheet", options => {\r\n\tlet canvas = document.createElement("canvas");\r\n\tcanvas.width = options.cellWidth * options.cols;\r\n\tcanvas.height = options.cellHeight * options.rows;\r\n\tlet ctx = canvas.getContext("2d");\r\n\tlet lastExistingFrame;\r\n\tfor (var frame = options.start - 1; frame <= options.end - 1; frame++) {\r\n\t\tlet index = frame - options.start + 1;\r\n\t\tlet x = Math.floor(index % options.cols) * options.cellWidth;\r\n\t\tlet y = Math.floor(index / options.cols) * options.cellHeight;\r\n\r\n\t\tlet keyframe = rigModel.keyframes[frame];\r\n\t\tif (keyframe) {\r\n\t\t\tlastExistingFrame = frame;\r\n\t\t\trigModel.updateSkin(keyframe.joints);\r\n\t\t}\r\n\r\n\t\trigModel.renderTo(ctx, {\r\n\t\t\tframe: rigModel.keyframes[frame] ? frame : lastExistingFrame,\r\n\t\t\tposition: {\r\n\t\t\t\tx: x,\r\n\t\t\t\ty: y\r\n\t\t\t},\r\n\t\t\tshowSkin: options.showSkin,\r\n\t\t\tshowBones: options.showBones\r\n\t\t});\r\n\t}\r\n\r\n\tlet img = canvas.toDataURL("image/png");\r\n\tlet link = document.createElement("a");\r\n\tlink.download = options.name;\r\n\tlink.href = img;\r\n\tlink.click();\r\n});\r\n\r\nevents.on("exportFrames", options => {\r\n\tlet btn = dom.query("#exportFrames");\r\n\tbtn.text("Processing...", true);\r\n\tbtn.addClass("disabled");\r\n\tlet counter = 0,\r\n\t\ttotalSize = 0;\r\n\tconst readableZipStream = new ZIP({\r\n\t\tstart(ctrl) {\r\n\t\t\tlet lastExistingFrame;\r\n\t\t\tfor (var frame = options.start - 1; frame <= options.end - 1; frame++) {\r\n\t\t\t\tlet canvas = document.createElement("canvas");\r\n\t\t\t\tcanvas.width = options.frameWidth;\r\n\t\t\t\tcanvas.height = options.frameHeight;\r\n\t\t\t\tlet ctx = canvas.getContext("2d");\r\n\r\n\t\t\t\tlet index = frame - options.start + 1;\r\n\t\t\t\tlet keyframe = rigModel.keyframes[frame];\r\n\t\t\t\tif (keyframe) {\r\n\t\t\t\t\tlastExistingFrame = frame;\r\n\t\t\t\t\trigModel.updateSkin(keyframe.joints);\r\n\t\t\t\t}\r\n\r\n\t\t\t\trigModel.renderTo(ctx, {\r\n\t\t\t\t\tframe: rigModel.keyframes[frame] ? frame : lastExistingFrame,\r\n\t\t\t\t\tshowSkin: options.showSkin,\r\n\t\t\t\t\tshowBones: options.showBones\r\n\t\t\t\t});\r\n\r\n\t\t\t\tcanvas.toBlob(blob => {\r\n\t\t\t\t\tlet file = {\r\n\t\t\t\t\t\tname: `frames/${index}.png`,\r\n\t\t\t\t\t\tstream: () => blob.stream()\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tctrl.enqueue(file);\r\n\r\n\t\t\t\t\tcounter++;\r\n\t\t\t\t\ttotalSize += blob.size;\r\n\r\n\t\t\t\t\tif (counter >= options.totalFrames) {\r\n\t\t\t\t\t\tctrl.close();\r\n\r\n\t\t\t\t\t\tconst fileStream = streamSaver.createWriteStream(options.name + ".zip", {\r\n\t\t\t\t\t\t\tsize: totalSize\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\treadableZipStream.pipeTo(fileStream);\r\n\t\t\t\t\t\tbtn.text("Export", true);\r\n\t\t\t\t\t\tbtn.removeClass("disabled");\r\n\t\t\t\t\t}\r\n\t\t\t\t}, "image/png");\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n});\r\n\r\nevents.on("exportGIF", options => {\r\n\tlet btn = dom.query("#exportGIF");\r\n\tbtn.text("Processing...", true);\r\n\tbtn.addClass("disabled");\r\n\tconst gif = new GIF({\r\n\t\tworkers: 4,\r\n\t\tquality: 10,\r\n\t\trepeat: 0,\r\n\t\twidth: options.width,\r\n\t\theight: options.height,\r\n\t\tdither: true,\r\n\t\tworkerScript: "lib/gif.worker.js"\r\n\t});\r\n\r\n\tlet lastExistingFrame;\r\n\tfor (var frame = options.start - 1; frame <= options.end - 1; frame++) {\r\n\t\tlet canvas = document.createElement("canvas");\r\n\t\tcanvas.width = options.width;\r\n\t\tcanvas.height = options.height;\r\n\t\tlet ctx = canvas.getContext("2d");\r\n\t\tlet keyframe = rigModel.keyframes[frame];\r\n\t\tif (keyframe) {\r\n\t\t\tlastExistingFrame = frame;\r\n\t\t\trigModel.updateSkin(keyframe.joints);\r\n\t\t}\r\n\r\n\t\tctx.fillStyle = options.background;\r\n\t\tctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n\t\trigModel.renderTo(ctx, {\r\n\t\t\tframe: rigModel.keyframes[frame] ? frame : lastExistingFrame,\r\n\t\t\tshowSkin: options.showSkin,\r\n\t\t\tshowBones: options.showBones\r\n\t\t});\r\n\r\n\t\tgif.addFrame(canvas, {\r\n\t\t\tdelay: 1000 / vue.timeline.app.animationSpeed\r\n\t\t});\r\n\t}\r\n\r\n\tgif.render();\r\n\r\n\tgif.on("finished", blob => {\r\n\t\ttry {\r\n\t\t\tgif.abort();\r\n\t\t\tbtn.text("Export", true);\r\n\t\t\tbtn.removeClass("disabled");\r\n\r\n\t\t\tconst fileStream = streamSaver.createWriteStream(`${options.name}.gif`, {\r\n\t\t\t\tsize: blob.size\r\n\t\t\t});\r\n\t\t\tconst readableStream = blob.stream();\r\n\t\t\tif (window.WritableStream && readableStream.pipeTo) {\r\n\t\t\t\treturn readableStream.pipeTo(fileStream);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\tconsole.warn(e);\r\n\t\t}\r\n\t});\r\n});\r\n\r\nevents.on("changeRiggingMode", mode => {\r\n\trigModeBtns.removeClass("selected");\r\n\tswitch (mode) {\r\n\t\tcase "linear":\r\n\t\t\tdom.query("#riggingMode #linear").addClass("selected");\r\n\t\t\tconfig.riggingMode = "linear";\r\n\t\t\tbreak;\r\n\t\tcase "inverse":\r\n\t\t\tdom.query("#riggingMode #inverseKinematics").addClass("selected");\r\n\t\t\tconfig.riggingMode = "inverseKinematics";\r\n\t\t\tbreak;\r\n\t\tcase "forward":\r\n\t\t\tdom.query("#riggingMode #forwardKinematics").addClass("selected");\r\n\t\t\tconfig.riggingMode = "forwardKinematics";\r\n\t\t\tbreak;\r\n\t}\r\n});\r\n\r\nconst rigModeBtns = dom.query("#riggingMode button", true);\r\n\r\nrigModeBtns.on("click", event => {\r\n\tevents.emit("changeRiggingMode", event.target.dataset.mode);\r\n});\r\n\r\nconst autoAddKeyframeBtn = dom.query("#autoAddKeyframe");\r\nautoAddKeyframeBtn.on("click", () => {\r\n\tautoAddKeyframeBtn.toggleClass("selected");\r\n\r\n\tif (autoAddKeyframeBtn.hasClass("selected")) {\r\n\t\tconfig.animation.autoAddKeyframe = true;\r\n\t} else {\r\n\t\tconfig.animation.autoAddKeyframe = false;\r\n\t}\r\n});\r\n\r\ndom.query("#focusRig").on("click", () => {\r\n\tif (rigModel.bounds) {\r\n\t\tif (!rigModel.joints.length) return;\r\n\t\tcameraMovement.x = (rigModel.bounds.min.x + rigModel.bounds.max.x) / 2;\r\n\t\tcameraMovement.y = (rigModel.bounds.min.y + rigModel.bounds.max.y) / 2;\r\n\t}\r\n});\r\n\r\nconst cropBtn = dom.query("#displayCropApp");\r\ncropBtn.on("click", () => {\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (activeJoint) {\r\n\t\tif (activeJoint.skin) {\r\n\t\t\tif (activeJoint.skin.imageSrc) {\r\n\t\t\t\tlet img = new Image();\r\n\t\t\t\timg.src = activeJoint.skin.imageSrc;\r\n\r\n\t\t\t\timg.onload = function() {\r\n\t\t\t\t\tif (activeJoint.skin._vueCrop) {\r\n\t\t\t\t\t\tvue.cropApp.cropFrom = activeJoint.skin._vueCrop.from;\r\n\t\t\t\t\t\tvue.cropApp.cropTo = activeJoint.skin._vueCrop.to;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvue.cropApp.show(img);\r\n\t\t\t\t\tjointCrop = activeJoint;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\ndom.query("#removeSkin").on("click", () => {\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (activeJoint) {\r\n\t\tif (activeJoint.skin) {\r\n\t\t\tif (activeJoint.skin.imageSrc) {\r\n\r\n\t\t\t\tlet skin = JSON.parse(JSON.stringify(activeJoint.skin));\r\n\r\n\t\t\t\tdelete skin.imageSrc;\r\n\t\t\t\tdelete skin.image;\r\n\r\n\t\t\t\trigModel.editJoint(activeJoint.id, {\r\n\t\t\t\t\tskin: skin\r\n\t\t\t\t});\r\n\r\n\t\t\t\thistory.add({\r\n\t\t\t\t\tlabel: "Remove joint skin",\r\n\t\t\t\t\tvalue: rigModel.clone(),\r\n\t\t\t\t\tgroup: "keyframe"\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\ndom.query("#resetOffset").on("click", () => {\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (activeJoint) {\r\n\t\tif (activeJoint.skin) {\r\n\t\t\tif (activeJoint.skin.offset) {\r\n\t\t\t\tif (activeJoint.skin.offset.x != 0 || activeJoint.skin.offset.y != 0 || activeJoint.skin.offset.scaleX != 1 || activeJoint.skin.offset.scaleY != 1 || activeJoint.skin.offset.angle != 0) {\r\n\r\n\t\t\t\t\tlet skin = JSON.parse(JSON.stringify(activeJoint.skin));\r\n\r\n\t\t\t\t\tskin.offset.x = 0;\r\n\t\t\t\t\tskin.offset.y = 0;\r\n\t\t\t\t\tskin.offset.scaleX = 1;\r\n\t\t\t\t\tskin.offset.scaleY = 1;\r\n\t\t\t\t\tskin.offset.angle = 0;\r\n\r\n\t\t\t\t\trigModel.editJoint(activeJoint.id, {\r\n\t\t\t\t\t\tskin: skin\r\n\t\t\t\t\t}, true);\r\n\r\n\t\t\t\t\tsetJointProperties(activeJoint);\r\n\r\n\t\t\t\t\thistory.add({\r\n\t\t\t\t\t\tlabel: "Reset transform offset",\r\n\t\t\t\t\t\tvalue: rigModel.clone(),\r\n\t\t\t\t\t\tgroup: "keyframe"\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\trigModel.updateSkin();\r\n\t\t\t\t\trigModel.updateBounds();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nevents.on("crop", (crop, _vueCrop) => {\r\n\trigModel.editJoints((joint, frame) => {\r\n\t\tif (joint.id === jointCrop.id) {\r\n\t\t\tjoint.skin.crop = JSON.parse(JSON.stringify(crop));\r\n\t\t\tjoint.skin._vueCrop = {\r\n\t\t\t\tfrom: {\r\n\t\t\t\t\tx: _vueCrop.from.x,\r\n\t\t\t\t\ty: _vueCrop.from.y\r\n\t\t\t\t},\r\n\t\t\t\tto: {\r\n\t\t\t\t\tx: _vueCrop.to.x,\r\n\t\t\t\t\ty: _vueCrop.to.y\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\trigModel.updateSkin(frame.joints);\r\n\t\t}\r\n\t});\r\n\r\n\trigModel.updateSubKeyframes();\r\n\trigModel.updateBounds();\r\n\r\n\thistory.add({\r\n\t\tlabel: "Crop skin",\r\n\t\tvalue: rigModel.clone(),\r\n\t\tgroup: "keyframe"\r\n\t});\r\n});\r\n\r\nevents.on("materialChange", url => {\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (url) {\r\n\t\tcropBtn.removeClass("disabled");\r\n\t} else {\r\n\t\tcropBtn.addClass("disabled");\r\n\t\treturn;\r\n\t}\r\n\r\n\tutils.loadImage(url).then(res => {\r\n\t\tif (activeJoint) {\r\n\t\t\tlet x = parseFloat(dom.query("#skinPositionX").value());\r\n\t\t\tlet y = parseFloat(dom.query("#skinPositionY").value());\r\n\t\t\tlet scaleX = parseFloat(dom.query("#skinScaleX").value());\r\n\t\t\tlet scaleY = parseFloat(dom.query("#skinScaleY").value());\r\n\t\t\tlet angle = parseFloat(dom.query("#skinAngle").value());\r\n\r\n\t\t\tlet crop = {\r\n\t\t\t\tfrom: {\r\n\t\t\t\t\tx: 0,\r\n\t\t\t\t\ty: 0\r\n\t\t\t\t},\r\n\t\t\t\tto: {\r\n\t\t\t\t\tx: res.width,\r\n\t\t\t\t\ty: res.height\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tif (activeJoint.skin) {\r\n\t\t\t\tif (activeJoint.skin.crop) {\r\n\t\t\t\t\tcrop.from.x = activeJoint.skin.crop.from.x;\r\n\t\t\t\t\tcrop.from.y = activeJoint.skin.crop.from.y;\r\n\t\t\t\t\tcrop.to.x = activeJoint.skin.crop.to.x;\r\n\t\t\t\t\tcrop.to.y = activeJoint.skin.crop.to.y;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tactiveJoint.skin.offset = {\r\n\t\t\t\t\tx: x || 0,\r\n\t\t\t\t\ty: y || 0,\r\n\t\t\t\t\tscaleX: scaleX || 0,\r\n\t\t\t\t\tscaleY: scaleY || 0,\r\n\t\t\t\t\tangle: utils.radians(utils.map(angle, 0, 360, -180, 180)) + Math.PI || 0\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\trigModel.editJoints((joint, frame) => {\r\n\t\t\t\tif (joint.id === activeJoint.id) {\r\n\t\t\t\t\tjoint.skin.imageSrc = res.url;\r\n\t\t\t\t\tjoint.skin.image = new Image();\r\n\t\t\t\t\tjoint.skin.image.src = res.url;\r\n\t\t\t\t\tjoint.skin.crop = JSON.parse(JSON.stringify(crop));\r\n\r\n\t\t\t\t\tlet _vc = activeJoint.skin._vueCrop;\r\n\t\t\t\t\tif (typeof _vc == "object" && _vc) {\r\n\t\t\t\t\t\tjoint.skin._vueCrop = JSON.parse(JSON.stringify(_vc)) || null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\trigModel.updateSkin(frame.joints);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\trigModel.updateSubKeyframes();\r\n\t\t\trigModel.updateBounds();\r\n\r\n\t\t\thistory.add({\r\n\t\t\t\tlabel: "Change skin",\r\n\t\t\t\tvalue: rigModel.clone(),\r\n\t\t\t\tgroup: "keyframe"\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n});\r\n\r\nfunction createJointElement(id, name) {\r\n\tlet jointEl = dom.create("div");\r\n\tjointEl.addClass("joint");\r\n\tlet jointBtn = jointEl.create("button");\r\n\tjointBtn.addClass("name", "darko-d");\r\n\tlet jointImg = jointBtn.create("img");\r\n\tjointImg.attr("src", "assets/svg/joint.svg");\r\n\tlet jointText = jointBtn.create("p");\r\n\tjointText.text(name);\r\n\tlet childWrapper = jointEl.create("div");\r\n\tchildWrapper.addClass("children");\r\n\r\n\tjointEl.attr("id", id);\r\n\r\n\tdom.query("#jointApp button.name.active", true).removeClass("active");\r\n\r\n\tlet joint = rigModel.joints.find(j => j.id === id);\r\n\tif (joint) {\r\n\t\tif (rigModel.activeJoint == joint) {\r\n\t\t\tjointBtn.addClass("active");\r\n\t\t}\r\n\t}\r\n\r\n\tlet jointApp = dom.query("#jointApp");\r\n\tjointApp.node.scrollTop = jointApp.node.scrollHeight;\r\n\tjointApp.node.scrollLeft = jointApp.node.scrollWidth;\r\n\r\n\tjointBtn.on("click", () => {\r\n\t\tif (!jointBtn.hasClass("active")) {\r\n\t\t\tlet prev = dom.query("#jointApp button.name.active");\r\n\t\t\tprev.removeClass("active");\r\n\t\t\tjointBtn.addClass("active");\r\n\r\n\t\t\tlet joint = rigModel.joints.find(j => j.id === id);\r\n\t\t\tif (joint) {\r\n\t\t\t\trigModel.selectJoint(joint.position.x, joint.position.y);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (vue.timeline.graph.state.isPlaying) {\r\n\t\t\tvue.timeline.graph.stop();\r\n\t\t}\r\n\r\n\t\tactivePane = "joints";\r\n\t});\r\n\r\n\tjointBtn.on("dblclick", () => {\r\n\t\tcameraMovement.set(rigModel.activeJoint.position);\r\n\t});\r\n\r\n\treturn jointEl;\r\n}\r\n\r\nfunction setJointProperties(joint) {\r\n\tlet propertyApp = dom.query("#propertyApp");\r\n\tif (joint) {\r\n\t\tif (!vue.timeline.graph.state.isPlaying) {\r\n\t\t\tpropertyApp.removeClass("disabled");\r\n\t\t}\r\n\r\n\t\t//Prop\r\n\t\tlet nameEl = propertyApp.query("#jointName");\r\n\t\tlet lengthEl = propertyApp.query("#jointLength");\r\n\t\tlet zIndexEl = propertyApp.query("#jointZIndex");\r\n\t\tnameEl.value(joint.name);\r\n\t\tlengthEl.value(joint.length.toFixed(2));\r\n\t\tzIndexEl.value(parseInt(joint.zIndex));\r\n\r\n\t\tif (!zIndexEl.node._lastValue) {\r\n\t\t\tzIndexEl.node._lastValue = zIndexEl.value();\r\n\t\t}\r\n\r\n\t\tif (!nameEl.node._lastValue) {\r\n\t\t\tnameEl.node._lastValue = nameEl.value();\r\n\t\t}\r\n\r\n\t\t//Transform\r\n\t\tlet xEl = propertyApp.query("#jointX");\r\n\t\tlet yEl = propertyApp.query("#jointY");\r\n\t\tlet angleEl = propertyApp.query("#jointAngle");\r\n\r\n\t\txEl.value(joint.position.x.toFixed(2));\r\n\t\tyEl.value(joint.position.y.toFixed(2));\r\n\t\tlet jointAngle = utils.degrees(utils.map(joint.angle, -Math.PI, Math.PI, 0, Math.PI * 2));\r\n\t\tangleEl.value(jointAngle.toFixed(2));\r\n\r\n\t\t//Skinning\r\n\t\tif (joint.skin) {\r\n\t\t\tif (joint.skin.imageSrc) {\r\n\t\t\t\tcropBtn.removeClass("disabled");\r\n\t\t\t} else {\r\n\t\t\t\tcropBtn.addClass("disabled");\r\n\t\t\t}\r\n\r\n\t\t\tif (joint.skin.offset) {\r\n\t\t\t\tlet x = dom.query("#skinPositionX");\r\n\t\t\t\tlet y = dom.query("#skinPositionY");\r\n\t\t\t\tlet scaleX = dom.query("#skinScaleX");\r\n\t\t\t\tlet scaleY = dom.query("#skinScaleY");\r\n\t\t\t\tlet angle = dom.query("#skinAngle");\r\n\r\n\t\t\t\tx.value(joint.skin.offset.x.toFixed(2));\r\n\t\t\t\ty.value(joint.skin.offset.y.toFixed(2));\r\n\t\t\t\tscaleX.value(joint.skin.offset.scaleX.toFixed(2));\r\n\t\t\t\tscaleY.value(joint.skin.offset.scaleY.toFixed(2));\r\n\t\t\t\tlet offsetAngle = utils.degrees(joint.skin.offset.angle);\r\n\t\t\t\tangle.value(offsetAngle.toFixed(2));\r\n\r\n\t\t\t\tif (!x.node._lastValue) {\r\n\t\t\t\t\tx.node._lastValue = x.value();\r\n\t\t\t\t}\r\n\t\t\t\tif (!y.node._lastValue) {\r\n\t\t\t\t\ty.node._lastValue = y.value();\r\n\t\t\t\t}\r\n\t\t\t\tif (!scaleX.node._lastValue) {\r\n\t\t\t\t\tscaleX.node._lastValue = scaleX.value();\r\n\t\t\t\t}\r\n\t\t\t\tif (!scaleY.node._lastValue) {\r\n\t\t\t\t\tscaleY.node._lastValue = scaleY.value();\r\n\t\t\t\t}\r\n\t\t\t\tif (!angle.node._lastValue) {\r\n\t\t\t\t\tangle.node._lastValue = angle.value();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tpropertyApp.addClass("disabled");\r\n\t}\r\n}\r\n\r\nevents.on("timelineSeeked", () => {\r\n\tif (vue.timeline.graph.state.isPlaying) return;\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (activeJoint) {\r\n\t\tsetJointProperties(activeJoint);\r\n\t}\r\n\r\n\tevents.emit("jointChange", rigModel.joints);\r\n\r\n\tactivePane = "timeline";\r\n});\r\n\r\nevents.on("jointChange", joints => {\r\n\tjoints = joints || rigModel.joints;\r\n\t//Joint Pane >\r\n\t//Adding elements\r\n\tlet jointApp = dom.query("#jointApp");\r\n\tfor (var i = 0; i < joints.length; i++) {\r\n\t\tlet joint = joints[i];\r\n\t\t//Check if it exists in dom\r\n\t\tlet check = jointApp.query("#" + joint.id);\r\n\t\tif (!check.node) {\r\n\t\t\tlet el = createJointElement(joint.id, joint.name);\r\n\t\t\tjointApp.append(el);\r\n\t\t}\r\n\t}\r\n\r\n\t//Fix each element hierarchy\r\n\tlet jointAppChildren = dom.query("#jointApp > *", true);\r\n\tfor (var i = 0; i < jointAppChildren.elements.length; i++) {\r\n\t\tlet el = jointAppChildren.elements[i];\r\n\t\tlet joint = joints.find(j => j.id === el.node.id);\r\n\t\t//Search for parent\r\n\t\tif (joint) {\r\n\t\t\tif (joint.parent) {\r\n\t\t\t\tlet parentEl = dom.query("#" + joint.parent.id + " > .children");\r\n\t\t\t\tparentEl.append(el);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//Updating elements\r\n\tlet jointAppJoints = dom.query("#jointApp .joint", true);\r\n\tfor (var i = 0; i < jointAppJoints.elements.length; i++) {\r\n\t\tlet el = jointAppJoints.elements[i];\r\n\t\tlet rigJoint = rigModel.joints.find(j => j.id === el.node.id);\r\n\t\tif (!rigJoint) {\r\n\t\t\tlet parentEl = dom.query(el.node.parentNode.parentNode);\r\n\r\n\t\t\t//If a joint is deleted, its parent element will inherit its children elements\r\n\t\t\tif (parentEl) {\r\n\t\t\t\tlet newParent;\r\n\t\t\t\tif (parentEl.hasClass("joint")) {\r\n\t\t\t\t\tnewParent = dom.query("#" + parentEl.node.id + " > .children");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnewParent = dom.query("#jointApp");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet children = dom.query("#" + el.node.id + " > .children > .joint", true);\r\n\t\t\t\tnewParent.append(children);\r\n\t\t\t}\r\n\r\n\t\t\tel.remove();\r\n\t\t} else {\r\n\t\t\tif (el.node.id === rigModel.activeJoint.id) {\r\n\t\t\t\tel.query("button.name", true).addClass("active");\r\n\t\t\t} else {\r\n\t\t\t\tel.query("button.name.active", true).removeClass("active");\r\n\t\t\t}\r\n\r\n\t\t\tel.query("button.name").text(rigJoint.name, true);\r\n\t\t}\r\n\t}\r\n\r\n\t//Properties Pane >\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tsetJointProperties(activeJoint);\r\n\r\n\t//Hide angle, length, & skinning properties if there\'s no parent\r\n\tif (rigModel.activeJoint) {\r\n\t\tif (!rigModel.activeJoint.parent) {\r\n\t\t\tdom.query(dom.query("#jointAngle").node.parentNode).css("display", "none");\r\n\t\t\tdom.query(dom.query("#jointLength").node.parentNode).css("display", "none");\r\n\t\t\tdom.query(".section.skinning").css("display", "none");\r\n\t\t} else {\r\n\t\t\tdom.query(dom.query("#jointAngle").node.parentNode).css("display", "flex");\r\n\t\t\tdom.query(dom.query("#jointLength").node.parentNode).css("display", "flex");\r\n\t\t\tdom.query(".section.skinning", true).css("display", "flex");\r\n\t\t}\r\n\t}\r\n});\r\n\r\nevents.on("jointNameInputChange", ignoreHistory => {\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (activeJoint) {\r\n\t\tlet name = dom.query("#jointName").value();\r\n\t\tactiveJoint.name = name;\r\n\r\n\t\trigModel.editJoint(activeJoint.id, {\r\n\t\t\tname: name\r\n\t\t});\r\n\r\n\t\tevents.emit("jointChange");\r\n\r\n\t\tif (!ignoreHistory) {\r\n\t\t\thistory.add({\r\n\t\t\t\tlabel: "Change joint name",\r\n\t\t\t\tvalue: rigModel.clone(),\r\n\t\t\t\tgroup: "keyframe"\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n});\r\n\r\nevents.on("jointZIndexInputChange", ignoreHistory => {\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (activeJoint) {\r\n\t\tlet zIndex = dom.query("#jointZIndex").value();\r\n\t\tactiveJoint.zIndex = zIndex;\r\n\r\n\t\trigModel.editJoint(activeJoint.id, {\r\n\t\t\tzIndex: zIndex\r\n\t\t});\r\n\r\n\t\tevents.emit("jointChange");\r\n\r\n\t\tif (!ignoreHistory) {\r\n\t\t\thistory.add({\r\n\t\t\t\tlabel: "Change joint Z-Index",\r\n\t\t\t\tvalue: rigModel.clone(),\r\n\t\t\t\tgroup: "keyframe"\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n})\r\n\r\nevents.on("jointSkinningInputChange", ignoreHistory => {\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (activeJoint) {\r\n\t\tlet activeJointSkin = activeJoint.skin;\r\n\t\tlet x = parseFloat(dom.query("#skinPositionX").value());\r\n\t\tlet y = parseFloat(dom.query("#skinPositionY").value());\r\n\t\tlet scaleX = parseFloat(dom.query("#skinScaleX").value());\r\n\t\tlet scaleY = parseFloat(dom.query("#skinScaleY").value());\r\n\t\tlet angle = parseFloat(dom.query("#skinAngle").value());\r\n\r\n\t\tactiveJointSkin.offset = {\r\n\t\t\tx: x,\r\n\t\t\ty: y,\r\n\t\t\tscaleX: scaleX,\r\n\t\t\tscaleY: scaleY,\r\n\t\t\tangle: utils.radians(utils.map(angle, 0, 360, -180, 180)) + Math.PI\r\n\t\t};\r\n\r\n\t\tif (!config.animateSkin) {\r\n\t\t\trigModel.editJoint(activeJoint.id, {\r\n\t\t\t\tskin: activeJointSkin\r\n\t\t\t}, true);\r\n\t\t}\r\n\r\n\t\tif (!ignoreHistory) {\r\n\t\t\thistory.add({\r\n\t\t\t\tlabel: "Change skin offset",\r\n\t\t\t\tvalue: rigModel.clone(),\r\n\t\t\t\tgroup: "keyframe"\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\trigModel.updateSubKeyframes();\r\n\t\trigModel.updateBounds();\r\n\t}\r\n});\r\n\r\nevents.on("jointPositionInputChange", () => {\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (activeJoint) {\r\n\t\tlet x = parseFloat(dom.query("#jointX").value()) || 0;\r\n\t\tlet y = parseFloat(dom.query("#jointY").value()) || 0;\r\n\t\trigModel.moveJoint(x, y);\r\n\t}\r\n});\r\n\r\nevents.on("jointAngleInputChange", () => {\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (activeJoint) {\r\n\t\tif (activeJoint.parent) {\r\n\t\t\tlet angle = parseFloat(dom.query("#jointAngle").value()) || 0;\r\n\t\t\tangle = utils.radians(utils.map(angle, 0, 360, -180, 180));\r\n\t\t\tlet x = activeJoint.parent.position.x - Math.cos(angle) * activeJoint.length;\r\n\t\t\tlet y = activeJoint.parent.position.y - Math.sin(angle) * activeJoint.length;\r\n\t\t\trigModel.moveJoint(x, y);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nevents.on("jointLengthInputChange", () => {\r\n\tlet activeJoint = rigModel.activeJoint;\r\n\tif (activeJoint) {\r\n\t\tlet length = parseFloat(dom.query("#jointLength").value()) || 0;\r\n\t\tactiveJoint.length = length;\r\n\t\trigModel.moveJoint(activeJoint.position.x, activeJoint.position.y);\r\n\t}\r\n});\r\n\r\nfunction addHistoryEl(event) {\r\n\tlet parent = dom.query("#historyApp");\r\n\tparent.query(".history.current", true).removeClass("current");\r\n\tlet historyEl = parent.create("div");\r\n\thistoryEl.attr("id", event.id);\r\n\thistoryEl.addClass("history", "current");\r\n\tlet descEl = historyEl.create("p");\r\n\tdescEl.text(event.label);\r\n\tparent.node.scrollTop = parent.node.scrollHeight;\r\n\r\n\thistoryEl.on("click", () => {\r\n\t\tif (event.group == "keyframe") {\r\n\t\t\tparent.query(".history.current", true).removeClass("current");\r\n\t\t\thistoryEl.addClass("current");\r\n\r\n\t\t\thistory.jump(event.id);\r\n\t\t\trigModel.import(event.value);\r\n\r\n\t\t\tvue.timeline.graph.updateState();\r\n\t\t\tvue.timeline.graph.redraw();\r\n\r\n\t\t\tsetJointProperties(rigModel.activeJoint);\r\n\r\n\r\n\t\t\tif (vue.timeline.graph.state.isPlaying) {\r\n\t\t\t\tvue.timeline.graph.stop();\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\nevents.on("undo", () => {\r\n\tlet prev = history.getPrevious();\r\n\tif (!prev) return;\r\n\tif (prev.group == "keyframe") {\r\n\t\trigModel.import(prev.value);\r\n\t\thistory.backward();\r\n\r\n\t\tvue.timeline.graph.updateState();\r\n\t\tvue.timeline.graph.redraw();\r\n\r\n\t\tsetJointProperties(rigModel.activeJoint);\r\n\t}\r\n\r\n\tdom.query(".history.current", true).removeClass("current");\r\n\tlet newCurrent = dom.query("#" + prev.id);\r\n\tnewCurrent.addClass("current");\r\n\tlet parent = dom.query("#historyApp");\r\n\tparent.node.scrollTop = newCurrent.node.offsetTop;\r\n});\r\n\r\nevents.on("redo", () => {\r\n\tlet next = history.getNext();\r\n\tif (!next) return;\r\n\tif (next.group == "keyframe") {\r\n\t\trigModel.import(next.value);\r\n\t\thistory.forward();\r\n\r\n\t\tvue.timeline.graph.updateState();\r\n\t\tvue.timeline.graph.redraw();\r\n\r\n\t\tsetJointProperties(rigModel.activeJoint);\r\n\t}\r\n\r\n\tdom.query(".history.current", true).removeClass("current");\r\n\tlet newCurrent = dom.query("#" + next.id);\r\n\tnewCurrent.addClass("current");\r\n\tlet parent = dom.query("#historyApp");\r\n\tparent.node.scrollTop = newCurrent.node.offsetTop;\r\n});\r\n\r\nevents.on("historyChange", () => {\r\n\t//Autosave\r\n\tif (history.eventCount % config.autosave.threshold == 0) {\r\n\t\tlet model = rigModel.toJSON(null, true);\r\n\t\tlocalStorage.setItem(config.autosave.label, JSON.stringify(model));\r\n\t}\r\n\r\n\t//Remove elements that aren\'t in the history anymore\r\n\tlet historyElements = dom.query("#historyApp .history", true);\r\n\tfor (var i = 0; i < historyElements.elements.length; i++) {\r\n\t\tlet el = historyElements.elements[i].node;\r\n\t\tlet event = history.events.find(e => e.id === el.id);\r\n\t\tif (!event) {\r\n\t\t\tel.remove();\r\n\t\t}\r\n\t}\r\n\r\n\tlet latest = history.getLatest();\r\n\taddHistoryEl(latest);\r\n});\r\n\r\n//Loading autosaved data\r\nutils.loadJSONData(config.autosave.label, data => {\r\n\trigModel.import(rigModel.fromJSON(data));\r\n\r\n\thistory.add({\r\n\t\tlabel: "Load autosave",\r\n\t\tvalue: rigModel.clone(),\r\n\t\tgroup: "keyframe"\r\n\t});\r\n});\r\n\r\nevents.on("clearJoints", () => {\r\n\tif (rigModel.joints.length) {\r\n\t\tdom.query("#jointApp *").remove();\r\n\t}\r\n\trigModel.reset();\r\n\tdom.query("#propertyApp").addClass("disabled");\r\n});\r\n\r\nevents.on("resetTimeline", () => {\r\n\t//Config\r\n\tdocument.getElementById("frameCount").value = 30;\r\n\tdocument.getElementById("animationSpeed").value = 30;\r\n\tvue.timeline.app.fixData();\r\n\r\n\t//Scrollbar\r\n\tvue.timeline.graph.scrollbar.left = 0;\r\n\tvue.timeline.graph.scrollbar.right = vue.timeline.graph.canvas.width;\r\n\tvue.timeline.graph.scrollbar.width = vue.timeline.graph.canvas.width;\r\n\r\n\t//Timeline\r\n\tvue.timeline.graph.setCurrentMark(0);\r\n\tvue.timeline.graph.playbackHandle.start.mark = 0;\r\n\tvue.timeline.graph.playbackHandle.start._x = vue.timeline.graph.markToX(vue.timeline.graph.playbackHandle.start.mark);\r\n\tvue.timeline.graph.playbackHandle.end.mark = vue.timeline.app.totalFrames - 1;\r\n\tvue.timeline.graph.playbackHandle.end._x = vue.timeline.graph.markToX(vue.timeline.graph.playbackHandle.end.mark);\r\n\r\n\tvue.timeline.graph.redraw();\r\n});\r\n\r\nevents.on("resetCamera", () => {\r\n\tmouseLast.reset();\r\n\tcameraMovement.reset();\r\n\tcameraDistance = config.world.zoom;\r\n});\r\n\r\nevents.on("deleteKeyframe", () => {\r\n\tlet frame = rigModel.getKeyframe("index", vue.timeline.graph.state.currentFrame);\r\n\tif (frame) {\r\n\t\tif (frame.type == "head" && !frame.locked) {\r\n\t\t\trigModel.deleteKeyframe(frame.id);\r\n\t\t\thistory.add({\r\n\t\t\t\tlabel: "Delete keyframe",\r\n\t\t\t\tvalue: rigModel.clone(),\r\n\t\t\t\tgroup: "keyframe"\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n});\r\n\r\nevents.on("renderSleep", () => {\r\n\tsleep = true;\r\n});\r\n\r\nevents.on("renderFocus", () => {\r\n\tsleep = false;\r\n});\r\n\r\ndom.query("#fileButton").on("mouseup", function() {\r\n\tlet fileApp = vue.fileApp;\r\n\tif (fileApp.hidden) {\r\n\t\tfileApp.show(mouse.x + 5, mouse.y + 5);\r\n\t}\r\n});\r\n\r\ndom.query("#optionButton").on("mouseup", function() {\r\n\tlet optionApp = vue.optionApp;\r\n\tif (optionApp.hidden) {\r\n\t\toptionApp.show(mouse.x + 5, mouse.y + 5);\r\n\t}\r\n});\r\n\r\nlet previousAction;\r\nkey.on("keydown", function(event) {\r\n\tlet pickedAction = actions[shortcuts[event.code]];\r\n\tif (pickedAction) {\r\n\t\tsetAction(pickedAction);\r\n\t\taction = pickedAction;\r\n\t}\r\n\r\n\tif (event.ctrlKey) {\r\n\t\tif (event.keyCode == 90) {\r\n\t\t\tevents.emit("undo");\r\n\t\t}\r\n\r\n\t\tif (event.keyCode == 89) {\r\n\t\t\tevents.emit("redo");\r\n\t\t}\r\n\t}\r\n\r\n\tif (event.shiftKey) {\r\n\t\tif (action == actions.add) {\r\n\t\t\tif (rigModel.activeJoint) {\r\n\t\t\t\tif (!mirror) {\r\n\t\t\t\t\tmirror = rigModel.activeJoint;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (event.keyCode == 32) {\r\n\t\tif (action != actions.pan) {\r\n\t\t\tpreviousAction = action;\r\n\t\t\tsetAction(actions.pan);\r\n\t\t}\r\n\t}\r\n\r\n\t//Delete\r\n\tif (event.keyCode == 46) {\r\n\t\tif (activePane == "joints") {\r\n\t\t\tlet activeJoint = rigModel.activeJoint;\r\n\t\t\tif (activeJoint) {\r\n\t\t\t\trigModel.removeJointById(activeJoint.id);\r\n\t\t\t}\r\n\t\t} else if (activePane == "timeline") {\r\n\t\t\tevents.emit("deleteKeyframe");\r\n\t\t}\r\n\t}\r\n});\r\n\r\nkey.on("keyup", function(event) {\r\n\tif (mirror) mirror = null;\r\n\r\n\tif (previousAction) {\r\n\t\tsetAction(previousAction);\r\n\t\tpreviousAction = undefined;\r\n\t}\r\n});\r\n\r\nmouse.on("mouseup", function() {\r\n\tif (rigModel._moved) {\r\n\t\thistory.add({\r\n\t\t\tlabel: "Move joint",\r\n\t\t\tvalue: rigModel.clone(),\r\n\t\t\tgroup: "keyframe"\r\n\t\t});\r\n\r\n\t\t//Properties Pane >\r\n\t\tlet activeJoint = rigModel.activeJoint;\r\n\t\tsetJointProperties(activeJoint);\r\n\r\n\t\trigModel._moved = false;\r\n\t}\r\n});\r\n\r\nmouse.on("mousedown", function() {\r\n\tvue.fileApp.hide();\r\n\tvue.optionApp.hide();\r\n\tvue.contextMenuApp.hide();\r\n\tselectOptions.css("display", "none");\r\n});\r\n\r\nmouse.on("mousemove", function() {\r\n\tif (!mouse.dragged) {\r\n\t\tmouseLast.set(worldMouse);\r\n\t}\r\n\r\n\tif (mouse.x <= renderer.bounds.x || mouse.x >= renderer.bounds.x + renderer.bounds.width || mouse.y <= renderer.bounds.y || mouse.y >= renderer.bounds.y + renderer.bounds.height) {\r\n\t\tactionPreview.css("display", "none");\r\n\t} else {\r\n\t\tactionPreview.css({\r\n\t\t\tdisplay: "block",\r\n\t\t\ttop: `${mouse.y - 10}px`,\r\n\t\t\tleft: `${mouse.x + 9}px`\r\n\t\t});\r\n\t}\r\n});\r\n\r\nlet actionPreview = dom.query("#actionPreview");\r\n\r\nrenderer.canvas.addEventListener("mousemove", function(e) {\r\n\tif (mouse.dragged && !sleep) {\r\n\t\tif (action === actions.pan) {\r\n\t\t\tcameraMovement.set({\r\n\t\t\t\tx: mouseLast.x - worldMouse.x + renderer.camera.movement.x,\r\n\t\t\t\ty: mouseLast.y - worldMouse.y + renderer.camera.movement.y\r\n\t\t\t});\r\n\r\n\t\t\tcameraMovement.x = utils.clamp(cameraMovement.x, -9000, 9000);\r\n\t\t\tcameraMovement.y = utils.clamp(cameraMovement.y, -9000, 9000);\r\n\t\t}\r\n\t}\r\n\r\n\tif (action === actions.move && !sleep) {\r\n\t\tif (mouse.pressed) {\r\n\t\t\tactivePane = "joints";\r\n\t\t\trigModel.moveJoint(worldMouse.x, worldMouse.y);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nrenderer.canvas.addEventListener("click", function() {\r\n\tif (vue.overlayApp.hidden && vue.overlayConfigApp.hidden && vue.fileApp.hidden && vue.loadApp.hidden && vue.saveApp.hidden && vue.optionApp.hidden) {\r\n\t\tif (action == actions.add) {\r\n\t\t\tif (mirror) {\r\n\t\t\t\tlet mirrorX = rigModel.activeJoint.position.x - worldMouse.x + mirror.position.x;\r\n\t\t\t\tlet joint = rigModel.addJoint(mirrorX, worldMouse.y, {\r\n\t\t\t\t\tparent: mirror,\r\n\t\t\t\t\tignoreHistory: true,\r\n\t\t\t\t\tignoreDefaults: true\r\n\t\t\t\t});\r\n\t\t\t\tmirror = joint;\r\n\t\t\t}\r\n\r\n\t\t\trigModel.addJoint(worldMouse.x, worldMouse.y);\r\n\r\n\t\t\tactivePane = "joints";\r\n\t\t}\r\n\r\n\t\tif (action === actions.remove) {\r\n\t\t\trigModel.selectJoint(worldMouse.x, worldMouse.y);\r\n\t\t\trigModel.removeJointByPosition(worldMouse.x, worldMouse.y);\r\n\t\t\tactivePane = "joints";\r\n\t\t}\r\n\r\n\t\tif (action === actions.select) {\r\n\t\t\trigModel.selectJoint(worldMouse.x, worldMouse.y);\r\n\t\t\tactivePane = "joints";\r\n\t\t}\r\n\t}\r\n});\r\n\r\nrenderer.canvas.addEventListener("mousewheel", function() {\r\n\tif (mouse.scrollTop) {\r\n\t\tcameraDistance -= 100;\r\n\t} else {\r\n\t\tcameraDistance += 100;\r\n\t}\r\n\r\n\tcameraDistance = utils.clamp(cameraDistance, config.world.minZoom, config.world.maxZoom);\r\n});\r\n\r\nwindow.dom = dom;\r\n\r\nfunction fixRendererSize() {\r\n\tlet toolApp = dom.query("#toolApp");\r\n\tlet canvasContainer = dom.query(".canvas-container");\r\n\tlet nav = dom.query("#navigation");\r\n\tlet width = canvasContainer.node.offsetWidth - 1 - toolApp.node.offsetWidth;\r\n\tlet height = innerHeight - nav.node.offsetHeight - vue.timeline.app.$el.offsetHeight;\r\n\trenderer.setSize(width, height);\r\n}\r\n\r\naddEventListener("resize", function() {\r\n\tfixRendererSize();\r\n\tvue.fileApp.hide();\r\n\tvue.optionApp.hide();\r\n\tvue.contextMenuApp.hide();\r\n});\r\n\r\nfixRendererSize();\r\nrenderer.camera.setZoomSpeed(0.2);\r\nrenderer.camera.setMoveSpeed(0.6);\r\n\r\nlet showBounds = dom.query("#showBounds");\r\nlet showGrid = dom.query("#showGrid");\r\nrenderer.draw(() => {\r\n\tlet focused = vue.overlayApp.hidden && vue.overlayConfigApp.hidden && vue.fileApp.hidden && vue.loadApp.hidden && vue.saveApp.hidden && vue.optionApp.hidden;\r\n\r\n\tworldMouse.set(renderer.camera.screenToWorld(mouse.x - renderer.bounds.x, mouse.y - renderer.bounds.y));\r\n\r\n\t//Background\r\n\trenderer.rect(0, 0, renderer.bounds.width, renderer.bounds.height, {\r\n\t\tfill: config.world.background\r\n\t});\r\n\r\n\trenderer.camera.begin(function() {\r\n\t\trenderer.camera.moveTo(cameraMovement.x, cameraMovement.y);\r\n\t\trenderer.camera.zoomTo(cameraDistance);\r\n\r\n\t\t//Draw overlay\r\n\t\tlet overlayFramesOffset = new Array(vue.overlayConfigApp.start - 1);\r\n\t\tlet trimStart = vue.overlayConfigApp.trimStart - 1;\r\n\t\tlet trimEnd = vue.overlayConfigApp.trimEnd - 1\r\n\t\tlet trimmedOverlayFrames = overlayFrames.slice(0).splice(trimStart, trimEnd - trimStart);\r\n\t\tlet modifiedOverlayFrames = overlayFramesOffset.concat(trimmedOverlayFrames);\r\n\r\n\t\tlet overlayIndex = vue.timeline.graph.state.currentMark;\r\n\t\tlet overlayFrame = modifiedOverlayFrames[overlayIndex];\r\n\t\tif (overlayFrame && showOverlay) {\r\n\t\t\trenderer.save();\r\n\t\t\trenderer.context.globalAlpha = vue.overlayConfigApp.opacity;\r\n\t\t\trenderer.context.scale(vue.overlayConfigApp.scale, vue.overlayConfigApp.scale);\r\n\t\t\trenderer.context.rotate(vue.overlayConfigApp.angle);\r\n\t\t\trenderer.context.drawImage(overlayFrame, -overlayFrame.width / 2, -overlayFrame.height / 2);\r\n\t\t\trenderer.restore();\r\n\t\t}\r\n\r\n\t\t//\r\n\t\tif (focused) {\r\n\t\t\tif (action === actions.add) {\r\n\t\t\t\tlet translucent = "rgba(240, 230, 255, 0.75)";\r\n\t\t\t\trenderer.save();\r\n\t\t\t\trenderer.context.globalCompositeOperation = "overlay";\r\n\t\t\t\tlet parent = rigModel.activeJoint;\r\n\t\t\t\tif (parent) {\r\n\t\t\t\t\trenderer.line(worldMouse.x, worldMouse.y, parent.position.x, parent.position.y, {\r\n\t\t\t\t\t\tlineWidth: config.render.segment.width,\r\n\t\t\t\t\t\tlineCap: "round",\r\n\t\t\t\t\t\tstroke: translucent\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tif (mirror) {\r\n\t\t\t\t\t\tlet mirrorX = parent.position.x - worldMouse.x + mirror.position.x;\r\n\t\t\t\t\t\trenderer.line(mirrorX, worldMouse.y, mirror.position.x, mirror.position.y, {\r\n\t\t\t\t\t\t\tlineWidth: config.render.segment.width,\r\n\t\t\t\t\t\t\tlineCap: "round",\r\n\t\t\t\t\t\t\tstroke: translucent\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\trenderer.circle(mirrorX, worldMouse.y, config.render.joint.radius, {\r\n\t\t\t\t\t\t\tfill: translucent\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\trenderer.circle(worldMouse.x, worldMouse.y, config.render.joint.radius, {\r\n\t\t\t\t\tfill: translucent\r\n\t\t\t\t});\r\n\r\n\t\t\t\trenderer.restore();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//Add grid\r\n\t\tif (showGrid.prop("checked")) {\r\n\t\t\tlet gridArea = 10000;\r\n\t\t\tlet gridSpacing = 20;\r\n\t\t\tfor (var x = -cameraDistance - gridArea; x < cameraDistance + gridArea; x += gridSpacing) {\r\n\t\t\t\trenderer.line(x, renderer.camera.viewport.top - gridArea, x, renderer.camera.viewport.bottom + gridArea, {\r\n\t\t\t\t\tstroke: "rgba(240, 230, 250, 0.2)",\r\n\t\t\t\t\tlineWidth: 0.2\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tfor (var y = -cameraDistance - gridArea; y < cameraDistance + gridArea; y += gridSpacing) {\r\n\t\t\t\trenderer.line(renderer.camera.viewport.left - gridArea, y, renderer.camera.viewport.right + gridArea, y, {\r\n\t\t\t\t\tstroke: "rgba(240, 230, 250, 0.2)",\r\n\t\t\t\t\tlineWidth: 0.2\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//Draw the model\'s bounds\r\n\t\tif (showBounds.prop("checked")) {\r\n\t\t\tlet boundsColor = "rgba(225, 50, 255, 0.5)";\r\n\t\t\tlet w = rigModel.bounds.max.x - rigModel.bounds.min.x;\r\n\t\t\tlet h = rigModel.bounds.max.y - rigModel.bounds.min.y;\r\n\t\t\tlet text = parseInt(w) + "x" + parseInt(h);\r\n\t\t\trenderer.text(text, rigModel.bounds.min.x, rigModel.bounds.min.y, {\r\n\t\t\t\talign: "left bottom",\r\n\t\t\t\tfont: "10px Consolas",\r\n\t\t\t\tfill: boundsColor\r\n\t\t\t});\r\n\r\n\t\t\trenderer.rect(rigModel.bounds.min.x, rigModel.bounds.min.y, w, h, {\r\n\t\t\t\tlineWidth: 0.35,\r\n\t\t\t\tstroke: boundsColor\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\trigModel.render(renderer);\r\n\t});\r\n});\r\n\r\nrenderer.render(() => {\r\n\trenderer.redraw();\r\n});\r\n\r\nif (__development) {\r\n\tkey.on("keyup", function() {\r\n\t\tif (key.code === 16) {\r\n\t\t\tconsole.log(history);\r\n\t\t\tconsole.log(rigModel);\r\n\t\t\tconsole.log(overlayFrames)\r\n\t\t}\r\n\t});\r\n}\n\n//# sourceURL=webpack:///./src/client/js/app.js?')},"./src/client/js/engine.js":function(module,exports){eval('class Engine {\r\n\tconstructor() {\r\n\t\tthis.frameRate = 0;\r\n\t\tthis.frameCount = 0;\r\n\t\tthis._targetFrameRate = 60;\r\n\t}\r\n\r\n\trun(f) {\r\n\t\tlet startTime = performance.now();\r\n\t\tlet lastRun = performance.now();\r\n\t\tlet delta;\r\n\t\tlet engine = this;\r\n\t\t(function animate() {\r\n\t\t\tdelta = (performance.now() - startTime) / 1000;\r\n\t\t\tengine.frameRate = 1 / delta;\r\n\t\t\tstartTime = performance.now();\r\n\t\t\tengine.frameCount++;\r\n\t\t\tif (typeof f == "function") f();\r\n\r\n\t\t\trequestAnimationFrame(animate);\r\n\t\t})();\r\n\t}\r\n}\r\n\r\nmodule.exports = {\r\n\tcreate: function() {\r\n\t\treturn new Engine();\r\n\t}\r\n};\n\n//# sourceURL=webpack:///./src/client/js/engine.js?')},"./src/client/js/extract.keyframes.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../lib/events.js */ "./src/lib/events.js");\r\nconst utils = __webpack_require__(/*! ../../lib/utils.js */ "./src/lib/utils.js");\r\nconst HAVE_ENOUGH_DATA = 4;\r\nlet pct;\r\n\r\nfunction extractFrames(url, options) {\r\n\toptions = options || {};\r\n\tif (options.drop) return;\r\n\r\n\tconst canvas = document.createElement("canvas");\r\n\tconst context = canvas.getContext("2d");\r\n\tconst video = document.createElement("video");\r\n\tvideo.crossOrigin = "anonymous"\r\n\tvideo.controls = true;\r\n\tvideo.muted = true;\r\n\tvideo.src = url;\r\n\tvideo.load();\r\n\r\n\tlet frames = [];\r\n\tlet start = options.start || 1;\r\n\tlet frameRate = options.frameRate || 24;\r\n\tlet quality = options.quality || 0.1;\r\n\tlet width = options.width || 640;\r\n\tlet height = options.height || 480;\r\n\r\n\tvideo.addEventListener("loadedmetadata", () => {\r\n\t\tlet end = options.end || video.duration;\r\n\t\tlet frameCount = options.frameCount || (end - start) * frameRate;\r\n\r\n\t\tlet size = utils.scaleSize(video.videoWidth, video.videoHeight, width, height);\r\n\t\tcanvas.width = size.width;\r\n\t\tcanvas.height = size.height;\r\n\r\n\t\tvideo.currentTime = start;\r\n\r\n\t\tvideo.addEventListener("seeked", () => {\r\n\t\t\tif (options.drop) {\r\n\t\t\t\tevents.emit("extractKeyframeDone", frames);\r\n\t\t\t} else {\r\n\t\t\t\tif (frames.length < frameCount) {\r\n\t\t\t\t\tevents.emit("extractKeyframeProgress", frameCount);\r\n\t\t\t\t\tvideo.currentTime += 1 / frameRate;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tevents.emit("extractKeyframeDone", frames);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n\r\n\tlet extract = events.on("extractKeyframeProgress", frameCount => {\r\n\t\tcontext.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n\t\tlet dataURL = canvas.toDataURL("image/jpeg", quality);\r\n\t\tlet img = new Image();\r\n\t\timg.crossOrigin = "anonymous";\r\n\t\timg.src = dataURL;\r\n\r\n\t\tlet data = {\r\n\t\t\timage: img,\r\n\t\t\ttime: video.currentTime\r\n\t\t};\r\n\r\n\t\tframes.push(data);\r\n\r\n\t\tcontext.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n\t\tif (typeof options.progress == "function") {\r\n\t\t\tpct = (frames.length / frameCount) * 100;\r\n\t\t\toptions.progress(data.image, pct);\r\n\t\t}\r\n\t});\r\n\r\n\tevents.once("extractKeyframeDone", frames => {\r\n\t\tframes.sort((a, b) => a.time - b.time);\r\n\t\tfor (var i = 0; i < frames.length; i++) {\r\n\t\t\tframes[i] = frames[i].image;\r\n\t\t}\r\n\r\n\t\toptions.done(frames);\r\n\t\tevents.removeListener(extract);\r\n\t\tcanvas.remove();\r\n\t});\r\n};\r\n\r\nmodule.exports = extractFrames;\n\n//# sourceURL=webpack:///./src/client/js/extract.keyframes.js?')},"./src/client/js/history.js":function(module,exports,__webpack_require__){eval('const utils = __webpack_require__(/*! ../../lib/utils.js */ "./src/lib/utils.js");\r\nconst config = __webpack_require__(/*! ../../lib/config.js */ "./src/lib/config.js");\r\nconst events = __webpack_require__(/*! ../../lib/events.js */ "./src/lib/events.js");\r\n\r\nclass History {\r\n\tconstructor() {\r\n\t\tthis.events = [];\r\n\t\tthis.present = null;\r\n\t\tthis.maxStates = 300;\r\n\t\tthis.eventCount = 0;\r\n\t}\r\n\r\n\tadd(options) {\r\n\t\toptions = options || {};\r\n\t\t\r\n\t\t//Clear redos/future events\r\n\t\tif (this.present) {\r\n\t\t\tthis.events.splice(0, this.events.indexOf(this.present));\r\n\t\t}\r\n\r\n\t\tlet event = {\r\n\t\t\tid: "E" + utils.uid(),\r\n\t\t\tlabel: options.label,\r\n\t\t\tvalue: options.value,\r\n\t\t\tgroup: options.group,\r\n\t\t\ttime: Date.now()\r\n\t\t};\r\n\r\n\t\tthis.present = event;\r\n\r\n\t\tthis.events.push(event);\r\n\r\n\t\tthis.sortByLatest();\r\n\r\n\t\tif (this.events.length > this.maxStates) {\r\n\t\t\tthis.events.pop();\r\n\t\t}\r\n\r\n\t\tthis.eventCount++;\r\n\t\tevents.emit("historyChange");\r\n\t}\r\n\r\n\tsortByLatest() {\r\n\t\tthis.events.sort((a, b) => b.time - a.time);\r\n\t}\r\n\r\n\tsortByOldest() {\r\n\t\tthis.events.sort((a, b) => a.time - b.time);\r\n\t}\r\n\r\n\tgetLatest() {\r\n\t\treturn this.events[0];\r\n\t}\r\n\r\n\tgetOldest() {\r\n\t\treturn this.events[this.events.length - 1];\r\n\t}\r\n\r\n\tgetNext() {\r\n\t\treturn this.events[this.events.indexOf(this.present) - 1] || null;\r\n\t}\r\n\r\n\tgetPrevious() {\r\n\t\treturn this.events[this.events.indexOf(this.present) + 1] || null;\r\n\t}\r\n\r\n\tforward() {\r\n\t\tthis.present = this.getNext();\r\n\t}\r\n\r\n\tbackward() {\r\n\t\tthis.present = this.getPrevious();\r\n\t}\r\n\r\n\tjump(id) {\r\n\t\tlet event = this.events.find(e => e.id === id);\r\n\t\tif (id) {\r\n\t\t\tthis.present = event;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst history = new History();\r\n\r\nmodule.exports = history;\n\n//# sourceURL=webpack:///./src/client/js/history.js?')},"./src/client/js/random.title.js":function(module,exports){eval('const randomVerbs = ["running", "walking", "dancing", "shivering", "jumping", "sleeping", "sitting", "flying", "cheering", "yielding", "punching", "kicking", "crawling", "painting", "smoking", "crouching", "driving", "sliding", "breathing", "hunting", "dying", "moving", "aroused", "tickled", "thrilled", "backflipping", "frontflipping", "falling"];\r\nconst randomAdjectives = ["abandoned", "able", "absolute", "adorable", "adventurous", "academic", "acceptable", "acclaimed", "accomplished", "accurate", "aching", "acidic", "acrobatic", "active", "actual", "adept", "admirable", "admired", "adolescent", "adorable", "adored", "advanced", "afraid", "affectionate", "aged", "aggravating", "aggressive", "agile", "agitated", "agonizing", "agreeable", "ajar", "alarmed", "alarming", "alert", "alienated", "alive", "all", "altruistic", "amazing", "ambitious", "ample", "amused", "amusing", "anchored", "ancient", "angelic", "angry", "anguished", "animated", "annual", "another", "antique", "anxious", "any", "apprehensive", "appropriate", "apt", "arctic", "arid", "aromatic", "artistic", "ashamed", "assured", "astonishing", "athletic", "attached", "attentive", "attractive", "austere", "authentic", "authorized", "automatic", "avaricious", "average", "aware", "awesome", "awful", "awkward", "babyish", "bad", "back", "baggy", "bare", "barren", "basic", "beautiful", "belated", "beloved", "beneficial", "better", "best", "bewitched", "big", "big-hearted", "biodegradable", "bite-sized", "bitter", "black", "black-and-white", "bland", "blank", "blaring", "bleak", "blind", "blissful", "blond", "blue", "blushing", "bogus", "boiling", "bold", "bony", "boring", "bossy", "both", "bouncy", "bountiful", "bowed", "brave", "breakable", "brief", "bright", "brilliant", "brisk", "broken", "bronze", "brown", "bruised", "bubbly", "bulky", "bumpy", "buoyant", "burdensome", "burly", "bustling", "busy", "buttery", "buzzing", "calculating", "calm", "candid", "canine", "capital", "carefree", "careful", "careless", "caring", "cautious", "cavernous", "celebrated", "charming", "cheap", "cheerful", "cheery", "chief", "chilly", "chubby", "circular", "classic", "clean", "clear", "clear-cut", "clever", "close", "closed", "cloudy", "clueless", "clumsy", "cluttered", "coarse", "cold", "colorful", "colorless", "colossal", "comfortable", "common", "compassionate", "competent", "complete", "complex", "complicated", "composed", "concerned", "concrete", "confused", "conscious", "considerate", "constant", "content", "conventional", "cooked", "cool", "cooperative", "coordinated", "corny", "corrupt", "costly", "courageous", "courteous", "crafty", "crazy", "creamy", "creative", "creepy", "criminal", "crisp", "critical", "crooked", "crowded", "cruel", "crushing", "cuddly", "cultivated", "cultured", "cumbersome", "curly", "curvy", "cute", "cylindrical", "damaged", "damp", "dangerous", "dapper", "daring", "darling", "dark", "dazzling", "dead", "deadly", "deafening", "dear", "dearest", "decent", "decimal", "decisive", "deep", "defenseless", "defensive", "defiant", "deficient", "definite", "definitive", "delayed", "delectable", "delicious", "delightful", "delirious", "demanding", "dense", "dental", "dependable", "dependent", "descriptive", "deserted", "detailed", "determined", "devoted", "different", "difficult", "digital", "diligent", "dim", "dimpled", "dimwitted", "direct", "disastrous", "discrete", "disfigured", "disgusting", "disloyal", "dismal", "distant", "downright", "dreary", "dirty", "disguised", "dishonest", "dismal", "distant", "distinct", "distorted", "dizzy", "dopey", "doting", "double", "downright", "drab", "drafty", "dramatic", "dreary", "droopy", "dry", "dual", "dull", "dutiful", "each", "eager", "earnest", "early", "easy", "easy-going", "ecstatic", "edible", "educated", "elaborate", "elastic", "elated", "elderly", "electric", "elegant", "elementary", "elliptical", "embarrassed", "embellished", "eminent", "emotional", "empty", "enchanted", "enchanting", "energetic", "enlightened", "enormous", "enraged", "entire", "envious", "equal", "equatorial", "essential", "esteemed", "ethical", "euphoric", "even", "evergreen", "everlasting", "every", "evil", "exalted", "excellent", "exemplary", "exhausted", "excitable", "excited", "exciting", "exotic", "expensive", "experienced", "expert", "extraneous", "extroverted", "extra-large", "extra-small", "fabulous", "failing", "faint", "fair", "faithful", "fake", "false", "familiar", "famous", "fancy", "fantastic", "far", "faraway", "far-flung", "far-off", "fast", "fat", "fatal", "fatherly", "favorable", "favorite", "fearful", "fearless", "feisty", "feline", "female", "feminine", "few", "fickle", "filthy", "fine", "finished", "firm", "first", "firsthand", "fitting", "fixed", "flaky", "flamboyant", "flashy", "flat", "flawed", "flawless", "flickering", "flimsy", "flippant", "flowery", "fluffy", "fluid", "flustered", "focused", "fond", "foolhardy", "foolish", "forceful", "forked", "formal", "forsaken", "forthright", "fortunate", "fragrant", "frail", "frank", "frayed", "free", "French", "fresh", "frequent", "friendly", "frightened", "frightening", "frigid", "frilly", "frizzy", "frivolous", "front", "frosty", "frozen", "frugal", "fruitful", "full", "fumbling", "functional", "funny", "fussy", "fuzzy", "gargantuan", "gaseous", "general", "generous", "gentle", "genuine", "giant", "giddy", "gigantic", "gifted", "giving", "glamorous", "glaring", "glass", "gleaming", "gleeful", "glistening", "glittering", "gloomy", "glorious", "glossy", "glum", "golden", "good", "good-natured", "gorgeous", "graceful", "gracious", "grand", "grandiose", "granular", "grateful", "grave", "gray", "great", "greedy", "green", "gregarious", "grim", "grimy", "gripping", "grizzled", "gross", "grotesque", "grouchy", "grounded", "growing", "growling", "grown", "grubby", "gruesome", "grumpy", "guilty", "gullible", "gummy", "hairy", "half", "handmade", "handsome", "handy", "happy", "happy-go-lucky", "hard", "hard-to-find", "harmful", "harmless", "harmonious", "harsh", "hasty", "hateful", "haunting", "healthy", "heartfelt", "hearty", "heavenly", "heavy", "hefty", "helpful", "helpless", "hidden", "hideous", "high", "high-level", "hilarious", "hoarse", "hollow", "homely", "honest", "honorable", "honored", "hopeful", "horrible", "hospitable", "hot", "huge", "humble", "humiliating", "humming", "humongous", "hungry", "hurtful", "husky", "icky", "icy", "ideal", "idealistic", "identical", "idle", "idiotic", "idolized", "ignorant", "ill", "illegal", "ill-fated", "ill-informed", "illiterate", "illustrious", "imaginary", "imaginative", "immaculate", "immaterial", "immediate", "immense", "impassioned", "impeccable", "impartial", "imperfect", "imperturbable", "impish", "impolite", "important", "impossible", "impractical", "impressionable", "impressive", "improbable", "impure", "inborn", "incomparable", "incompatible", "incomplete", "inconsequential", "incredible", "indelible", "inexperienced", "indolent", "infamous", "infantile", "infatuated", "inferior", "infinite", "informal", "innocent", "insecure", "insidious", "insignificant", "insistent", "instructive", "insubstantial", "intelligent", "intent", "intentional", "interesting", "internal", "international", "intrepid", "ironclad", "irresponsible", "irritating", "itchy", "jaded", "jagged", "jam-packed", "jaunty", "jealous", "jittery", "joint", "jolly", "jovial", "joyful", "joyous", "jubilant", "judicious", "juicy", "jumbo", "junior", "jumpy", "juvenile", "kaleidoscopic", "keen", "key", "kind", "kindhearted", "kindly", "klutzy", "knobby", "knotty", "knowledgeable", "knowing", "known", "kooky", "kosher", "lame", "lanky", "large", "last", "lasting", "late", "lavish", "lawful", "lazy", "leading", "lean", "leafy", "left", "legal", "legitimate", "light", "lighthearted", "likable", "likely", "limited", "limp", "limping", "linear", "lined", "liquid", "little", "live", "lively", "livid", "loathsome", "lone", "lonely", "long", "long-term", "loose", "lopsided", "lost", "loud", "lovable", "lovely", "loving", "low", "loyal", "lucky", "lumbering", "luminous", "lumpy", "lustrous", "luxurious", "mad", "made-up", "magnificent", "majestic", "major", "male", "mammoth", "married", "marvelous", "masculine", "massive", "mature", "meager", "mealy", "mean", "measly", "meaty", "medical", "mediocre", "medium", "meek", "mellow", "melodic", "memorable", "menacing", "merry", "messy", "metallic", "mild", "milky", "mindless", "miniature", "minor", "minty", "miserable", "miserly", "misguided", "misty", "mixed", "modern", "modest", "moist", "monstrous", "monthly", "monumental", "moral", "mortified", "motherly", "motionless", "mountainous", "muddy", "muffled", "multicolored", "mundane", "murky", "mushy", "musty", "muted", "mysterious", "naive", "narrow", "nasty", "natural", "naughty", "nautical", "near", "neat", "necessary", "needy", "negative", "neglected", "negligible", "neighboring", "nervous", "new", "next", "nice", "nifty", "nimble", "nippy", "nocturnal", "noisy", "nonstop", "normal", "notable", "noted", "noteworthy", "novel", "noxious", "numb", "nutritious", "nutty", "obedient", "obese", "oblong", "oily", "oblong", "obvious", "occasional", "odd", "oddball", "offbeat", "offensive", "official", "old", "old-fashioned", "only", "open", "optimal", "optimistic", "opulent", "orange", "orderly", "organic", "ornate", "ornery", "ordinary", "original", "other", "our", "outlying", "outgoing", "outlandish", "outrageous", "outstanding", "oval", "overcooked", "overdue", "overjoyed", "overlooked", "palatable", "pale", "paltry", "parallel", "parched", "partial", "passionate", "past", "pastel", "peaceful", "peppery", "perfect", "perfumed", "periodic", "perky", "personal", "pertinent", "pesky", "pessimistic", "petty", "phony", "physical", "piercing", "pink", "pitiful", "plain", "plaintive", "plastic", "playful", "pleasant", "pleased", "pleasing", "plump", "plush", "polished", "polite", "political", "pointed", "pointless", "poised", "poor", "popular", "portly", "posh", "positive", "possible", "potable", "powerful", "powerless", "practical", "precious", "present", "prestigious", "pretty", "precious", "previous", "pricey", "prickly", "primary", "prime", "pristine", "private", "prize", "probable", "productive", "profitable", "profuse", "proper", "proud", "prudent", "punctual", "pungent", "puny", "pure", "purple", "pushy", "putrid", "puzzled", "puzzling", "quaint", "qualified", "quarrelsome", "quarterly", "queasy", "querulous", "questionable", "quick", "quick-witted", "quiet", "quintessential", "quirky", "quixotic", "quizzical", "radiant", "ragged", "rapid", "rare", "rash", "raw", "recent", "reckless", "rectangular", "ready", "real", "realistic", "reasonable", "red", "reflecting", "regal", "regular", "reliable", "relieved", "remarkable", "remorseful", "remote", "repentant", "required", "respectful", "responsible", "repulsive", "revolving", "rewarding", "rich", "rigid", "right", "ringed", "ripe", "roasted", "robust", "rosy", "rotating", "rotten", "rough", "round", "rowdy", "royal", "rubbery", "rundown", "ruddy", "rude", "runny", "rural", "rusty", "sad", "safe", "salty", "same", "sandy", "sane", "sarcastic", "sardonic", "satisfied", "scaly", "scarce", "scared", "scary", "scented", "scholarly", "scientific", "scornful", "scratchy", "scrawny", "second", "secondary", "second-hand", "secret", "self-assured", "self-reliant", "selfish", "sentimental", "separate", "serene", "serious", "serpentine", "several", "severe", "shabby", "shadowy", "shady", "shallow", "shameful", "shameless", "sharp", "shimmering", "shiny", "shocked", "shocking", "shoddy", "short", "short-term", "showy", "shrill", "shy", "sick", "silent", "silky", "silly", "silver", "similar", "simple", "simplistic", "sinful", "single", "sizzling", "skeletal", "skinny", "sleepy", "slight", "slim", "slimy", "slippery", "slow", "slushy", "small", "smart", "smoggy", "smooth", "smug", "snappy", "snarling", "sneaky", "sniveling", "snoopy", "sociable", "soft", "soggy", "solid", "somber", "some", "spherical", "sophisticated", "sore", "sorrowful", "soulful", "soupy", "sour", "Spanish", "sparkling", "sparse", "specific", "spectacular", "speedy", "spicy", "spiffy", "spirited", "spiteful", "splendid", "spotless", "spotted", "spry", "square", "squeaky", "squiggly", "stable", "staid", "stained", "stale", "standard", "starchy", "stark", "starry", "steep", "sticky", "stiff", "stimulating", "stingy", "stormy", "straight", "strange", "steel", "strict", "strident", "striking", "striped", "strong", "studious", "stunning", "stupendous", "stupid", "sturdy", "stylish", "subdued", "submissive", "substantial", "subtle", "suburban", "sudden", "sugary", "sunny", "super", "superb", "superficial", "superior", "supportive", "sure-footed", "surprised", "suspicious", "svelte", "sweaty", "sweet", "sweltering", "swift", "sympathetic", "tall", "talkative", "tame", "tan", "tangible", "tart", "tasty", "tattered", "taut", "tedious", "teeming", "tempting", "tender", "tense", "tepid", "terrible", "terrific", "testy", "thankful", "that", "these", "thick", "thin", "third", "thirsty", "this", "thorough", "thorny", "those", "thoughtful", "threadbare", "thrifty", "thunderous", "tidy", "tight", "timely", "tinted", "tiny", "tired", "torn", "total", "tough", "traumatic", "treasured", "tremendous", "tragic", "trained", "tremendous", "triangular", "tricky", "trifling", "trim", "trivial", "troubled", "true", "trusting", "trustworthy", "trusty", "truthful", "tubby", "turbulent", "twin", "ugly", "ultimate", "unacceptable", "unaware", "uncomfortable", "uncommon", "unconscious", "understated", "unequaled", "uneven", "unfinished", "unfit", "unfolded", "unfortunate", "unhappy", "unhealthy", "uniform", "unimportant", "unique", "united", "unkempt", "unknown", "unlawful", "unlined", "unlucky", "unnatural", "unpleasant", "unrealistic", "unripe", "unruly", "unselfish", "unsightly", "unsteady", "unsung", "untidy", "untimely", "untried", "untrue", "unused", "unusual", "unwelcome", "unwieldy", "unwilling", "unwitting", "unwritten", "upbeat", "upright", "upset", "urban", "usable", "used", "useful", "useless", "utilized", "utter", "vacant", "vague", "vain", "valid", "valuable", "vapid", "variable", "vast", "velvety", "venerated", "vengeful", "verifiable", "vibrant", "vicious", "victorious", "vigilant", "vigorous", "villainous", "violet", "violent", "virtual", "virtuous", "visible", "vital", "vivacious", "vivid", "voluminous", "wan", "warlike", "warm", "warmhearted", "warped", "wary", "wasteful", "watchful", "waterlogged", "watery", "wavy", "wealthy", "weak", "weary", "webbed", "wee", "weekly", "weepy", "weighty", "weird", "welcome", "well-documented", "well-groomed", "well-informed", "well-lit", "well-made", "well-off", "well-to-do", "well-worn", "wet", "which", "whimsical", "whirlwind", "whispered", "white", "whole", "whopping", "wicked", "wide", "wide-eyed", "wiggly", "wild", "willing", "wilted", "winding", "windy", "winged", "wiry", "wise", "witty", "wobbly", "woeful", "wonderful", "wooden", "woozy", "wordy", "worldly", "worn", "worried", "worrisome", "worse", "worst", "worthless", "worthwhile", "worthy", "wrathful", "wretched", "writhing", "wrong", "wry", "yawning", "yearly", "yellow", "yellowish", "young", "youthful", "yummy", "zany", "zealous", "zesty", "zigzag", "rocky"];\r\nconst randomNouns = ["person", "dog", "cat", "elephant", "bird", "velociraptor", "t-rex", "worm", "fly", "mosquito", "bear", "fish", "fox", "horse", "tiger", "lion", "frog", "monkey", "people", "meat", "food", "player", "soup", "woman", "hair", "police", "lady", "pizza", "plant", "doctor", "god", "nurse", "cow"];\r\nconst randomAnimeCharacters = ["Eren Yaeger", "Mikasa", "Levi Ackerman", "Nezuko", "Tanjiro", "Muzan", "Kazuto", "Kurisu", "Hachiman", "Itachi", "Naruto", "Roronoa", "Light Yagami"];\r\nconst randomCharacters = ["Spider-Man", "Iron Man", "Hulk", "Thanos", "Wolverine", "Loki", "Batman", "Superman", "Aquaman", "Joker", "Lex Luthor", "Cyborg"];\r\nconst randomNames = ["Obama", "Trump", "Abraham Lincoln", "Madonna", "Drawne Johnson", "Leonardo DiCaprio", "Will Smith", "Tom Hanks", "Tom Cruise", "Brad Pitt", "Johnny Depp", "Matt Damon", "Chris Hemsworth", "Hugh Jackman"];\r\n\r\nmodule.exports = {\r\n\tgenerate: function() {\r\n\t\tlet predicates = randomVerbs.concat(randomAdjectives);\r\n\t\tlet predicate = predicates[Math.floor(Math.random() * predicates.length)];\r\n\r\n\t\tlet subjects = randomNouns.concat(randomAnimeCharacters, randomCharacters, randomNames);\r\n\t\tlet subject = subjects[Math.floor(Math.random() * subjects.length)];\r\n\r\n\t\treturn predicate.charAt(0).toUpperCase() + predicate.slice(1) + " " + subject;\r\n\t}\r\n}\n\n//# sourceURL=webpack:///./src/client/js/random.title.js?')},"./src/client/js/renderer.js":function(module,exports,__webpack_require__){eval('const camera = __webpack_require__(/*! ./../lib/camera.js */ "./src/client/lib/camera.js");\r\nconst engine = __webpack_require__(/*! ./engine.js */ "./src/client/js/engine.js");\r\n\r\nclass Renderer {\r\n\tconstructor() {\r\n\t\tthis.canvas = document.getElementById("gameCanvas");\r\n\t\tthis.bounds = this.canvas.getBoundingClientRect();\r\n\t\tthis.context = this.canvas.getContext("2d");\r\n\t\tthis.camera = camera.create(this.context);\r\n\t\tthis.engine = engine.create();\r\n\t\tthis.offscreen = 0;\r\n\t\tthis.context.offscreens = [];\r\n\t\tthis._customOptions = ["fill", "stroke", "align", "close", "curve"];\r\n\t\tthis._currentContext = this.context;\r\n\t\tthis._render = null;\r\n\r\n\t\tlet _preventDefault = event => {\r\n\t\t\tevent.preventDefault();\r\n\t\t}\r\n\r\n\t\tthis.canvas.addEventListener("drag", _preventDefault);\r\n\t\tthis.canvas.addEventListener("dragstart", _preventDefault);\r\n\t}\r\n\r\n\tdraw(f) {\r\n\t\tthis._render = f;\r\n\t\tif (typeof this._render == "function") {\r\n\t\t\tthis._render();\r\n\t\t}\r\n\t}\r\n\r\n\tredraw() {\r\n\t\tif (typeof this._render == "function") {\r\n\t\t\tthis._render();\r\n\t\t}\r\n\t}\r\n\r\n\trender(f) {\r\n\t\tif (typeof f !== "function") return;\r\n\r\n\t\tthis.engine.run(() => {\r\n\t\t\tthis.clear();\r\n\t\t\tf();\r\n\r\n\t\t\tif (!this.context.offscreens.length) return;\r\n\t\t\tthis.drawOffscreens();\r\n\t\t});\r\n\t}\r\n\r\n\tgetFrameCount() {\r\n\t\treturn this.engine.frameCount;\r\n\t}\r\n\r\n\tgetFrameRate() {\r\n\t\treturn this.engine.frameRate;\r\n\t}\r\n\r\n\tsetSize(width, height) {\r\n\t\tthis.canvas.width = width;\r\n\t\tthis.canvas.height = height;\r\n\t\tthis.bounds = this.canvas.getBoundingClientRect();\r\n\r\n\t\tfor (let context of this.context.offscreens) {\r\n\t\t\tcontext.canvas.width = this.canvas.width;\r\n\t\t\tcontext.canvas.height = this.canvas.height;\r\n\t\t}\r\n\t}\r\n\r\n\tfullscreen() {\r\n\t\tthis.setSize(innerWidth, innerHeight);\r\n\t\taddEventListener("resize", () => {\r\n\t\t\tthis.setSize(innerWidth, innerHeight);\r\n\t\t});\r\n\t}\r\n\r\n\tcreateLayer() {\r\n\t\tlet canvas = document.createElement("canvas");\r\n\t\tcanvas.width = this.canvas.width;\r\n\t\tcanvas.height = this.canvas.height;\r\n\t\tlet context = canvas.getContext("2d");\r\n\t\tlet data = {\r\n\t\t\tcamera: this.camera\r\n\t\t};\r\n\t\tcontext.rendererData = data;\r\n\t\tthis.context.offscreens.push(context);\r\n\t\treturn context;\r\n\t}\r\n\r\n\tdrawOffscreens() {\r\n\t\tfor (var i = 0; i < this.context.offscreens.length; i++) {\r\n\t\t\tlet context = this.context.offscreens[i]\r\n\t\t\tcontext.rendererData.camera.begin(() => {\r\n\t\t\t\tthis.context.drawImage(context.canvas, 0, 0, context.canvas.width, context.canvas.height);\r\n\t\t\t})\r\n\r\n\t\t\tcontext.clearRect(0, 0, context.canvas.width, context.canvas.height);\r\n\t\t}\r\n\t}\r\n\r\n\tline(x1, y1, x2, y2, options, context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(x1, y1);\r\n\t\tctx.lineTo(x2, y2);\r\n\t\tthis._hasProperty(options, "close", () => {\r\n\t\t\tctx.closePath();\r\n\t\t});\r\n\r\n\t\tthis._evaluateOptions(options, ctx);\r\n\t}\r\n\r\n\tcircle(x, y, radius, options, context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tctx.beginPath();\r\n\t\tctx.arc(x, y, radius, 0, Math.PI * 2);\r\n\t\tthis._hasProperty(options, "close", () => {\r\n\t\t\tctx.closePath();\r\n\t\t});\r\n\r\n\t\tthis._evaluateOptions(options, ctx);\r\n\t}\r\n\r\n\trect(x, y, width, height, options, context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tthis._hasProperty(options, "align", opt => {\r\n\t\t\tlet alignment = opt.split(" ");\r\n\r\n\t\t\tif (alignment[0]) {\r\n\t\t\t\tif (alignment[0] == "center" || alignment[0] == "middle") {\r\n\t\t\t\t\tx -= width * 0.5;\r\n\t\t\t\t} else if (alignment[0] == "right") {\r\n\t\t\t\t\tx -= width;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (alignment[1]) {\r\n\t\t\t\tif (alignment[1] == "center" || alignment[0] == "middle") {\r\n\t\t\t\t\ty -= height * 0.5;\r\n\t\t\t\t} else if (alignment[1] == "bottom") {\r\n\t\t\t\t\ty -= height;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(x, y, width, height);\r\n\r\n\t\tthis._hasProperty(options, "close", () => {\r\n\t\t\tctx.closePath();\r\n\t\t});\r\n\r\n\t\tthis._evaluateOptions(options, ctx);\r\n\t}\r\n\r\n\tfromVertices(vertices, options, context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tif (!vertices.length) return;\r\n\r\n\t\tctx.beginPath();\r\n\r\n\t\tif (!this._hasProperty(options, "curve")) {\r\n\t\t\tctx.moveTo(vertices[0].x, vertices[0].y);\r\n\t\t\tfor (var i = 0; i < vertices.length; i++) {\r\n\t\t\t\tlet vertex = vertices[i];\r\n\t\t\t\tctx.lineTo(vertex.x, vertex.y);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._hasProperty(options, "curve", () => {\r\n\t\t\tctx.beginPath();\r\n\t\t\tlet first = vertices[0];\r\n\t\t\tlet next = vertices[1];\r\n\t\t\tlet mx = (first.x + next.x) * 0.5;\r\n\t\t\tlet my = (first.y + next.y) * 0.5;\r\n\t\t\tctx.moveTo(mx, my);\r\n\t\t\tfor (var i = 1; i < vertices.length; i++) {\r\n\t\t\t\tlet current = vertices[i];\r\n\t\t\t\tlet next = vertices[i + 1 == vertices.length ? 0 : i + 1];\r\n\t\t\t\tlet mx = (next.x + current.x) * 0.5;\r\n\t\t\t\tlet my = (next.y + current.y) * 0.5;\r\n\t\t\t\tctx.quadraticCurveTo(current.x, current.y, mx, my);\r\n\t\t\t}\r\n\t\t\tctx.quadraticCurveTo(first.x, first.y, mx, my);\r\n\t\t\tctx.lineJoin = "round";\r\n\t\t});\r\n\r\n\t\tthis._hasProperty(options, "close", () => {\r\n\t\t\tctx.closePath();\r\n\t\t});\r\n\r\n\t\tthis._evaluateOptions(options, ctx);\r\n\t}\r\n\r\n\ttext(text, x, y, options, context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tthis._hasProperty(options, "align", opt => {\r\n\t\t\tlet alignment = opt.split(" ");\r\n\r\n\t\t\tif (alignment[0]) {\r\n\t\t\t\tif (alignment[0] == "left") {\r\n\t\t\t\t\tctx.textAlign = "start";\r\n\t\t\t\t} else if (alignment[0] == "center" || alignment[0] == "middle") {\r\n\t\t\t\t\tctx.textAlign = "center";\r\n\t\t\t\t} else if (alignment[0] == "right") {\r\n\t\t\t\t\tctx.textAlign = "right";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (alignment[1]) {\r\n\t\t\t\tif (alignment[1] == "top") {\r\n\t\t\t\t\tctx.textBaseline = "start";\r\n\t\t\t\t} else if (alignment[1] == "center" || alignment[0] == "middle") {\r\n\t\t\t\t\tctx.textBaseline = "middle";\r\n\t\t\t\t} else if (alignment[1] == "bottom") {\r\n\t\t\t\t\tctx.textBaseline = "bottom";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tctx.beginPath();\r\n\t\tthis._evaluateOptions(options, ctx);\r\n\t\tthis._hasProperty(options, "stroke", () => {\r\n\t\t\tctx.strokeText(text, x, y);\r\n\t\t});\r\n\r\n\t\tthis._hasProperty(options, "fill", () => {\r\n\t\t\tctx.fillText(text, x, y);\r\n\t\t});\r\n\r\n\t\tthis._hasProperty(options, "close", () => {\r\n\t\t\tctx.closePath();\r\n\t\t});\r\n\t}\r\n\r\n\tclear(context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\t}\r\n\r\n\tsave(context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tctx.save();\r\n\t}\r\n\r\n\trestore(context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tctx.restore();\r\n\t}\r\n\r\n\tclip(context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tctx.clip();\r\n\t}\r\n\r\n\tfill(color, context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tctx.fillStyle = color;\r\n\t\tctx.fill();\r\n\t}\r\n\r\n\tstroke(color, context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tctx.strokeStyle = color;\r\n\t\tctx.stroke();\r\n\t}\r\n\r\n\t_evaluateOptions(options, context) {\r\n\t\tlet ctx = context || this.context;\r\n\t\tif (!options) return;\r\n\r\n\t\tlet keys = Object.keys(options);\r\n\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\tlet key = keys[i];\r\n\t\t\tif (key == "stroke") ctx.strokeStyle = options[key];\r\n\t\t\tif (key == "fill") ctx.fillStyle = options[key];\r\n\t\t\tif (this._customOptions.includes(key)) continue;\r\n\t\t\tctx[key] = options[key];\r\n\t\t}\r\n\r\n\t\tif (options.stroke) this.stroke(options.stroke, ctx);\r\n\t\tif (options.fill) this.fill(options.fill, ctx);\r\n\t}\r\n\r\n\t_hasProperty(options, name, callback) {\r\n\t\tif (options) {\r\n\t\t\tif (!options[name]) return false;\r\n\t\t\tif (typeof callback == "function") callback(options[name]);\r\n\t\t\treturn options[name];\r\n\t\t}\r\n\t}\r\n}\r\n\r\nmodule.exports = new Renderer();\n\n//# sourceURL=webpack:///./src/client/js/renderer.js?')},"./src/client/js/rig.model.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../lib/events.js */ "./src/lib/events.js");\r\nconst mouse = __webpack_require__(/*! ../../lib/mouse.js */ "./src/lib/mouse.js");\r\nconst vector = __webpack_require__(/*! ../../lib/vector.js */ "./src/lib/vector.js");\r\nconst config = __webpack_require__(/*! ../../lib/config.js */ "./src/lib/config.js");\r\nconst utils = __webpack_require__(/*! ../../lib/utils.js */ "./src/lib/utils.js");\r\nconst history = __webpack_require__(/*! ./history.js */ "./src/client/js/history.js");\r\n\r\nlet timeline;\r\n\r\nlet showSkeleton = document.getElementById("showSkeleton")\r\nclass RigModel {\r\n\tconstructor() {\r\n\t\tthis.joints = [];\r\n\t\tthis.keyframes = {};\r\n\t\tthis.totalKeyframes = 0;\r\n\r\n\t\tthis.mouseBuffer = 10;\r\n\t\tthis.activeJoint = null;\r\n\r\n\t\tthis.bounds = {\r\n\t\t\tmin: vector(),\r\n\t\t\tmax: vector()\r\n\t\t};\r\n\r\n\t\tthis._moved = false;\r\n\t}\r\n\r\n\tupdateBounds() {\r\n\t\tlet keys = Object.keys(this.keyframes);\r\n\t\tlet xAxes = [];\r\n\t\tlet yAxes = [];\r\n\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\tlet frame = this.keyframes[keys[i]];\r\n\t\t\tfor (var j = 0; j < frame.joints.length; j++) {\r\n\t\t\t\tlet joint = frame.joints[j];\r\n\t\t\t\txAxes.push(joint.position.x + config.render.joint.radius);\r\n\t\t\t\tyAxes.push(joint.position.y + config.render.joint.radius);\r\n\r\n\t\t\t\txAxes.push(joint.position.x - config.render.joint.radius);\r\n\t\t\t\tyAxes.push(joint.position.y - config.render.joint.radius);\r\n\r\n\t\t\t\tif (joint.skin.vertices) {\r\n\t\t\t\t\tfor (var k = 0; k < joint.skin.vertices.length; k++) {\r\n\t\t\t\t\t\txAxes.push(joint.skin.vertices[k].x);\r\n\t\t\t\t\t\tyAxes.push(joint.skin.vertices[k].y);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.bounds.min.set({\r\n\t\t\tx: Math.min(...xAxes),\r\n\t\t\ty: Math.min(...yAxes)\r\n\t\t});\r\n\r\n\t\tthis.bounds.max.set({\r\n\t\t\tx: Math.max(...xAxes),\r\n\t\t\ty: Math.max(...yAxes)\r\n\t\t});\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.keyframes = {};\r\n\t\tthis.joints = [];\r\n\t\tthis.totalKeyframes = 0;\r\n\t\tthis.activeJoint = null;\r\n\r\n\t\tif (timeline.graph) {\r\n\t\t\tthis.setKeyframe(0, {\r\n\t\t\t\tposition: {\r\n\t\t\t\t\tx: timeline.graph.hatchMark.spacing / 2,\r\n\t\t\t\t\ty: 0\r\n\t\t\t\t},\r\n\t\t\t\tlocked: true,\r\n\t\t\t\tignoreHistory: true\r\n\t\t\t});\r\n\r\n\t\t\ttimeline.graph.setCurrentMark(0);\r\n\t\t\ttimeline.graph.updateState();\r\n\t\t}\r\n\r\n\t\tthis.updateBounds();\r\n\r\n\t\thistory.add({\r\n\t\t\tlabel: "Clear",\r\n\t\t\tvalue: this.clone(),\r\n\t\t\tgroup: "keyframe"\r\n\t\t});\r\n\t}\r\n\r\n\tclone(keyframes) {\r\n\t\tkeyframes = keyframes || this.keyframes;\r\n\t\tlet clone = this.fromJSON(this.toJSON(keyframes));\r\n\t\treturn clone;\r\n\t}\r\n\r\n\tgetKeyframe(findKey, value) {\r\n\t\tlet keyframes = Object.values(this.keyframes);\r\n\t\tlet res = keyframes.find(k => k[findKey] === value);\r\n\t\tif (res) {\r\n\t\t\treturn this.keyframes[res.index];\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\teditJoints(f) {\r\n\t\tlet keyframes = Object.values(this.keyframes);\r\n\t\tfor (var i = 0; i < keyframes.length; i++) {\r\n\t\t\tlet frame = keyframes[i];\r\n\t\t\tfor (var j = 0; j < frame.joints.length; j++) {\r\n\t\t\t\tlet joint = frame.joints[j];\r\n\t\t\t\tif (typeof f == "function") {\r\n\t\t\t\t\tf(joint, frame);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\teditJoint(id, prop, unique) {\r\n\t\tlet keyframes = Object.values(this.keyframes);\r\n\t\tfor (var i = 0; i < keyframes.length; i++) {\r\n\t\t\tlet frame = keyframes[i];\r\n\t\t\tlet joint = frame.joints.find(j => j.id === id);\r\n\t\t\tprop = unique ? JSON.parse(JSON.stringify(prop)) : prop;\r\n\t\t\tif (joint) {\r\n\t\t\t\tlet _props = Object.keys(prop);\r\n\t\t\t\tfor (var j = 0; j < _props.length; j++) {\r\n\t\t\t\t\tjoint[_props[j]] = prop[_props[j]];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\taddSubKeyframes(start, end) {\r\n\t\tif (timeline.graph) {\r\n\t\t\tlet keys = Object.keys(this.keyframes);\r\n\t\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\t\tif (this.keyframes[keys[i]].type == "sub") {\r\n\t\t\t\t\tkeys.splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet clone = this.clone();\r\n\r\n\t\t\t//If there\'s more than 1 frame\r\n\t\t\tif (keys.length > 1) {\r\n\t\t\t\t//...then add the hidden key frames\r\n\t\t\t\ttimeline.graph.updateState();\r\n\r\n\t\t\t\tfor (var i = end - 1; i >= start + 1; i--) {\r\n\t\t\t\t\tlet clone = this.clone();\r\n\t\t\t\t\tlet subJoints = clone[end].joints;\r\n\r\n\t\t\t\t\tlet subKeyframe = {\r\n\t\t\t\t\t\tid: utils.uid(),\r\n\t\t\t\t\t\ttype: "sub",\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tactiveJointId: clone.activeJointId,\r\n\t\t\t\t\t\tjoints: subJoints,\r\n\t\t\t\t\t\trender: {\r\n\t\t\t\t\t\t\tsize: 12,\r\n\t\t\t\t\t\t\tcolor: "red",\r\n\t\t\t\t\t\t\tposition: vector(i * timeline.graph.hatchMark.spacing + timeline.graph.hatchMark.spacing / 2, 0)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tthis.keyframes[i] = subKeyframe;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.updateSubKeyframes();\r\n\t\ttimeline.graph.updateState();\r\n\t\ttimeline.graph.redraw();\r\n\t}\r\n\r\n\tupdateSubKeyframes() {\r\n\t\tlet keys = Object.keys(this.keyframes);\r\n\r\n\t\tfor (var i = keys.length - 1; i >= 0; i--) {\r\n\t\t\tlet frame = this.keyframes[keys[i]];\r\n\t\t\tif (!frame) continue;\r\n\t\t\tif (frame.type == "head") continue;\r\n\r\n\t\t\tlet back = null;\r\n\t\t\tfor (var j = frame.index; j >= 0; j--) {\r\n\t\t\t\tlet key = this.keyframes[j];\r\n\t\t\t\tif (key) {\r\n\t\t\t\t\tif (key.type == "head") {\r\n\t\t\t\t\t\tback = key.index;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet front = null;\r\n\t\t\tfor (var j = frame.index; j < timeline.app.totalFrames; j++) {\r\n\t\t\t\tlet key = this.keyframes[j];\r\n\t\t\t\tif (key) {\r\n\t\t\t\t\tif (key.type == "head") {\r\n\t\t\t\t\t\tfront = key.index;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet lerpWeight = utils.map(frame.index, front, back, 0, 1);\r\n\r\n\t\t\tlet frontFrame = this.keyframes[front];\r\n\t\t\tlet backFrame = this.keyframes[back];\r\n\r\n\t\t\tfor (var j = 0; j < frame.joints.length; j++) {\r\n\t\t\t\tlet joint = frame.joints[j];\r\n\t\t\t\tif (joint && frontFrame && backFrame) {\r\n\t\t\t\t\tlet frontJoint = frontFrame.joints.find(fj => fj.id === joint.id);\r\n\t\t\t\t\tlet backJoint = backFrame.joints.find(bj => bj.id === joint.id);\r\n\r\n\t\t\t\t\tif (frontJoint && backJoint) {\r\n\t\t\t\t\t\tlet position = frontJoint.position.copy().lerp(backJoint.position, lerpWeight)\r\n\t\t\t\t\t\tlet length = utils.lerp(frontJoint.length, backJoint.length, lerpWeight);\r\n\r\n\t\t\t\t\t\tjoint.length = length;\r\n\t\t\t\t\t\tjoint.position.set(position);\r\n\r\n\t\t\t\t\t\tif (config.animateSkin) {\r\n\t\t\t\t\t\t\tif (backJoint.skin && frontJoint.skin) {\r\n\t\t\t\t\t\t\t\tif (backJoint.skin.offset && frontJoint.skin.offset) {\r\n\t\t\t\t\t\t\t\t\tjoint.skin.offset = {\r\n\t\t\t\t\t\t\t\t\t\tx: utils.lerp(frontJoint.skin.offset.x, backJoint.skin.offset.x, lerpWeight),\r\n\t\t\t\t\t\t\t\t\t\ty: utils.lerp(frontJoint.skin.offset.y, backJoint.skin.offset.y, lerpWeight),\r\n\t\t\t\t\t\t\t\t\t\tscaleX: utils.lerp(frontJoint.skin.offset.scaleX, backJoint.skin.offset.scaleX, lerpWeight),\r\n\t\t\t\t\t\t\t\t\t\tscaleY: utils.lerp(frontJoint.skin.offset.scaleY, backJoint.skin.offset.scaleY, lerpWeight),\r\n\t\t\t\t\t\t\t\t\t\tangle: utils.lerp(frontJoint.skin.offset.angle, backJoint.skin.offset.angle, lerpWeight)\r\n\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (var k = 0; k < joint.children.length; k++) {\r\n\t\t\t\t\t\t\tlet child = joint.children[k];\r\n\t\t\t\t\t\t\tchild.angle = child.position.heading(joint.position);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (joint.id == backFrame.activeJointId) {\r\n\t\t\t\t\t\tframe.activeJointId = joint.id;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (config.riggingMode != "linear") {\r\n\t\t\t\tif (config.riggingMode == "forwardKinematics") {\r\n\t\t\t\t\tthis.computeKinematics(frame.joints);\r\n\t\t\t\t} else if (config.riggingMode == "inverseKinematics") {\r\n\t\t\t\t\tthis.computeKinematics(frame.joints, true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateSkin(frame.joints);\r\n\t\t}\r\n\t}\r\n\r\n\tsetKeyframe(index, options) {\r\n\t\tif (typeof index != "number") return;\r\n\t\toptions = options || {};\r\n\r\n\t\tlet keyframe = {\r\n\t\t\ttype: "head",\r\n\t\t\tindex: options.keyframe ? options.keyframe.index : index,\r\n\t\t\tactiveJointId: options.keyframe ? options.keyframe.activeJointId : (this.activeJoint ? this.activeJoint.id : null),\r\n\t\t\tjoints: options.joints,\r\n\t\t\trender: {\r\n\t\t\t\tsize: config.render.keyframe.size,\r\n\t\t\t\tcolor: config.render.keyframe.color.default,\r\n\t\t\t\tposition: options.position || vector(index * timeline.graph.hatchMark.spacing + timeline.graph.hatchMark.spacing / 2, 0)\r\n\t\t\t},\r\n\t\t\tlocked: options.locked || false\r\n\t\t};\r\n\r\n\t\tif (timeline.graph) {\r\n\t\t\tlet clone = this.clone()[timeline.graph.state.currentFrame];\r\n\t\t\tlet joints = clone ? clone.joints : [];\r\n\t\t\tif (options.joints) joints = options.joints;\r\n\t\t\tkeyframe.joints = joints;\r\n\t\t}\r\n\r\n\t\tkeyframe.id = options.id || utils.uid();\r\n\r\n\t\tthis.keyframes[index] = keyframe;\r\n\r\n\t\tif (timeline.graph) {\r\n\t\t\ttimeline.graph.updateState();\r\n\t\t\tlet currentFrame = timeline.graph.state.currentFrame;\r\n\t\t\tlet previousFrame = timeline.graph.state.previousFrame;\r\n\t\t\tthis.addSubKeyframes(previousFrame, currentFrame);\r\n\t\t\ttimeline.graph.redraw();\r\n\t\t}\r\n\r\n\t\t//History\r\n\t\tif (!options.ignoreHistory) {\r\n\t\t\tlet frames = Object.values(this.keyframes);\r\n\t\t\tlet headCount = 0;\r\n\t\t\tfor (var i = 0; i < frames.length; i++) {\r\n\t\t\t\tlet frame = frames[i];\r\n\t\t\t\tif (frame.type == "head") headCount++;\r\n\t\t\t}\r\n\r\n\t\t\tlet historyLabel = "Add keyframe";\r\n\t\t\tif (headCount == this.totalKeyframes) {\r\n\t\t\t\thistoryLabel = "Move keyframe";\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateBounds();\r\n\r\n\t\t\thistory.add({\r\n\t\t\t\tlabel: historyLabel,\r\n\t\t\t\tvalue: this.clone(),\r\n\t\t\t\tgroup: "keyframe"\r\n\t\t\t});\r\n\r\n\t\t\tthis.totalKeyframes = headCount;\r\n\t\t\treturn keyframe;\r\n\t\t}\r\n\t}\r\n\r\n\tdeleteKeyframe(id) {\r\n\t\tlet keyframe = this.getKeyframe("id", id);\r\n\r\n\t\tif (!keyframe) return;\r\n\t\tif (Object.keys(this.keyframes).length <= 1) return;\r\n\t\tlet subs = [];\r\n\t\tlet leftHead;\r\n\t\tlet rightHead;\r\n\r\n\t\t//Get left subs\r\n\t\tfor (var i = keyframe.index - 1; i >= 0; i--) {\r\n\t\t\tlet key = this.keyframes[i];\r\n\t\t\tif (key) {\r\n\t\t\t\tif (key.type == "sub") {\r\n\t\t\t\t\tsubs.push(key);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (key.type == "head") {\r\n\t\t\t\t\tleftHead = key;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//Get right subs\r\n\t\tfor (var i = keyframe.index + 1; i < timeline.app.totalFrames; i++) {\r\n\t\t\tlet key = this.keyframes[i];\r\n\t\t\tif (key) {\r\n\t\t\t\tif (key.type == "sub") {\r\n\t\t\t\t\tsubs.push(key);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (key.type == "head") {\r\n\t\t\t\t\trightHead = key;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//Delete left & right subs\r\n\t\tfor (var i = 0; i < subs.length; i++) {\r\n\t\t\tlet frame = this.getKeyframe("id", subs[i].id);\r\n\t\t\tdelete this.keyframes[frame.index];\r\n\t\t}\r\n\r\n\t\t//Delete head\r\n\t\tdelete this.keyframes[keyframe.index];\r\n\r\n\t\tif (rightHead && leftHead) this.addSubKeyframes(leftHead.index, rightHead.index);\r\n\r\n\t\tif (timeline.graph) {\r\n\t\t\ttimeline.graph.updateState();\r\n\t\t\ttimeline.graph.redraw();\r\n\t\t}\r\n\r\n\t\tthis.updateBounds();\r\n\t}\r\n\r\n\tupdateKeyframe(index, data) {\r\n\t\tlet d = Object.keys(data);\r\n\t\tfor (var i = 0; i < d.length; i++) {\r\n\t\t\tthis.keyframes[index][d[i]] = data[d[i]];\r\n\t\t}\r\n\r\n\t\tthis.updateSubKeyframes();\r\n\t}\r\n\r\n\taddJoint(x, y, options) {\r\n\t\toptions = options || {};\r\n\t\tif (timeline.graph) {\r\n\t\t\ttimeline.graph.setCurrentMark(timeline.graph.state.currentFrame, false);\r\n\t\t}\r\n\r\n\t\tlet parent = options.parent || this.activeJoint;\r\n\r\n\t\tlet joint = {\r\n\t\t\tid: "J" + utils.uid(),\r\n\t\t\tname: `Joint ${this.joints.length + 1}`,\r\n\t\t\tposition: vector(x, y),\r\n\t\t\tpositionPrev: vector(x, y),\r\n\t\t\tangle: parent ? vector(x, y).heading(parent.position) : 0,\r\n\t\t\tparent: parent || null,\r\n\t\t\tchildren: [],\r\n\t\t\tlength: parent ? parent.position.dist(x, y) : 0,\r\n\t\t\thierarchy: parent ? parent.hierarchy + 1 : 1,\r\n\t\t\tskin: {},\r\n\t\t\tzIndex: this.joints.length + 1\r\n\t\t};\r\n\r\n\t\tif (parent) parent.children.push(joint);\r\n\r\n\t\tif (!options.ignoreDefaults) {\r\n\t\t\tthis.activeJoint = joint;\r\n\t\t}\r\n\r\n\t\tthis.joints.push(joint);\r\n\r\n\t\tif (timeline.graph) {\r\n\t\t\tthis.updateKeyframe(timeline.graph.state.currentFrame, {\r\n\t\t\t\tactiveJointId: this.activeJoint.id\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.updateBounds();\r\n\r\n\t\tif (!options.ignoreHistory) {\r\n\t\t\thistory.add({\r\n\t\t\t\tlabel: "Add joint",\r\n\t\t\t\tvalue: this.clone(),\r\n\t\t\t\tgroup: "keyframe"\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tevents.emit("jointChange", this.joints);\r\n\r\n\t\treturn joint;\r\n\t}\r\n\r\n\tselectJoint(x, y) {\r\n\t\tif (!this.joints.length) return;\r\n\r\n\t\tlet joints = this.joints.slice();\r\n\t\tjoints.sort((a, b) => {\r\n\t\t\treturn a.position.dist(x, y) - b.position.dist(x, y);\r\n\t\t});\r\n\r\n\t\tthis.activeJoint = this.joints.find(j => j.id === joints[0].id);\r\n\r\n\t\tevents.emit("jointChange", this.joints);\r\n\r\n\t\tif (timeline.graph) {\r\n\t\t\tthis.updateKeyframe(timeline.graph.state.currentFrame, {\r\n\t\t\t\tactiveJointId: this.activeJoint.id\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tremoveJointById(id) {\r\n\t\tlet keys = Object.keys(this.keyframes);\r\n\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\tlet frame = this.keyframes[keys[i]];\r\n\t\t\tlet joint = frame.joints.find(j => j.id === id);\r\n\t\t\tif (joint) {\r\n\t\t\t\tfor (var j = 0; j < joint.children.length; j++) {\r\n\t\t\t\t\tlet child = joint.children[j];\r\n\t\t\t\t\tchild.parent = joint.parent;\r\n\t\t\t\t\tchild.length += joint.length;\r\n\t\t\t\t\tthis.activeJoint = child;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (joint.parent) {\r\n\t\t\t\t\tjoint.parent.children.splice(joint.parent.children.indexOf(joint), 1);\r\n\t\t\t\t\tjoint.parent.children.push(...joint.children);\r\n\t\t\t\t\tthis.activeJoint = joint.parent;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.activeJoint = joint.children[0];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tframe.joints.splice(frame.joints.indexOf(joint), 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//Fix position\r\n\t\tif (this.activeJoint) {\r\n\t\t\tthis.moveJoint(this.activeJoint.position.x, this.activeJoint.position.y);\r\n\t\t}\r\n\r\n\t\tthis.updateBounds();\r\n\r\n\t\thistory.add({\r\n\t\t\tlabel: "Remove joint",\r\n\t\t\tvalue: this.clone(),\r\n\t\t\tgroup: "keyframe"\r\n\t\t});\r\n\r\n\t\tevents.emit("jointChange", this.joints);\r\n\t}\r\n\r\n\tremoveJointByPosition(x, y) {\r\n\t\tif (!this.joints.length) return;\r\n\r\n\t\tfor (var i = 0; i < this.joints.length; i++) {\r\n\t\t\tlet joint = this.joints[i];\r\n\t\t\tif (joint.position.dist(x, y) < config.render.joint.radius + this.mouseBuffer) {\r\n\t\t\t\tthis.removeJointById(joint.id);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tcomputeKinematics(jointChain, inverse) {\r\n\t\t/*let doforward = [];\r\n\t\tlet doinverse = [];\r\n\t\tfor (var i = 0; i < jointChain.length; i++) {\r\n\t\t\tlet joint = jointChain[i];\r\n\t\t\tif (joint.hierarchy <= this.activeJoint.hierarchy) {\r\n\t\t\t\tdoinverse.push(joint);\r\n\t\t\t} \r\n\t\t\tif (joint.hierarchy >= this.activeJoint.hierarchy) {\r\n\t\t\t\tdoforward.push(joint);\r\n\t\t\t}\r\n\t\t}\r\n\t\tdoforward.sort((a, b) => a.hierarchy - b.hierarchy);\r\n\t\tfor (var i = 0; i < doforward.length; i++) {\r\n\t\t\tlet joint = doforward[i];\r\n\t\t\tfor (var j = 0; j < joint.children.length; j++) {\r\n\t\t\t\tlet child = joint.children[j];\r\n\t\t\t\tchild.angle = child.position.heading(joint.position);\r\n\t\t\t\tchild.position.set({\r\n\t\t\t\t\tx: joint.position.x - Math.cos(child.angle) * child.length,\r\n\t\t\t\t\ty: joint.position.y - Math.sin(child.angle) * child.length\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\tdoinverse.sort((a, b) => b.hierarchy - a.hierarchy);\r\n\t\tfor (var i = doinverse.length - 1; i >= 0; i--) {\r\n\t\t\tlet joint = doinverse[i];\r\n\t\t\tif (joint.parent !== this.activeJoint) {\r\n\t\t\t\tif (joint.parent) {\r\n\t\t\t\t\tjoint.parent.angle = joint.position.heading(joint.parent.position);\r\n\t\t\t\t\tjoint.parent.position.set({\r\n\t\t\t\t\t\tx: joint.position.x + Math.cos(joint.parent.angle) * joint.length,\r\n\t\t\t\t\t\ty: joint.position.y + Math.sin(joint.parent.angle) * joint.length\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}*/\r\n\r\n\r\n\r\n\t\tif (!inverse) {\r\n\t\t\tfor (var i = 0; i < jointChain.length; i++) {\r\n\t\t\t\tlet joint = jointChain[i];\r\n\t\t\t\tfor (var j = 0; j < joint.children.length; j++) {\r\n\t\t\t\t\tlet child = joint.children[j];\r\n\t\t\t\t\tchild.angle = child.position.heading(joint.position);\r\n\t\t\t\t\tchild.position.set({\r\n\t\t\t\t\t\tx: joint.position.x - Math.cos(child.angle) * child.length,\r\n\t\t\t\t\t\ty: joint.position.y - Math.sin(child.angle) * child.length\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (var i = jointChain.length - 1; i >= 0; i--) {\r\n\t\t\t\tlet joint = jointChain[i];\r\n\r\n\t\t\t\tif (joint.parent) {\r\n\t\t\t\t\tjoint.parent.angle = joint.position.heading(joint.parent.position);\r\n\t\t\t\t\tjoint.parent.position.set({\r\n\t\t\t\t\t\tx: joint.position.x + Math.cos(joint.parent.angle) * joint.length,\r\n\t\t\t\t\t\ty: joint.position.y + Math.sin(joint.parent.angle) * joint.length\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tupdateSkin(jointChain) {\r\n\t\tjointChain = jointChain || this.joints;\r\n\t\tfor (var i = 0; i < jointChain.length; i++) {\r\n\t\t\tlet joint = jointChain[i];\r\n\t\t\tlet newWidth = joint.length;\r\n\t\t\tlet newHeight = joint.length;\r\n\t\t\tlet angleAuto = 0;\r\n\r\n\t\t\tlet crop = joint.skin.crop;\r\n\t\t\tlet cropWidth = 0;\r\n\t\t\tlet cropHeight = 0;\r\n\t\t\tif (crop) {\r\n\t\t\t\tcropWidth = crop.to.x - crop.from.x;\r\n\t\t\t\tcropHeight = crop.to.y - crop.from.y;\r\n\t\t\t}\r\n\r\n\t\t\tif (cropWidth > cropHeight) {\r\n\t\t\t\tnewHeight = Number.MAX_SAFE_INTEGER;\r\n\t\t\t} else {\r\n\t\t\t\tnewWidth = Number.MAX_SAFE_INTEGER;\r\n\t\t\t\tangleAuto = Math.PI / 2;\r\n\t\t\t}\r\n\r\n\t\t\tjoint.skin.size = utils.scaleSize(cropWidth, cropHeight, newWidth, newHeight);;\r\n\t\t\tjoint.skin._sizeOriginal = {\r\n\t\t\t\twidth: cropWidth,\r\n\t\t\t\theight: cropHeight\r\n\t\t\t};\r\n\r\n\t\t\tjoint.skin.angleAuto = angleAuto;\r\n\r\n\t\t\tlet xOffset = 0;\r\n\t\t\tlet yOffset = 0;\r\n\t\t\tlet scaleXOffset = 1;\r\n\t\t\tlet scaleYOffset = 1;\r\n\t\t\tlet angleOffset = 0;\r\n\r\n\t\t\tif (joint.skin.offset) {\r\n\t\t\t\txOffset = joint.skin.offset.x || 0;\r\n\t\t\t\tyOffset = joint.skin.offset.y || 0;\r\n\t\t\t\tscaleXOffset = joint.skin.offset.scaleX || 0;\r\n\t\t\t\tscaleYOffset = joint.skin.offset.scaleY || 0;\r\n\t\t\t\tangleOffset = joint.skin.offset.angle || 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (joint.parent && crop) {\r\n\t\t\t\tjoint.skin.position = {\r\n\t\t\t\t\tx: (joint.position.x + joint.parent.position.x) / 2,\r\n\t\t\t\t\ty: (joint.position.y + joint.parent.position.y) / 2\r\n\t\t\t\t};\r\n\r\n\t\t\t\tlet vertices = [{\r\n\t\t\t\t\tx: joint.skin.position.x + xOffset - joint.skin.size.width / 2,\r\n\t\t\t\t\ty: joint.skin.position.y + yOffset - joint.skin.size.height / 2\r\n\t\t\t\t}, {\r\n\t\t\t\t\tx: joint.skin.position.x + xOffset + joint.skin.size.width / 2,\r\n\t\t\t\t\ty: joint.skin.position.y + yOffset - joint.skin.size.height / 2\r\n\t\t\t\t}, {\r\n\t\t\t\t\tx: joint.skin.position.x + xOffset + joint.skin.size.width / 2,\r\n\t\t\t\t\ty: joint.skin.position.y + yOffset + joint.skin.size.height / 2\r\n\t\t\t\t}, {\r\n\t\t\t\t\tx: joint.skin.position.x + xOffset - joint.skin.size.width / 2,\r\n\t\t\t\t\ty: joint.skin.position.y + yOffset + joint.skin.size.height / 2\r\n\t\t\t\t}];\r\n\r\n\t\t\t\tfor (let vert of vertices) {\r\n\t\t\t\t\tlet vertexDelta = {\r\n\t\t\t\t\t\tx: vert.x - joint.skin.position.x,\r\n\t\t\t\t\t\ty: vert.y - joint.skin.position.y\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tvert.x = vert.x + vertexDelta.x * (scaleXOffset - 1);\r\n\t\t\t\t\tvert.y = vert.y + vertexDelta.y * (scaleYOffset - 1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let vert of vertices) {\r\n\t\t\t\t\tlet angle = joint.angle + joint.skin.angleAuto + angleOffset;\r\n\t\t\t\t\tlet x = (vert.x - joint.skin.position.x) * Math.cos(angle) - (vert.y - joint.skin.position.y) * Math.sin(angle);\r\n\t\t\t\t\tlet y = (vert.x - joint.skin.position.x) * Math.sin(angle) + (vert.y - joint.skin.position.y) * Math.cos(angle);\r\n\r\n\t\t\t\t\tvert.x = x + joint.skin.position.x;\r\n\t\t\t\t\tvert.y = y + joint.skin.position.y;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tjoint.skin.vertices = vertices;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tmoveJointById(id, x, y) {\r\n\t\tthis.activeJoint = this.getJoint(id);\r\n\t\tif (!this.activeJoint) return;\r\n\t\tif (timeline.graph) {\r\n\t\t\tif (config.animation.autoAddKeyframe) {\r\n\t\t\t\tif (!this.activeJoint.position.equals(x, y)) {\r\n\t\t\t\t\tlet currentMark = timeline.graph.state.currentMark;\r\n\t\t\t\t\tlet frame = this.keyframes[currentMark];\r\n\t\t\t\t\tif (!frame) {\r\n\t\t\t\t\t\tthis.setKeyframe(currentMark);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (frame.type != "head") {\r\n\t\t\t\t\t\t\tthis.setKeyframe(currentMark);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttimeline.graph.setCurrentMark(timeline.graph.state.currentFrame, false);\r\n\t\t\t\ttimeline.graph.updateState();\r\n\t\t\t}\r\n\r\n\t\t\tthis.updateSubKeyframes();\r\n\t\t}\r\n\r\n\t\tif (x && y) {\r\n\t\t\tif (this.activeJoint.position.dist(this.activeJoint.positionPrev) > 1) {\r\n\t\t\t\tthis._moved = true;\r\n\t\t\t\tthis.activeJoint.positionPrev.set(this.activeJoint.position.x, this.activeJoint.position.y);\r\n\t\t\t}\r\n\r\n\t\t\tthis.activeJoint.position.set(x, y);\r\n\r\n\t\t\tif (config.riggingMode == "linear") {\r\n\t\t\t\tif (this.activeJoint.parent) {\r\n\t\t\t\t\tthis.activeJoint.angle = this.activeJoint.position.heading(this.activeJoint.parent.position);\r\n\r\n\t\t\t\t\tthis.activeJoint.length = this.activeJoint.position.dist(this.activeJoint.parent.position);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (var i = 0; i < this.activeJoint.children.length; i++) {\r\n\t\t\t\t\tlet child = this.activeJoint.children[i];\r\n\t\t\t\t\tchild.length = child.position.dist(this.activeJoint.position);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (config.riggingMode != "linear") {\r\n\t\t\tif (config.riggingMode == "forwardKinematics") {\r\n\t\t\t\tthis.computeKinematics(this.joints);\r\n\t\t\t} else if (config.riggingMode == "inverseKinematics") {\r\n\t\t\t\tthis.computeKinematics(this.joints, true);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.updateSkin();\r\n\t\tthis.updateBounds();\r\n\r\n\t\treturn this.activeJoint;\r\n\t}\r\n\r\n\tmoveJoint(x, y) {\r\n\t\tthis.moveJointById(this.activeJoint.id, x, y);\r\n\t}\r\n\r\n\tgetJoint(id) {\r\n\t\tlet joint = this.joints.find(j => j.id === id) || null;\r\n\t\treturn joint;\r\n\t}\r\n\r\n\ttoJSON(_keyframes, excludeImageSrc) {\r\n\t\tlet keyframes = _keyframes || this.clone();\r\n\t\tlet json = {};\r\n\t\tlet keys = Object.keys(keyframes);\r\n\r\n\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\tlet key = keys[i];\r\n\t\t\tlet frame = keyframes[key];\r\n\r\n\t\t\tlet keyframe = {\r\n\t\t\t\tid: frame.id,\r\n\t\t\t\tactiveJointId: frame.activeJointId,\r\n\t\t\t\tindex: frame.index,\r\n\t\t\t\tjoints: [],\r\n\t\t\t\trender: frame.render,\r\n\t\t\t\ttype: frame.type,\r\n\t\t\t\tlocked: frame.locked\r\n\t\t\t};\r\n\r\n\t\t\tfor (var j = 0; j < frame.joints.length; j++) {\r\n\t\t\t\tlet joint = frame.joints[j];\r\n\r\n\t\t\t\tlet jointData = {\r\n\t\t\t\t\tid: joint.id,\r\n\t\t\t\t\tname: joint.name,\r\n\t\t\t\t\tangle: joint.angle,\r\n\t\t\t\t\tposition: joint.position,\r\n\t\t\t\t\tpositionPrev: joint.positionPrev,\r\n\t\t\t\t\tlength: joint.length,\r\n\t\t\t\t\tparent: joint.parent ? joint.parent.id : null,\r\n\t\t\t\t\thierarchy: joint.hierarchy,\r\n\t\t\t\t\tchildren: [],\r\n\t\t\t\t\tskinImageSrc: joint.skin && !excludeImageSrc ? joint.skin.imageSrc : undefined,\r\n\t\t\t\t\tskinCrop: joint.skin ? joint.skin.crop : null,\r\n\t\t\t\t\tskinOffset: joint.skin ? joint.skin.offset : null,\r\n\t\t\t\t\tskinPosition: joint.skin ? joint.skin.position : null,\r\n\t\t\t\t\tskinAngleAuto: joint.skin ? joint.skin.angleAuto : undefined,\r\n\t\t\t\t\tskinSize: joint.skin ? joint.skin.size : null,\r\n\t\t\t\t\t_skinSizeOriginal: joint.skin ? joint.skin._sizeOriginal : null,\r\n\t\t\t\t\t_vueCrop: joint.skin ? joint.skin._vueCrop : null,\r\n\t\t\t\t\tzIndex: joint.zIndex\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfor (var k = 0; k < joint.children.length; k++) {\r\n\t\t\t\t\tlet child = joint.children[k];\r\n\t\t\t\t\tjointData.children.push(child.id);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkeyframe.joints.push(jointData);\r\n\t\t\t}\r\n\r\n\t\t\tjson[keyframe.index] = keyframe;\r\n\t\t}\r\n\r\n\t\treturn json;\r\n\t}\r\n\r\n\tfromJSON(json) {\r\n\t\tif (!json) return;\r\n\r\n\t\tlet result = {};\r\n\t\tlet keys = Object.keys(json);\r\n\r\n\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\tlet key = keys[i];\r\n\t\t\tlet frame = json[key];\r\n\t\t\tlet activeJoint = frame.joints.find(j => j.id === frame.activeJointId);\r\n\r\n\t\t\tlet parsedJoints = [];\r\n\r\n\t\t\t//Parse joint data\r\n\t\t\tfor (var j = 0; j < frame.joints.length; j++) {\r\n\t\t\t\tlet joint = frame.joints[j];\r\n\t\t\t\tlet data = {\r\n\t\t\t\t\tid: joint.id,\r\n\t\t\t\t\tname: joint.name,\r\n\t\t\t\t\tangle: joint.angle,\r\n\t\t\t\t\tposition: vector(joint.position),\r\n\t\t\t\t\tpositionPrev: vector(joint.positionPrev),\r\n\t\t\t\t\tlength: joint.length,\r\n\t\t\t\t\thierarchy: joint.hierarchy,\r\n\t\t\t\t\tparent: joint.parent,\r\n\t\t\t\t\tchildren: joint.children.slice(),\r\n\t\t\t\t\tskin: {\r\n\t\t\t\t\t\toffset: joint.skinOffset,\r\n\t\t\t\t\t\tcrop: joint.skinCrop,\r\n\t\t\t\t\t\t_vueCrop: joint._vueCrop,\r\n\t\t\t\t\t\timageSrc: joint.skinImageSrc,\r\n\t\t\t\t\t\tposition: joint.skinPosition,\r\n\t\t\t\t\t\tangleAuto: joint.angleAuto,\r\n\t\t\t\t\t\tsize: joint.skinSize,\r\n\t\t\t\t\t\t_sizeOriginal: joint._skinSizeOriginal\r\n\t\t\t\t\t},\r\n\t\t\t\t\tzIndex: joint.zIndex\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparsedJoints.push(data);\r\n\t\t\t}\r\n\r\n\t\t\t//Find parent and children\r\n\t\t\tfor (var j = 0; j < parsedJoints.length; j++) {\r\n\t\t\t\tlet joint = parsedJoints[j];\r\n\r\n\t\t\t\tjoint.parent = parsedJoints.find(pj => pj.id === joint.parent) || null;\r\n\r\n\t\t\t\tfor (var k = 0; k < joint.children.length; k++) {\r\n\t\t\t\t\tlet child = joint.children[k];\r\n\r\n\t\t\t\t\tjoint.children[k] = parsedJoints.find(pj => pj.id === child) || null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet parsedFrame = {\r\n\t\t\t\tactiveJointId: frame.activeJointId,\r\n\t\t\t\tid: frame.id,\r\n\t\t\t\tindex: frame.index,\r\n\t\t\t\tjoints: parsedJoints,\r\n\t\t\t\tlocked: frame.locked,\r\n\t\t\t\trender: frame.render,\r\n\t\t\t\ttype: frame.type\r\n\t\t\t};\r\n\r\n\t\t\tresult[frame.index] = parsedFrame;\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\timport (keyframes) {\r\n\t\tthis.keyframes = this.clone(keyframes);\r\n\r\n\t\tlet frames = Object.values(this.keyframes);\r\n\t\tlet headCount = 0;\r\n\t\tfor (var i = 0; i < frames.length; i++) {\r\n\t\t\tlet frame = frames[i];\r\n\t\t\tif (frame.type == "head") headCount++;\r\n\t\t}\r\n\r\n\t\tthis.totalKeyframes = headCount;\r\n\r\n\t\tif (timeline.graph) {\r\n\t\t\t//timeline.graph.setCurrentMark(0, false);\r\n\t\t\tlet currentFrame = this.keyframes[timeline.graph.state.currentMark];\r\n\r\n\t\t\tif (currentFrame) {\r\n\t\t\t\tthis.activeJoint = this.getKeyframe("id", currentFrame.activeJointId);\r\n\t\t\t\tif (this.activeJoint) {\r\n\t\t\t\t\tthis.updateKeyframe(timeline.graph.state.currentFrame, {\r\n\t\t\t\t\t\tactiveJointId: this.activeJoint.id\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttimeline.graph.updateState();\r\n\t\t}\r\n\r\n\t\tthis.updateSkin();\r\n\t\tthis.updateBounds();\r\n\t\tevents.emit("jointChange", this.joints);\r\n\t}\r\n\r\n\trenderTo(ctx, options) {\r\n\t\toptions = options || {};\r\n\t\tlet frame = this.keyframes[options.frame];\r\n\r\n\t\tif (!frame) return;\r\n\r\n\t\toptions.position = options.position || {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0\r\n\t\t};\r\n\r\n\t\tlet offset = {\r\n\t\t\tx: -this.bounds.min.x + options.position.x,\r\n\t\t\ty: -this.bounds.min.y + options.position.y\r\n\t\t};\r\n\r\n\t\tframe.joints.sort((a, b) => a.zIndex - b.zIndex);\r\n\r\n\t\tif (options.showSkin) {\r\n\t\t\tfor (var i = 0; i < frame.joints.length; i++) {\r\n\t\t\t\tlet joint = frame.joints[i];\r\n\r\n\t\t\t\tif (joint.parent) {\r\n\t\t\t\t\t//Load image if there\'s an image url\r\n\t\t\t\t\tif (joint.skin.imageSrc) {\r\n\t\t\t\t\t\tif (!joint.skin.image) {\r\n\t\t\t\t\t\t\tlet img = new Image();\r\n\t\t\t\t\t\t\timg.src = joint.skin.imageSrc;\r\n\t\t\t\t\t\t\tjoint.skin.image = img;\r\n\t\t\t\t\t\t\tthis.updateSkin();\r\n\t\t\t\t\t\t\tthis.updateBounds();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (!joint.skin.image.width) {\r\n\t\t\t\t\t\t\t\tlet img = new Image();\r\n\t\t\t\t\t\t\t\timg.src = joint.skin.imageSrc;\r\n\t\t\t\t\t\t\t\tjoint.skin.image = img;\r\n\t\t\t\t\t\t\t\tthis.updateSkin();\r\n\t\t\t\t\t\t\t\tthis.updateBounds();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (joint.skin) {\r\n\t\t\t\t\t\tif (typeof joint.skin.image == "object") {\r\n\t\t\t\t\t\t\tif (joint.skin.image.src && joint.skin.position) {\r\n\t\t\t\t\t\t\t\tctx.save();\r\n\t\t\t\t\t\t\t\tctx.translate(joint.skin.position.x + offset.x, joint.skin.position.y + offset.y);\r\n\t\t\t\t\t\t\t\tctx.rotate(joint.angle + joint.skin.angleAuto);\r\n\r\n\t\t\t\t\t\t\t\tif (joint.skin.offset) {\r\n\t\t\t\t\t\t\t\t\tlet xOffset = joint.skin.offset.x;\r\n\t\t\t\t\t\t\t\t\tlet yOffset = joint.skin.offset.y;\r\n\t\t\t\t\t\t\t\t\tlet scaleXOffset = joint.skin.offset.scaleX;\r\n\t\t\t\t\t\t\t\t\tlet scaleYOffset = joint.skin.offset.scaleY;\r\n\t\t\t\t\t\t\t\t\tlet angleOffset = joint.skin.offset.angle;\r\n\r\n\t\t\t\t\t\t\t\t\tctx.rotate(angleOffset);\r\n\t\t\t\t\t\t\t\t\tctx.translate(xOffset, yOffset);\r\n\t\t\t\t\t\t\t\t\tctx.scale(scaleXOffset, scaleYOffset);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tctx.drawImage(joint.skin.image, joint.skin.crop.from.x, joint.skin.crop.from.y, joint.skin._sizeOriginal.width, joint.skin._sizeOriginal.height, -joint.skin.size.width / 2, -joint.skin.size.height / 2, joint.skin.size.width, joint.skin.size.height);\r\n\t\t\t\t\t\t\t\tctx.restore();\r\n\r\n\t\t\t\t\t\t\t\tif (!joint.skin.vertices) {\r\n\t\t\t\t\t\t\t\t\tthis.updateSkin();\r\n\t\t\t\t\t\t\t\t\tthis.updateBounds();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (options.showBones) {\r\n\t\t\tfor (var i = 0; i < frame.joints.length; i++) {\r\n\t\t\t\tlet joint = frame.joints[i];\r\n\r\n\t\t\t\tif (joint.parent) {\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.moveTo(joint.position.x + offset.x, joint.position.y + offset.y);\r\n\t\t\t\t\tctx.lineTo(joint.parent.position.x + offset.x, joint.parent.position.y + offset.y);\r\n\t\t\t\t\tctx.lineWidth = config.render.segment.width;\r\n\t\t\t\t\tctx.lineCap = "round";\r\n\t\t\t\t\tctx.strokeStyle = config.render.segment.color;\r\n\t\t\t\t\tctx.stroke();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i = 0; i < frame.joints.length; i++) {\r\n\t\t\t\tlet joint = frame.joints[i];\r\n\r\n\t\t\t\tlet jointColor = joint === this.activeJoint ? config.render.joint.color.selected : config.render.joint.color.default;\r\n\r\n\t\t\t\tif (timeline.graph) {\r\n\t\t\t\t\tif (this.activeJoint && !timeline.graph.state.isPlaying) {\r\n\t\t\t\t\t\tif (this.activeJoint.children.length) jointColor = this.activeJoint.children.includes(joint) ? "#5bff85" : jointColor;\r\n\t\t\t\t\t\tif (this.activeJoint.parent) jointColor = this.activeJoint.parent === joint ? "#9b68e1" : jointColor;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (timeline.graph.state.isPlaying) {\r\n\t\t\t\t\t\tjointColor = config.render.joint.color.default;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.arc(joint.position.x + offset.x, joint.position.y + offset.y, config.render.joint.radius, 0, Math.PI * 2);\r\n\t\t\t\tctx.closePath();\r\n\t\t\t\tctx.fillStyle = options.workColor ? jointColor : config.render.joint.color.default;\r\n\t\t\t\tctx.fill();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\trender(renderer) {\r\n\t\tlet showBones = showSkeleton.checked;\r\n\t\tif (timeline.graph) {\r\n\t\t\tlet previousFrame = timeline.graph.state.previousFrame;\r\n\t\t\tlet currentFrame = timeline.graph.state.currentFrame;\r\n\t\t\tlet nextFrame = timeline.graph.state.nextFrame;\r\n\t\t\tlet currentMark = timeline.graph.state.currentMark;\r\n\r\n\t\t\trenderer.save();\r\n\t\t\trenderer.context.globalAlpha = 0.1;\r\n\t\t\tthis.renderTo(renderer.context, {\r\n\t\t\t\tframe: previousFrame,\r\n\t\t\t\tposition: {\r\n\t\t\t\t\tx: this.bounds.min.x,\r\n\t\t\t\t\ty: this.bounds.min.y\r\n\t\t\t\t},\r\n\t\t\t\tshowBones: showBones\r\n\t\t\t});\r\n\r\n\t\t\tthis.renderTo(renderer.context, {\r\n\t\t\t\tframe: currentFrame,\r\n\t\t\t\tposition: {\r\n\t\t\t\t\tx: this.bounds.min.x,\r\n\t\t\t\t\ty: this.bounds.min.y\r\n\t\t\t\t},\r\n\t\t\t\tshowBones: showBones\r\n\t\t\t});\r\n\r\n\t\t\tthis.renderTo(renderer.context, {\r\n\t\t\t\tframe: nextFrame,\r\n\t\t\t\tposition: {\r\n\t\t\t\t\tx: this.bounds.min.x,\r\n\t\t\t\t\ty: this.bounds.min.y\r\n\t\t\t\t},\r\n\t\t\t\tshowBones: showBones\r\n\t\t\t});\r\n\t\t\trenderer.restore();\r\n\r\n\t\t\tif (!this.keyframes[currentMark]) {\r\n\t\t\t\tcurrentMark = currentFrame;\r\n\t\t\t}\r\n\r\n\t\t\tthis.renderTo(renderer.context, {\r\n\t\t\t\tframe: currentMark,\r\n\t\t\t\tposition: {\r\n\t\t\t\t\tx: this.bounds.min.x,\r\n\t\t\t\t\ty: this.bounds.min.y\r\n\t\t\t\t},\r\n\t\t\t\tshowBones: showBones,\r\n\t\t\t\tshowSkin: true,\r\n\t\t\t\tworkColor: true\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n}\r\n\r\nconst rigModel = new RigModel();\r\n\r\nevents.once("loadedApps", vue => {\r\n\ttimeline = vue.timeline;\r\n\r\n\trigModel.setKeyframe(0, {\r\n\t\tlocked: true,\r\n\t\tignoreHistory: true\r\n\t});\r\n});\r\n\r\nmodule.exports = rigModel;\n\n//# sourceURL=webpack:///./src/client/js/rig.model.js?')},"./src/client/js/vue/contextMenu.js":function(module,exports,__webpack_require__){eval('const clonedeep = __webpack_require__(/*! lodash.clonedeep */ "./node_modules/lodash.clonedeep/index.js");\r\nconst rigModel = __webpack_require__(/*! ../rig.model.js */ "./src/client/js/rig.model.js");\r\nconst config = __webpack_require__(/*! ../../../lib/config.js */ "./src/lib/config.js");\r\nconst utils = __webpack_require__(/*! ../../../lib/utils.js */ "./src/lib/utils.js");\r\nconst vector = __webpack_require__(/*! ../../../lib/vector.js */ "./src/lib/vector.js");\r\n\r\nconst contextMenuApp = new Vue({\r\n\tel: "#contextMenuApp",\r\n\tdata: {\r\n\t\tselectedKeyframe: null,\r\n\t\thidden: true,\r\n\t\tposition: {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0\r\n\t\t},\r\n\t\twidth: document.getElementById("contextMenuApp").offsetWidth,\r\n\t\theight: document.getElementById("contextMenuApp").offsetHeight,\r\n\r\n\t},\r\n\tmethods: {\r\n\t\tshow: function(x, y) {\r\n\t\t\tthis.hidden = false;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.width = this.$el.offsetWidth;\r\n\t\t\t\tthis.height = this.$el.offsetHeight;\r\n\t\t\t\tthis.position.x = x;\r\n\t\t\t\tthis.position.y = y;\r\n\t\t\t\tthis.$el.style.left = `${this.position.x}px`;\r\n\t\t\t\tthis.$el.style.top = `${this.position.y}px`;\r\n\t\t\t});\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tthis.hidden = true;\r\n\t\t},\r\n\t\tcopy: function() {\r\n\t\t\trigModel.copiedKeyframe = clonedeep(rigModel.getKeyframe("selected", true));\r\n\t\t},\r\n\t\tpaste: function() {\r\n\t\t\tconst timeline = __webpack_require__(/*! ./timeline.js */ "./src/client/js/vue/timeline.js");\r\n\t\t\tlet copiedKeyframe = rigModel.copiedKeyframe;\r\n\t\t\tif (copiedKeyframe) {\r\n\t\t\t\trigModel.setKeyframe(timeline.graph.state.currentMark, {\r\n\t\t\t\t\tposition: vector(timeline.graph.state.currentMark * timeline.graph.hatchMark.spacing + timeline.graph.hatchMark.spacing / 2, config.render.keyframe.y),\r\n\t\t\t\t\tlocked: timeline.graph.state.currentMark == 0 ? true : false,\r\n\t\t\t\t\tid: utils.uid(),\r\n\t\t\t\t\tjoints: copiedKeyframe.joints\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nwindow.contextMenuApp = contextMenuApp;\r\n\r\nmodule.exports = contextMenuApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/contextMenu.js?')},"./src/client/js/vue/crop.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst dom = __webpack_require__(/*! ../../../lib/dom.js */ "./src/lib/dom.js");\r\nconst utils = __webpack_require__(/*! ../../../lib/utils.js */ "./src/lib/utils.js");\r\nconst config = __webpack_require__(/*! ../../../lib/config.js */ "./src/lib/config.js");\r\n\r\nfunction createRect(ctx, x, y, width, height) {\r\n\tctx.beginPath();\r\n\tctx.rect(x, y, width, height);\r\n\tctx.closePath();\r\n}\r\n\r\nconst cropApp = new Vue({\r\n\tel: "#cropApp",\r\n\tdata: {\r\n\t\tcropFrom: {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0\r\n\t\t},\r\n\t\tcropTo: null,\r\n\t\tcropBoundsThickness: 6,\r\n\t\tcanvas: null,\r\n\t\tcontext: null,\r\n\t\timage: null,\r\n\t\timageSize: null,\r\n\t\thidden: true\r\n\t},\r\n\tmethods: {\r\n\t\tshow: function(img) {\r\n\t\t\tthis.hidden = false;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.$el.style.opacity = "1";\r\n\t\t\t\tdom.query("#cropApp .drag").draggable({\r\n\t\t\t\t\trestrict: true,\r\n\t\t\t\t\troot: this.$el\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis.canvas = document.getElementById("cropCanvas");\r\n\t\t\t\tthis.context = this.canvas.getContext("2d");\r\n\r\n\t\t\t\tthis.image = img;\r\n\t\t\t\tthis.imageSize = utils.scaleSize(this.image.width, this.image.height, this.canvas.parentNode.offsetWidth, this.canvas.parentNode.offsetWidth);\r\n\t\t\t\tthis.canvas.width = this.imageSize.width;\r\n\t\t\t\tthis.canvas.height = this.imageSize.height;\r\n\r\n\t\t\t\tif (!this.cropTo) {\r\n\t\t\t\t\tthis.cropTo = {\r\n\t\t\t\t\t\tx: this.imageSize.width,\r\n\t\t\t\t\t\ty: this.imageSize.height\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.redraw();\r\n\t\t\t});\r\n\r\n\t\t\tevents.emit("renderSleep");\r\n\t\t},\r\n\t\tredraw: function() {\r\n\t\t\tif (this.canvas && this.context && this.image) {\r\n\t\t\t\tlet ctx = this.context;\r\n\r\n\t\t\t\tctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n\t\t\t\t//Draw image\r\n\t\t\t\tctx.drawImage(this.image, 0, 0, this.canvas.width, this.canvas.height);\r\n\r\n\t\t\t\t//Make cropped areas darker\r\n\t\t\t\tctx.beginPath();\r\n\t\t\t\tctx.moveTo(this.cropFrom.x, this.cropFrom.y);\r\n\t\t\t\tctx.lineTo(this.cropTo.x, this.cropFrom.y);\r\n\t\t\t\tctx.lineTo(this.cropTo.x, this.cropTo.y);\r\n\t\t\t\tctx.lineTo(this.cropFrom.x, this.cropTo.y);\r\n\t\t\t\tctx.lineTo(this.cropFrom.x, this.cropFrom.y);\r\n\t\t\t\tctx.lineTo(0, 0);\r\n\t\t\t\tctx.lineTo(0, this.canvas.height);\r\n\t\t\t\tctx.lineTo(this.canvas.width, this.canvas.height);\r\n\t\t\t\tctx.lineTo(this.canvas.width, 0);\r\n\t\t\t\tctx.lineTo(0, 0);\r\n\t\t\t\tctx.closePath();\r\n\t\t\t\tctx.fillStyle = "rgba(0, 0, 0, 0.4)";\r\n\t\t\t\tctx.fill();\r\n\r\n\t\t\t\t//Create crop bounding box\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.clip();\r\n\t\t\t\tcreateRect(ctx, this.cropFrom.x - this.cropBoundsThickness / 2, this.cropFrom.y - this.cropBoundsThickness / 2, this.cropTo.x - this.cropFrom.x + this.cropBoundsThickness, this.cropTo.y - this.cropFrom.y + this.cropBoundsThickness);\r\n\t\t\t\tctx.fillStyle = config.accent;\r\n\t\t\t\tctx.fill();\r\n\t\t\t\tctx.restore();\r\n\t\t\t}\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tthis.hidden = true;\r\n\t\t\tthis.canvas = null;\r\n\t\t\tthis.context = null;\r\n\t\t\tevents.emit("renderFocus");\r\n\t\t},\r\n\t\tgetCrop: function () {\r\n\t\t\treturn {\r\n\t\t\t\tfrom: {\r\n\t\t\t\t\tx: utils.map(this.cropFrom.x, 0, this.imageSize.width, 0, this.image.width),\r\n\t\t\t\t\ty: utils.map(this.cropFrom.y, 0, this.imageSize.height, 0, this.image.height)\r\n\t\t\t\t},\r\n\t\t\t\tto: {\r\n\t\t\t\t\tx: utils.map(this.cropTo.x, 0, this.imageSize.width, 0, this.image.width),\r\n\t\t\t\t\ty: utils.map(this.cropTo.y, 0, this.imageSize.width, 0, this.image.width)\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\tsave: function() {\r\n\t\t\tthis.hide();\r\n\t\t\tevents.emit("crop", this.getCrop(), {\r\n\t\t\t\tfrom: this.cropFrom,\r\n\t\t\t\tto: this.cropTo\r\n\t\t\t});\r\n\t\t},\r\n\t\treset: function () {\r\n\t\t\tthis.cropFrom = {\r\n\t\t\t\tx: 0,\r\n\t\t\t\ty: 0\r\n\t\t\t};\r\n\r\n\t\t\tthis.cropTo = {\r\n\t\t\t\tx: this.canvas.width,\r\n\t\t\t\ty: this.canvas.height\r\n\t\t\t};\r\n\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nfunction getMousePosition(x, y) {\r\n\tlet onTop = false,\r\n\t\tonBottom = false,\r\n\t\tonLeft = false,\r\n\t\tonRight = false;\r\n\tif (x >= cropApp.cropFrom.x - cropApp.cropBoundsThickness && x <= cropApp.cropFrom.x + cropApp.cropBoundsThickness && y >= cropApp.cropFrom.y - cropApp.cropBoundsThickness && y <= cropApp.cropTo.y + cropApp.cropBoundsThickness) {\r\n\t\tonLeft = true;\r\n\t} else {\r\n\t\tonLeft = false;\r\n\t}\r\n\r\n\tif (x >= cropApp.cropTo.x - cropApp.cropBoundsThickness && x <= cropApp.cropTo.x + cropApp.cropBoundsThickness && y >= cropApp.cropFrom.y - cropApp.cropBoundsThickness && y <= cropApp.cropTo.y + cropApp.cropBoundsThickness) {\r\n\t\tonRight = true;\r\n\t} else {\r\n\t\tonRight = false;\r\n\t}\r\n\r\n\tif (y >= cropApp.cropFrom.y - cropApp.cropBoundsThickness && y <= cropApp.cropFrom.y + cropApp.cropBoundsThickness && x >= cropApp.cropFrom.x - cropApp.cropBoundsThickness && x <= cropApp.cropTo.x + cropApp.cropBoundsThickness) {\r\n\t\tonTop = true;\r\n\t} else {\r\n\t\tonTop = false;\r\n\t}\r\n\r\n\tif (y >= cropApp.cropTo.y - cropApp.cropBoundsThickness && y <= cropApp.cropTo.y + cropApp.cropBoundsThickness && x >= cropApp.cropFrom.x - cropApp.cropBoundsThickness && x <= cropApp.cropTo.x + cropApp.cropBoundsThickness) {\r\n\t\tonBottom = true;\r\n\t} else {\r\n\t\tonBottom = false;\r\n\t}\r\n\r\n\treturn {\r\n\t\ttop: onTop,\r\n\t\tright: onRight,\r\n\t\tbottom: onBottom,\r\n\t\tleft: onLeft\r\n\t};\r\n}\r\n\r\nlet doc = dom.query("body");\r\nlet isDragging = false,\r\n\tstartMousePos,\r\n\tstartMouse,\r\n\tstartWidth,\r\n\tstartHeight;\r\n\r\nfunction dragStart(event) {\r\n\tif (cropApp.canvas && cropApp.context) {\r\n\t\tlet mouseX = event.clientX;\r\n\t\tlet mouseY = event.clientY;\r\n\t\tlet canvasBounds = cropApp.canvas.getBoundingClientRect();\r\n\t\tlet canvasX = mouseX - canvasBounds.x;\r\n\t\tlet canvasY = mouseY - canvasBounds.y;\r\n\t\tisDragging = true;\r\n\t\tstartMousePos = getMousePosition(canvasX, canvasY);\r\n\t\tstartMouse = {\r\n\t\t\tx: canvasX - cropApp.cropFrom.x,\r\n\t\t\ty: canvasY - cropApp.cropFrom.y\r\n\t\t};\r\n\t\tstartWidth = cropApp.cropTo.x - cropApp.cropFrom.x;\r\n\t\tstartHeight = cropApp.cropTo.y - cropApp.cropFrom.y;\r\n\t}\r\n}\r\n\r\nfunction dragEnd() {\r\n\tisDragging = false;\r\n}\r\n\r\nfunction drag(event) {\r\n\tlet mouseX = event.clientX;\r\n\tlet mouseY = event.clientY;\r\n\tif (cropApp.canvas && cropApp.context) {\r\n\t\tlet canvasBounds = cropApp.canvas.getBoundingClientRect();\r\n\t\tlet canvasX = mouseX - canvasBounds.x;\r\n\t\tlet canvasY = mouseY - canvasBounds.y;\r\n\r\n\t\tlet mousePos = getMousePosition(canvasX, canvasY);\r\n\r\n\t\tlet inside = canvasX >= cropApp.cropFrom.x + cropApp.cropBoundsThickness / 2 && canvasX <= cropApp.cropTo.x - cropApp.cropBoundsThickness / 2 && canvasY >= cropApp.cropFrom.y + cropApp.cropBoundsThickness / 2 && canvasY <= cropApp.cropTo.y - cropApp.cropBoundsThickness / 2;\r\n\r\n\t\tif (isDragging) {\r\n\t\t\tif (startMousePos.top) {\r\n\t\t\t\tcropApp.cropFrom.y = canvasY;\r\n\t\t\t\tcropApp.redraw();\r\n\t\t\t}\r\n\r\n\t\t\tif (startMousePos.left) {\r\n\t\t\t\tcropApp.cropFrom.x = canvasX;\r\n\t\t\t\tcropApp.redraw();\r\n\t\t\t}\r\n\r\n\t\t\tif (startMousePos.bottom) {\r\n\t\t\t\tcropApp.cropTo.y = canvasY;\r\n\t\t\t\tcropApp.redraw();\r\n\t\t\t}\r\n\r\n\t\t\tif (startMousePos.right) {\r\n\t\t\t\tcropApp.cropTo.x = canvasX;\r\n\t\t\t\tcropApp.redraw();\r\n\t\t\t}\r\n\r\n\t\t\tif (!startMousePos.top && !startMousePos.bottom && !startMousePos.left && !startMousePos.right && inside) {\r\n\t\t\t\tcropApp.cropFrom.x = canvasX - startMouse.x;\r\n\t\t\t\tcropApp.cropFrom.y = canvasY - startMouse.y;\r\n\t\t\t\tcropApp.cropTo.x = cropApp.cropFrom.x + startWidth;\r\n\t\t\t\tcropApp.cropTo.y = cropApp.cropFrom.y + startHeight;\r\n\t\t\t\tcropApp.redraw();\r\n\t\t\t}\r\n\r\n\t\t\tcropApp.cropFrom.y = utils.clamp(cropApp.cropFrom.y, 0, cropApp.cropTo.y)\r\n\t\t\tcropApp.cropFrom.x = utils.clamp(cropApp.cropFrom.x, 0, cropApp.cropTo.x)\r\n\t\t\tcropApp.cropTo.y = utils.clamp(cropApp.cropTo.y, cropApp.cropFrom.y, cropApp.canvas.height)\r\n\t\t\tcropApp.cropTo.x = utils.clamp(cropApp.cropTo.x, cropApp.cropFrom.x, cropApp.canvas.width)\r\n\t\t} else {\r\n\t\t\tif (mousePos.left || mousePos.right) {\r\n\t\t\t\tdoc.css("cursor", "ew-resize");\r\n\t\t\t}\r\n\r\n\t\t\tif (mousePos.top || mousePos.bottom) {\r\n\t\t\t\tdoc.css("cursor", "ns-resize");\r\n\t\t\t}\r\n\r\n\t\t\tif (mousePos.top && mousePos.left) {\r\n\t\t\t\tdoc.css("cursor", "nw-resize");\r\n\t\t\t}\r\n\r\n\t\t\tif (mousePos.top && mousePos.right) {\r\n\t\t\t\tdoc.css("cursor", "ne-resize");\r\n\t\t\t}\r\n\r\n\t\t\tif (mousePos.bottom && mousePos.left) {\r\n\t\t\t\tdoc.css("cursor", "sw-resize");\r\n\t\t\t}\r\n\r\n\t\t\tif (mousePos.bottom && mousePos.right) {\r\n\t\t\t\tdoc.css("cursor", "se-resize");\r\n\t\t\t}\r\n\r\n\t\t\tif (!mousePos.top && !mousePos.bottom && !mousePos.left && !mousePos.right) {\r\n\t\t\t\tdoc.css("cursor", "unset");\r\n\t\t\t}\r\n\r\n\t\t\tif (inside) {\r\n\t\t\t\tdoc.css("cursor", "move");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\naddEventListener("mousedown", dragStart);\r\naddEventListener("mouseup", dragEnd);\r\naddEventListener("mousemove", drag);\r\n\r\n\r\nmodule.exports = cropApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/crop.js?')},"./src/client/js/vue/export.frames.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst utils = __webpack_require__(/*! ../../../lib/utils.js */ "./src/lib/utils.js");\r\nconst dom = __webpack_require__(/*! ../../../lib/dom.js */ "./src/lib/dom.js");\r\nconst timeline = __webpack_require__(/*! ./timeline.js */ "./src/client/js/vue/timeline.js");\r\nconst randomTitle = __webpack_require__(/*! ../random.title.js */ "./src/client/js/random.title.js");\r\n\r\nconst framesExportApp = new Vue({\r\n\tel: "#framesExportApp",\r\n\tdata: {\r\n\t\thidden: true\r\n\t},\r\n\tmethods: {\r\n\t\tshow: function() {\r\n\t\t\tthis.hidden = false;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.$el.style.opacity = "1";\r\n\t\t\t\tdom.query("#framesExportApp .drag").draggable({\r\n\t\t\t\t\trestrict: true,\r\n\t\t\t\t\troot: this.$el\r\n\t\t\t\t});\r\n\r\n\t\t\t\tdom.query("#framesExportApp .custom-checkbox", true).on("click", event => {\r\n\t\t\t\t\tlet el = dom.query(event.target).query(".checkbox");\r\n\t\t\t\t\tel.toggleClass("checked");\r\n\t\t\t\t});\r\n\r\n\t\t\t\tdom.query("#framesExportName").value(randomTitle.generate())\r\n\r\n\t\t\t\tlet startFrame = timeline.graph.playbackHandle.start.mark + 1;\r\n\t\t\t\tlet endFrame = timeline.graph.playbackHandle.end.mark + 1;\r\n\t\t\t\tlet bounds = rigModel.bounds;\r\n\t\t\t\tlet frameWidth = bounds.max.x - bounds.min.x;\r\n\t\t\t\tlet frameHeight = bounds.max.y - bounds.min.y;\r\n\t\t\t\tdom.query("#framesExportStart").value(startFrame);\r\n\t\t\t\tdom.query("#framesExportEnd").value(endFrame);\r\n\t\t\t\tdom.query("#framesExportWidth").value(frameWidth.toFixed(2));\r\n\t\t\t\tdom.query("#framesExportHeight").value(frameHeight.toFixed(2));\r\n\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tlet title = document.getElementById("framesExportName");\r\n\t\t\t\t\ttitle.focus();\r\n\t\t\t\t}, 100);\r\n\r\n\t\t\t\tevents.emit("renderSleep");\r\n\t\t\t});\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tthis.hidden = true;\r\n\t\t\tevents.emit("renderFocus");\r\n\t\t},\r\n\t\tvalidateFormat: function(e) {\r\n\t\t\te.target.value = e.target.value.replace(/[^0-9.-]/g, "").replace(/(\\..*)\\./g, "$1").replace(/^0+/g, "").replace(/(?<!^)-/g, "");\r\n\t\t\tthis.validateMax(e);\r\n\t\t},\r\n\t\tvalidateAmount: function(e) {\r\n\t\t\tthis.validateMin(e);\r\n\t\t\tthis.validateMax(e);\r\n\t\t},\r\n\t\tvalidateMax: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet max = e.target.dataset.max;\r\n\r\n\t\t\tif (e.target.id == "framesExportStart") {\r\n\t\t\t\tmax = parseInt(dom.query("#framesExportEnd").value());\r\n\t\t\t}\r\n\r\n\t\t\tif (e.target.id == "framesExportEnd") {\r\n\t\t\t\tmax = timeline.app.totalFrames;\r\n\t\t\t}\r\n\r\n\t\t\tif (parseInt(value) > max) {\r\n\t\t\t\te.target.value = max.toString();\r\n\t\t\t}\r\n\t\t},\r\n\t\tvalidateMin: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet min = e.target.dataset.min;\r\n\r\n\t\t\tif (e.target.id == "framesExportEnd") {\r\n\t\t\t\tmin = parseInt(dom.query("#framesExportStart").value());\r\n\t\t\t}\r\n\r\n\t\t\tif (parseInt(value) < min) {\r\n\t\t\t\te.target.value = min.toString();\r\n\t\t\t}\r\n\t\t},\r\n\t\ttoggleAmount: function(e) {\r\n\t\t\tif (e.target != document.activeElement) return;\r\n\t\t\tif (!e.target.value.length) {\r\n\t\t\t\te.target.value = 1;\r\n\t\t\t}\r\n\r\n\t\t\tlet isDown = e.wheelDeltaY < 0;\r\n\t\t\tlet value = parseFloat(e.target.value);\r\n\t\t\tif (isDown) {\r\n\t\t\t\tvalue--;\r\n\t\t\t} else {\r\n\t\t\t\tvalue++;\r\n\t\t\t}\r\n\r\n\t\t\tif (e.target.id == "framesExportWidth" || e.target.id == "framesExportHeight") {\r\n\t\t\t\tvalue = value.toFixed(2);\r\n\t\t\t}\r\n\r\n\t\t\te.target.value = value.toString();\r\n\t\t\tthis.validateAmount(e);\r\n\t\t},\r\n\t\tvalidate: function() {\r\n\t\t\tlet name = dom.query("#framesExportName").value();\r\n\t\t\tlet startFrame = parseInt(dom.query("#framesExportStart").value());\r\n\t\t\tlet endFrame = parseInt(dom.query("#framesExportEnd").value());\r\n\t\t\tlet totalFrames = endFrame - startFrame + 1;\r\n\t\t\tlet frameWidth = parseFloat(dom.query("#framesExportWidth").value());\r\n\t\t\tlet frameHeight = parseFloat(dom.query("#framesExportHeight").value());\r\n\t\t\tlet showSkin = dom.query("#framesExportShowSkin").query(".checkbox").hasClass("checked");\r\n\t\t\tlet showBones = dom.query("#framesExportShowBones").query(".checkbox").hasClass("checked");\r\n\t\t\tevents.emit("exportFrames", {\r\n\t\t\t\tname: name.length ? name : utils.uid(),\r\n\t\t\t\tstart: startFrame,\r\n\t\t\t\tend: endFrame,\r\n\t\t\t\ttotalFrames: totalFrames,\r\n\t\t\t\tframeWidth: frameWidth,\r\n\t\t\t\tframeHeight: frameHeight,\r\n\t\t\t\tshowSkin: showSkin,\r\n\t\t\t\tshowBones: showBones\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = framesExportApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/export.frames.js?')},"./src/client/js/vue/export.gif.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst utils = __webpack_require__(/*! ../../../lib/utils.js */ "./src/lib/utils.js");\r\nconst dom = __webpack_require__(/*! ../../../lib/dom.js */ "./src/lib/dom.js");\r\nconst timeline = __webpack_require__(/*! ./timeline.js */ "./src/client/js/vue/timeline.js");\r\nconst randomTitle = __webpack_require__(/*! ../random.title.js */ "./src/client/js/random.title.js");\r\n\r\nconst GIFExportApp = new Vue({\r\n\tel: "#GIFExportApp",\r\n\tdata: {\r\n\t\thidden: true\r\n\t},\r\n\tmethods: {\r\n\t\tshow: function() {\r\n\t\t\tthis.hidden = false;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.$el.style.opacity = "1";\r\n\t\t\t\tdom.query("#GIFExportApp .drag").draggable({\r\n\t\t\t\t\trestrict: true,\r\n\t\t\t\t\troot: this.$el\r\n\t\t\t\t});\r\n\r\n\t\t\t\tdom.query("#GIFExportApp .custom-checkbox", true).on("click", event => {\r\n\t\t\t\t\tlet el = dom.query(event.target).query(".checkbox");\r\n\t\t\t\t\tel.toggleClass("checked");\r\n\t\t\t\t});\r\n\r\n\t\t\t\tdom.query("#GIFExportName").value(randomTitle.generate())\r\n\r\n\t\t\t\tlet startFrame = timeline.graph.playbackHandle.start.mark + 1;\r\n\t\t\t\tlet endFrame = timeline.graph.playbackHandle.end.mark + 1;\r\n\t\t\t\tlet bounds = rigModel.bounds;\r\n\t\t\t\tlet frameWidth = bounds.max.x - bounds.min.x;\r\n\t\t\t\tlet frameHeight = bounds.max.y - bounds.min.y;\r\n\t\t\t\tdom.query("#GIFExportStart").value(startFrame);\r\n\t\t\t\tdom.query("#GIFExportEnd").value(endFrame);\r\n\t\t\t\tdom.query("#GIFExportWidth").value(frameWidth.toFixed(2));\r\n\t\t\t\tdom.query("#GIFExportHeight").value(frameHeight.toFixed(2));\r\n\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tlet title = document.getElementById("GIFExportName");\r\n\t\t\t\t\ttitle.focus();\r\n\t\t\t\t}, 100);\r\n\r\n\t\t\t\tevents.emit("renderSleep");\r\n\t\t\t});\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tthis.hidden = true;\r\n\t\t\tevents.emit("renderFocus");\r\n\t\t},\r\n\t\tvalidateFormat: function(e) {\r\n\t\t\te.target.value = e.target.value.replace(/[^0-9.-]/g, "").replace(/(\\..*)\\./g, "$1").replace(/^0+/g, "").replace(/(?<!^)-/g, "");\r\n\t\t\tthis.validateMax(e);\r\n\t\t},\r\n\t\tvalidateAmount: function(e) {\r\n\t\t\tthis.validateMin(e);\r\n\t\t\tthis.validateMax(e);\r\n\t\t},\r\n\t\tvalidateMax: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet max = e.target.dataset.max;\r\n\r\n\t\t\tif (e.target.id == "GIFExportStart") {\r\n\t\t\t\tmax = parseInt(dom.query("#GIFExportEnd").value());\r\n\t\t\t}\r\n\r\n\t\t\tif (e.target.id == "GIFExportEnd") {\r\n\t\t\t\tmax = timeline.app.totalFrames;\r\n\t\t\t}\r\n\r\n\t\t\tif (parseInt(value) > max) {\r\n\t\t\t\te.target.value = max.toString();\r\n\t\t\t}\r\n\t\t},\r\n\t\tvalidateMin: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet min = e.target.dataset.min;\r\n\r\n\t\t\tif (e.target.id == "GIFExportEnd") {\r\n\t\t\t\tmin = parseInt(dom.query("#GIFExportStart").value());\r\n\t\t\t}\r\n\r\n\t\t\tif (parseInt(value) < min) {\r\n\t\t\t\te.target.value = min.toString();\r\n\t\t\t}\r\n\t\t},\r\n\t\ttoggleAmount: function(e) {\r\n\t\t\tif (e.target != document.activeElement) return;\r\n\t\t\tif (!e.target.value.length) {\r\n\t\t\t\te.target.value = 1;\r\n\t\t\t}\r\n\r\n\t\t\tlet isDown = e.wheelDeltaY < 0;\r\n\t\t\tlet value = parseFloat(e.target.value);\r\n\t\t\tif (isDown) {\r\n\t\t\t\tvalue--;\r\n\t\t\t} else {\r\n\t\t\t\tvalue++;\r\n\t\t\t}\r\n\r\n\t\t\tif (e.target.id == "GIFExportWidth" || e.target.id == "GIFExportHeight") {\r\n\t\t\t\tvalue = value.toFixed(2);\r\n\t\t\t}\r\n\r\n\t\t\te.target.value = value.toString();\r\n\t\t\tthis.validateAmount(e);\r\n\t\t},\r\n\t\tvalidate: function() {\r\n\t\t\tlet name = dom.query("#GIFExportName").value();\r\n\t\t\tlet startFrame = parseInt(dom.query("#GIFExportStart").value());\r\n\t\t\tlet endFrame = parseInt(dom.query("#GIFExportEnd").value());\r\n\t\t\tlet totalFrames = endFrame - startFrame + 1;\r\n\t\t\tlet width = parseFloat(dom.query("#GIFExportWidth").value());\r\n\t\t\tlet height = parseFloat(dom.query("#GIFExportHeight").value());\r\n\t\t\tlet background = dom.query("#GIFExportBackground").value();\r\n\t\t\tlet showSkin = dom.query("#GIFExportShowSkin").query(".checkbox").hasClass("checked");\r\n\t\t\tlet showBones = dom.query("#GIFExportShowBones").query(".checkbox").hasClass("checked");\r\n\t\t\tevents.emit("exportGIF", {\r\n\t\t\t\tname: name.length ? name : utils.uid(),\r\n\t\t\t\tstart: startFrame,\r\n\t\t\t\tend: endFrame,\r\n\t\t\t\ttotalFrames: totalFrames,\r\n\t\t\t\twidth: width,\r\n\t\t\t\theight: height,\r\n\t\t\t\tshowSkin: showSkin,\r\n\t\t\t\tshowBones: showBones,\r\n\t\t\t\tbackground: background\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = GIFExportApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/export.gif.js?')},"./src/client/js/vue/export.spritesheet.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst utils = __webpack_require__(/*! ../../../lib/utils.js */ "./src/lib/utils.js");\r\nconst dom = __webpack_require__(/*! ../../../lib/dom.js */ "./src/lib/dom.js");\r\nconst timeline = __webpack_require__(/*! ./timeline.js */ "./src/client/js/vue/timeline.js");\r\nconst randomTitle = __webpack_require__(/*! ../random.title.js */ "./src/client/js/random.title.js");\r\n\r\nconst spritesheetExportApp = new Vue({\r\n\tel: "#spritesheetExportApp",\r\n\tdata: {\r\n\t\thidden: true\r\n\t},\r\n\tmethods: {\r\n\t\tshow: function() {\r\n\t\t\tthis.hidden = false;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.$el.style.opacity = "1";\r\n\t\t\t\tdom.query("#spritesheetExportApp .drag").draggable({\r\n\t\t\t\t\trestrict: true,\r\n\t\t\t\t\troot: this.$el\r\n\t\t\t\t});\r\n\r\n\t\t\t\tdom.query("#spritesheetExportApp .custom-checkbox", true).on("click", event => {\r\n\t\t\t\t\tlet el = dom.query(event.target).query(".checkbox");\r\n\t\t\t\t\tel.toggleClass("checked");\r\n\t\t\t\t});\r\n\r\n\t\t\t\tdom.query("#spritesheetName").value(randomTitle.generate())\r\n\r\n\t\t\t\tlet startFrame = timeline.graph.playbackHandle.start.mark + 1;\r\n\t\t\t\tlet endFrame = timeline.graph.playbackHandle.end.mark + 1;\r\n\t\t\t\tlet bounds = rigModel.bounds;\r\n\t\t\t\tlet cellWidth = bounds.max.x - bounds.min.x;\r\n\t\t\t\tlet cellHeight = bounds.max.y - bounds.min.y;\r\n\t\t\t\tlet rowCount = Math.ceil(Math.sqrt(endFrame - startFrame));\r\n\t\t\t\tdom.query("#spritesheetStart").value(startFrame);\r\n\t\t\t\tdom.query("#spritesheetEnd").value(endFrame);\r\n\t\t\t\tdom.query("#spritesheetCellWidth").value(cellWidth.toFixed(2));\r\n\t\t\t\tdom.query("#spritesheetCellHeight").value(cellHeight.toFixed(2));\r\n\t\t\t\tdom.query("#spritesheetRowCount").value(rowCount);\r\n\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tlet title = document.getElementById("spritesheetName");\r\n\t\t\t\t\ttitle.focus();\r\n\t\t\t\t}, 100);\r\n\r\n\t\t\t\tevents.emit("renderSleep");\r\n\t\t\t});\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tthis.hidden = true;\r\n\t\t\tevents.emit("renderFocus");\r\n\t\t},\r\n\t\tvalidateFormat: function(e) {\r\n\t\t\te.target.value = e.target.value.replace(/[^0-9.-]/g, "").replace(/(\\..*)\\./g, "$1").replace(/^0+/g, "").replace(/(?<!^)-/g, "");\r\n\t\t\tthis.validateMax(e);\r\n\t\t},\r\n\t\tvalidateAmount: function(e) {\r\n\t\t\tthis.validateMin(e);\r\n\t\t\tthis.validateMax(e);\r\n\t\t},\r\n\t\tvalidateMax: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet max = e.target.dataset.max;\r\n\r\n\t\t\tif (e.target.id == "spritesheetRowCount") {\r\n\t\t\t\tlet totalFrames = parseInt(dom.query("#spritesheetEnd").value()) - parseInt(dom.query("#spritesheetStart").value());\r\n\r\n\t\t\t\tmax = totalFrames + 1;\r\n\t\t\t}\r\n\r\n\t\t\tif (e.target.id == "spritesheetStart") {\r\n\t\t\t\tmax = parseInt(dom.query("#spritesheetEnd").value());\r\n\t\t\t}\r\n\r\n\t\t\tif (e.target.id == "spritesheetEnd") {\r\n\t\t\t\tmax = timeline.app.totalFrames;\r\n\t\t\t}\r\n\r\n\t\t\tif (parseInt(value) > max) {\r\n\t\t\t\te.target.value = max.toString();\r\n\t\t\t}\r\n\t\t},\r\n\t\tvalidateMin: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet min = e.target.dataset.min;\r\n\r\n\t\t\tif (e.target.id == "spritesheetEnd") {\r\n\t\t\t\tmin = parseInt(dom.query("#spritesheetStart").value());\r\n\t\t\t}\r\n\r\n\t\t\tif (parseInt(value) < min) {\r\n\t\t\t\te.target.value = min.toString();\r\n\t\t\t}\r\n\t\t},\r\n\t\ttoggleAmount: function(e) {\r\n\t\t\tif (e.target != document.activeElement) return;\r\n\t\t\tif (!e.target.value.length) {\r\n\t\t\t\te.target.value = 1;\r\n\t\t\t}\r\n\r\n\t\t\tlet isDown = e.wheelDeltaY < 0;\r\n\t\t\tlet value = parseFloat(e.target.value);\r\n\t\t\tif (isDown) {\r\n\t\t\t\tvalue--;\r\n\t\t\t} else {\r\n\t\t\t\tvalue++;\r\n\t\t\t}\r\n\r\n\t\t\tif (e.target.id == "spritesheetCellWidth" || e.target.id == "spritesheetCellHeight") {\r\n\t\t\t\tvalue = value.toFixed(2);\r\n\t\t\t}\r\n\r\n\t\t\te.target.value = value.toString();\r\n\t\t\tthis.validateAmount(e);\r\n\t\t},\r\n\t\tvalidate: function() {\r\n\t\t\tlet name = dom.query("#spritesheetName").value();\r\n\t\t\tlet startFrame = parseInt(dom.query("#spritesheetStart").value());\r\n\t\t\tlet endFrame = parseInt(dom.query("#spritesheetEnd").value());\r\n\t\t\tlet totalFrames = endFrame - startFrame + 1;\r\n\t\t\tlet cellWidth = parseFloat(dom.query("#spritesheetCellWidth").value());\r\n\t\t\tlet cellHeight = parseFloat(dom.query("#spritesheetCellHeight").value());\r\n\t\t\tlet rowCount = parseInt(dom.query("#spritesheetRowCount").value());\r\n\t\t\tlet showSkin = dom.query("#spritesheetShowSkin").query(".checkbox").hasClass("checked");\r\n\t\t\tlet showBones = dom.query("#spritesheetShowBones").query(".checkbox").hasClass("checked");\r\n\t\t\tlet columnCount = Math.ceil(totalFrames / rowCount);\r\n\t\t\tevents.emit("exportSpritesheet", {\r\n\t\t\t\tname: name.length ? name : utils.uid(),\r\n\t\t\t\tstart: startFrame,\r\n\t\t\t\tend: endFrame,\r\n\t\t\t\ttotalFrames: totalFrames,\r\n\t\t\t\tcellWidth: cellWidth,\r\n\t\t\t\tcellHeight: cellHeight,\r\n\t\t\t\trows: rowCount,\r\n\t\t\t\tcols: columnCount,\r\n\t\t\t\tshowSkin: showSkin,\r\n\t\t\t\tshowBones: showBones\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = spritesheetExportApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/export.spritesheet.js?')},"./src/client/js/vue/file.js":function(module,exports,__webpack_require__){eval('const saveApp = __webpack_require__(/*! ./save.js */ "./src/client/js/vue/save.js");\r\nconst loadApp = __webpack_require__(/*! ./load.js */ "./src/client/js/vue/load.js");\r\nconst spritesheetExportApp = __webpack_require__(/*! ./export.spritesheet.js */ "./src/client/js/vue/export.spritesheet.js");\r\nconst framesExportApp = __webpack_require__(/*! ./export.frames.js */ "./src/client/js/vue/export.frames.js");\r\nconst GIFExportApp = __webpack_require__(/*! ./export.gif.js */ "./src/client/js/vue/export.gif.js");\r\n\r\nconst fileApp = new Vue({\r\n\tel: "#fileApp",\r\n\tdata: {\r\n\t\tshowExportFormats: false,\r\n\t\thidden: true,\r\n\t\tposition: {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0\r\n\t\t}\r\n\t},\r\n\tmethods: {\r\n\t\tshow: function(x, y) {\r\n\t\t\tthis.hidden = false;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tlet fileButtonBounds = document.getElementById("fileButton").getBoundingClientRect();\r\n\t\t\t\tthis.$el.style.left = `${fileButtonBounds.x}px`;\r\n\t\t\t\tthis.$el.style.top = `${fileButtonBounds.y + fileButtonBounds.height + 3}px`;\r\n\t\t\t});\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tthis.hidden = true;\r\n\t\t\tthis.showExportFormats = false;\r\n\t\t},\r\n\t\tshowSaveApp: function () {\r\n\t\t\tsaveApp.show();\r\n\t\t},\r\n\t\tshowLoadApp: function () {\r\n\t\t\tloadApp.show();\r\n\t\t},\r\n\t\tshowSpritesheetExportApp: function () {\r\n\t\t\tspritesheetExportApp.show();\r\n\t\t},\r\n\t\tshowFrameExportApp: function () {\r\n\t\t\tframesExportApp.show();\r\n\t\t},\r\n\t\tshowGIFExportApp: function () {\r\n\t\t\tGIFExportApp.show();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = fileApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/file.js?')},"./src/client/js/vue/load.js":function(module,exports,__webpack_require__){eval('const yj = __webpack_require__(/*! yieldable-json */ "./node_modules/yieldable-json/index.js");\r\nconst events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst dom = __webpack_require__(/*! ../../../lib/dom.js */ "./src/lib/dom.js");\r\n\r\nvar currentJSON;\r\nconst loadApp = new Vue({\r\n\tel: "#loadApp",\r\n\tdata: {\r\n\t\thidden: true,\r\n\t\tcloseMsg: "Close",\r\n\t\terrorMessage: "",\r\n\t\tfileError: false\r\n\t},\r\n\tmethods: {\r\n\t\tshow: function() {\r\n\t\t\tthis.hidden = false;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.$el.style.opacity = "1";\r\n\t\t\t\tdom.query("#loadApp .drag").draggable({\r\n\t\t\t\t\trestrict: true,\r\n\t\t\t\t\troot: this.$el\r\n\t\t\t\t});\r\n\r\n\t\t\t\tevents.emit("renderSleep");\r\n\t\t\t});\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tcurrentJSON = undefined;\r\n\t\t\tevents.emit("renderFocus");\r\n\r\n\t\t\tdom.query("#import").addClass("disabled");\r\n\r\n\t\t\tthis.fileError = false;\r\n\t\t\tthis.hidden = true;\r\n\t\t},\r\n\t\tcheckFile: function() {\r\n\t\t\tlet fileEl = dom.query("#importInput");\r\n\t\t\tlet filenameEl = dom.query("#loadFilename");\r\n\t\t\tlet file = fileEl.node.files[0];\r\n\t\t\tif (!file) return;\r\n\t\t\tlet filename = file.name;\r\n\t\t\tlet fileExtension = filename.split(".")[filename.split(".").length - 1];\r\n\t\t\tlet importButton = dom.query("#import");\r\n\t\t\timportButton.addClass("disabled");\r\n\t\t\timportButton.text("Processing...", true);\r\n\t\t\tif (fileExtension == "rigme") {\r\n\t\t\t\tfilenameEl.text(filename, true);\r\n\t\t\t\tlet fileURL = URL.createObjectURL(file);\r\n\t\t\t\tif (fileURL) {\r\n\t\t\t\t\tfetch(fileURL).then(res => {\r\n\t\t\t\t\t\tres.text().then(text => {\r\n\t\t\t\t\t\t\tlet json;\r\n\t\t\t\t\t\t\tlet error = false;\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tyj.parseAsync(text, (err, res) => {\r\n\t\t\t\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\t\t\t\terror = true;\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tjson = res;\r\n\t\t\t\t\t\t\t\t\terror = false;\r\n\t\t\t\t\t\t\t\t\tcurrentJSON = json;\r\n\t\t\t\t\t\t\t\t\timportButton.text("Load", true);\r\n\t\t\t\t\t\t\t\t\timportButton.removeClass("disabled");\r\n\t\t\t\t\t\t\t\t\tthis.fileError = false;\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\t\timportButton.addClass("disabled");\r\n\t\t\t\t\t\t\t\tthis.errorMessage = "This file is corrupted.";\r\n\t\t\t\t\t\t\t\tthis.fileError = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tvalidate: function() {\r\n\t\t\tif (!currentJSON) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tevents.emit("loadProject", currentJSON);\r\n\t\t\tthis.hide();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = loadApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/load.js?')},"./src/client/js/vue/option.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst mouse = __webpack_require__(/*! ../../../lib/mouse.js */ "./src/lib/mouse.js");\r\nconst overlayApp = __webpack_require__(/*! ./overlay.js */ "./src/client/js/vue/overlay.js");\r\nconst overlayConfig = __webpack_require__(/*! ./overlay.config.js */ "./src/client/js/vue/overlay.config.js");\r\n\r\nconst optionApp = new Vue({\r\n\tel: "#optionApp",\r\n\tdata: {\r\n\t\thidden: true,\r\n\t\toverlayConfigHidden: true,\r\n\t\tshowOverlayActions: false,\r\n\t\toverlayConfigDisabled: true,\r\n\t\tposition: {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0\r\n\t\t}\r\n\t},\r\n\tmethods: {\r\n\t\tshow: function(x, y) {\r\n\t\t\tthis.hidden = false;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tlet optionButtonBounds = document.getElementById("optionButton").getBoundingClientRect();\r\n\t\t\t\tthis.$el.style.left = `${optionButtonBounds.x}px`;\r\n\t\t\t\tthis.$el.style.top = `${optionButtonBounds.y + optionButtonBounds.height + 3}px`;\r\n\t\t\t});\r\n\t\t},\r\n\t\ttoggleOverlayActions: function (b) {\r\n\t\t\tthis.showOverlayActions = b;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tif (!this.overlayConfigDisabled) {\r\n\t\t\t\t\tdocument.getElementById("showOverlayConfigApp").classList.remove("disabled");\r\n\t\t\t\t\tdocument.getElementById("rotoscope").classList.remove("disabled");\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tthis.hidden = true;\r\n\t\t\tthis.showOverlayActions = false;\r\n\t\t},\r\n\t\tshowOverlayApp: function() {\r\n\t\t\toverlayApp.show();\r\n\t\t},\r\n\t\tshowOverlayConfigApp: function() {\r\n\t\t\toverlayConfig.show();\r\n\t\t},\r\n\t\tclearJoints: function() {\r\n\t\t\tlet con = confirm("Are you sure you want to reset everything?");\r\n\r\n\t\t\tif (con) {\r\n\t\t\t\tevents.emit("clearJoints");\r\n\t\t\t\tevents.emit("resetTimeline");\r\n\t\t\t\tevents.emit("resetCamera");\r\n\t\t\t}\r\n\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tmouse.pressed = false;\r\n\t\t\t\tmouse.dragged = false;\r\n\t\t\t}, 100);\r\n\t\t},\r\n\t\tresetTimeline: function() {\r\n\t\t\tlet con = confirm("Are you sure you want to reset the timeline? (This action won\'t affect the keyframes)");\r\n\r\n\t\t\tif (con) {\r\n\t\t\t\tevents.emit("resetTimeline");\r\n\t\t\t}\r\n\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tmouse.pressed = false;\r\n\t\t\t\tmouse.dragged = false;\r\n\t\t\t}, 100);\r\n\t\t},\r\n\t\tresetView: function() {\r\n\t\t\tevents.emit("resetCamera");\r\n\t\t},\r\n\t\tundo: function() {\r\n\t\t\tevents.emit("undo");\r\n\t\t},\r\n\t\tredo: function() {\r\n\t\t\tevents.emit("redo");\r\n\t\t},\r\n\t\trotoscope: function () {\r\n\t\t\tevents.emit("rotoscope");\r\n\t\t}\r\n\t}\r\n});\r\n\r\nevents.on("overlayFrames", () => {\r\n\toptionApp.overlayConfigDisabled = false;\r\n});\r\n\r\nmodule.exports = optionApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/option.js?')},"./src/client/js/vue/overlay.config.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst mouse = __webpack_require__(/*! ../../../lib/mouse.js */ "./src/lib/mouse.js");\r\nconst config = __webpack_require__(/*! ../../../lib/config.js */ "./src/lib/config.js");\r\nconst utils = __webpack_require__(/*! ../../../lib/utils.js */ "./src/lib/utils.js");\r\nconst dom = __webpack_require__(/*! ../../../lib/dom.js */ "./src/lib/dom.js");\r\nconst timeline = __webpack_require__(/*! ./timeline.js */ "./src/client/js/vue/timeline.js");\r\n\r\nlet minOpacity = 0;\r\nlet maxOpacity = 1;\r\nlet minScale = 0;\r\nlet maxScale = 6;\r\nlet minAngle = -Math.PI;\r\nlet maxAngle = Math.PI;\r\n\r\nlet activeSliderDrag;\r\nlet overlayFrames = [];\r\n\r\nconst overlayConfigApp = new Vue({\r\n\tel: "#overlayConfigApp",\r\n\tdata: {\r\n\t\thidden: true,\r\n\t\tcloseMsg: "Close",\r\n\t\topacity: maxOpacity,\r\n\t\tscale: 1,\r\n\t\tangle: 0,\r\n\t\ttrimStart: 1,\r\n\t\ttrimEnd: timeline.app.totalFrames,\r\n\t\tstart: 1\r\n\t},\r\n\tmethods: {\r\n\t\tfixData: function() {\r\n\t\t\tlet fromEl = document.getElementById("overlayConfigTrimStart");\r\n\t\t\tlet toEl = document.getElementById("overlayConfigTrimEnd");\r\n\t\t\tlet startEl = document.getElementById("overlayConfigStart");\r\n\r\n\t\t\tlet from = parseInt(fromEl.value);\r\n\t\t\tlet to = parseInt(toEl.value);\r\n\t\t\tlet start = parseInt(startEl.value);\r\n\t\t\tthis.trimStart = from ? from : 1;\r\n\t\t\tthis.trimEnd = to ? to : overlayFrames.length;\r\n\t\t\tthis.start = start ? start : 1;\r\n\t\t},\r\n\t\tvalidateFormat: function(e) {\r\n\t\t\te.target.value = e.target.value.replace(/[^0-9.-]/g, "").replace(/(\\..*)\\./g, "$1").replace(/^0+/g, "").replace(/(?<!^)-/g, "");\r\n\r\n\t\t\tthis.validateMax(e);\r\n\t\t\tthis.fixData();\r\n\t\t},\r\n\t\tvalidateAmount: function(e) {\r\n\t\t\tthis.validateMin(e);\r\n\t\t\tthis.validateMax(e);\r\n\t\t},\r\n\t\tvalidateMax: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet max = e.target.dataset.max;\r\n\r\n\t\t\tif (e.target.id == "overlayConfigTrimStart") {\r\n\t\t\t\tmax = this.trimEnd;\r\n\t\t\t}\r\n\r\n\t\t\tif (e.target.id == "overlayConfigTrimEnd") {\r\n\t\t\t\tmax = overlayFrames.length;\r\n\t\t\t}\r\n\r\n\t\t\tif (e.target.id == "overlayConfigStart") {\r\n\t\t\t\tmax = timeline.app.totalFrames;\r\n\t\t\t}\r\n\r\n\t\t\tif (parseInt(value) > max) {\r\n\t\t\t\te.target.value = max.toString();\r\n\t\t\t}\r\n\r\n\t\t\tthis.fixData();\r\n\t\t},\r\n\t\tvalidateMin: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet min = e.target.dataset.min;\r\n\r\n\t\t\tif (e.target.id == "overlayConfigTrimEnd") {\r\n\t\t\t\tmin = this.trimStart;\r\n\t\t\t}\r\n\r\n\t\t\tif (parseInt(value) < min) {\r\n\t\t\t\te.target.value = min.toString();\r\n\t\t\t}\r\n\r\n\t\t\tthis.fixData();\r\n\t\t},\r\n\t\ttoggleAmount: function(e) {\r\n\t\t\tif (e.target != document.activeElement) return;\r\n\t\t\tif (!e.target.value.length) {\r\n\t\t\t\te.target.value = 1;\r\n\t\t\t}\r\n\r\n\t\t\tlet isDown = e.wheelDeltaY < 0;\r\n\t\t\tlet value = parseInt(e.target.value);\r\n\t\t\tif (isDown) {\r\n\t\t\t\tvalue--;\r\n\t\t\t} else {\r\n\t\t\t\tvalue++;\r\n\t\t\t}\r\n\r\n\t\t\te.target.value = value.toString();\r\n\t\t\tthis.validateAmount(e);\r\n\r\n\t\t\tthis.fixData();\r\n\t\t},\r\n\t\tupdateSliders: function() {\r\n\t\t\tlet sliders = document.querySelectorAll(".slider-wrapper");\r\n\r\n\t\t\tfor (var i = 0; i < sliders.length; i++) {\r\n\t\t\t\tlet slider = sliders[i];\r\n\r\n\t\t\t\tlet handle = slider.querySelector(".handle");\r\n\t\t\t\tlet handleBounds = handle.getBoundingClientRect();\r\n\t\t\t\tlet track = slider.querySelector(".track");\r\n\t\t\t\tlet trackBounds = track.getBoundingClientRect();\r\n\t\t\t\tlet positionMin = 0;\r\n\t\t\t\tlet positionMax = trackBounds.width - handleBounds.width;\r\n\r\n\t\t\t\tlet min, max, value;\r\n\t\t\t\tif (slider.dataset.label == "opacity") {\r\n\t\t\t\t\tmin = minOpacity;\r\n\t\t\t\t\tmax = maxOpacity;\r\n\t\t\t\t\tvalue = this.opacity;\r\n\t\t\t\t} else if (slider.dataset.label == "scale") {\r\n\t\t\t\t\tmin = minScale;\r\n\t\t\t\t\tmax = maxScale;\r\n\t\t\t\t\tvalue = this.scale;\r\n\t\t\t\t} else if (slider.dataset.label == "rotate") {\r\n\t\t\t\t\tmin = minAngle;\r\n\t\t\t\t\tmax = maxAngle;\r\n\t\t\t\t\tvalue = this.angle;\r\n\t\t\t\t}\r\n\r\n\t\t\t\thandle.style.left = `${utils.map(value, min, max, positionMin, positionMax)}px`;\r\n\r\n\t\t\t\tslider.onmousemove = () => {\r\n\t\t\t\t\tif (mouse.dragged && !activeSliderDrag) {\r\n\t\t\t\t\t\tactiveSliderDrag = slider;\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tslider.onmousedown = () => {\r\n\t\t\t\t\tactiveSliderDrag = slider;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tlet configData = {\r\n\t\t\t\topacity: this.opacity,\r\n\t\t\t\tscale: this.scale,\r\n\t\t\t\tangle: this.angle\r\n\t\t\t};\r\n\r\n\t\t\tlocalStorage.setItem(config.autosave.label + ".overlay.config", JSON.stringify(configData));\r\n\t\t},\r\n\t\tshow: function() {\r\n\t\t\tthis.hidden = false;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.$el.style.opacity = "1";\r\n\r\n\t\t\t\tdom.query("#overlayConfigApp .drag").draggable({\r\n\t\t\t\t\trestrict: true,\r\n\t\t\t\t\troot: this.$el\r\n\t\t\t\t});\r\n\r\n\t\t\t\tevents.emit("renderSleep");\r\n\r\n\t\t\t\tlet fromEl = document.getElementById("overlayConfigTrimStart");\r\n\t\t\t\tlet toEl = document.getElementById("overlayConfigTrimEnd");\r\n\t\t\t\tlet startEl = document.getElementById("overlayConfigStart");\r\n\r\n\t\t\t\tfromEl.value = this.trimStart;\r\n\t\t\t\ttoEl.value = this.trimEnd;\r\n\t\t\t\tstartEl.value = this.start;\r\n\r\n\t\t\t\tthis.updateSliders();\r\n\t\t\t\tthis.fixData();\r\n\t\t\t});\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tevents.emit("renderFocus");\r\n\t\t\tthis.hidden = true;\r\n\t\t},\r\n\t\treset: function() {\r\n\t\t\tthis.opacity = maxOpacity;\r\n\t\t\tthis.scale = 1;\r\n\t\t\tthis.angle = 0;\r\n\r\n\t\t\tlet fromEl = document.getElementById("overlayConfigTrimStart");\r\n\t\t\tlet toEl = document.getElementById("overlayConfigTrimEnd");\r\n\t\t\tlet startEl = document.getElementById("overlayConfigStart");\r\n\r\n\t\t\tfromEl.value = 1;\r\n\t\t\ttoEl.value = overlayFrames.length;\r\n\t\t\tstartEl.value = 1;\r\n\r\n\t\t\tthis.fixData();\r\n\t\t\tthis.updateSliders();\r\n\t\t},\r\n\t\tremoveOverlay: function() {\r\n\t\t\tlet con = confirm("Are you sure you want to remove the overlay?");\r\n\t\t\tif (con) {\r\n\t\t\t\tevents.emit("removeOverlay");\r\n\t\t\t\tthis.hide();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nevents.on("overlayFrames", _overlayFrames => {\r\n\toverlayFrames = _overlayFrames;\r\n\toverlayConfigApp.trimEnd = overlayFrames.length;\r\n});\r\n\r\nfunction handleSliders() {\r\n\tif (activeSliderDrag) {\r\n\t\tlet handle = activeSliderDrag.querySelector(".handle");\r\n\t\tlet handleBounds = handle.getBoundingClientRect();\r\n\t\tlet track = activeSliderDrag.querySelector(".track");\r\n\t\tlet trackBounds = track.getBoundingClientRect();\r\n\t\tlet positionMin = 0;\r\n\t\tlet positionMax = trackBounds.width - handleBounds.width;\r\n\t\tlet position = mouse.x - trackBounds.x - handleBounds.width / 2;\r\n\t\tposition = utils.clamp(position, positionMin, positionMax);\r\n\t\thandle.style.left = `${position}px`;\r\n\r\n\t\tlet min, max, target;\r\n\t\tif (activeSliderDrag.dataset.label == "opacity") {\r\n\t\t\tmin = minOpacity;\r\n\t\t\tmax = maxOpacity;\r\n\t\t\ttarget = "opacity";\r\n\t\t} else if (activeSliderDrag.dataset.label == "scale") {\r\n\t\t\tmin = minScale;\r\n\t\t\tmax = maxScale;\r\n\t\t\ttarget = "scale";\r\n\t\t} else if (activeSliderDrag.dataset.label == "rotate") {\r\n\t\t\tmin = minAngle;\r\n\t\t\tmax = maxAngle;\r\n\t\t\ttarget = "angle";\r\n\t\t}\r\n\r\n\t\tlet value = utils.map(position, positionMin, positionMax, min, max);\r\n\t\toverlayConfigApp[target] = value;\r\n\r\n\t\tlet configData = {\r\n\t\t\topacity: overlayConfigApp.opacity,\r\n\t\t\tscale: overlayConfigApp.scale,\r\n\t\t\tangle: overlayConfigApp.angle\r\n\t\t};\r\n\r\n\t\tlocalStorage.setItem(config.autosave.label + ".overlay.config", JSON.stringify(configData));\r\n\t}\r\n}\r\n\r\n//Autosave config\r\nutils.loadJSONData(config.autosave.label + ".overlay.config", data => {\r\n\tif (typeof data.opacity == "number") overlayConfigApp.opacity = data.opacity;\r\n\tif (typeof data.scale == "number") overlayConfigApp.scale = data.scale;\r\n\tif (typeof data.angle == "number") overlayConfigApp.angle = data.angle;\r\n\r\n\toverlayConfigApp.updateSliders();\r\n});\r\n\r\nmouse.on("mouseup", function(event) {\r\n\tactiveSliderDrag = null;\r\n});\r\n\r\nmouse.on("mousedown", function(event) {\r\n\thandleSliders();\r\n});\r\n\r\nmouse.on("mousemove", function(event) {\r\n\tif (mouse.dragged) {\r\n\t\thandleSliders();\r\n\t}\r\n});\r\n\r\nmodule.exports = overlayConfigApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/overlay.config.js?')},"./src/client/js/vue/overlay.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst utils = __webpack_require__(/*! ../../../lib/utils.js */ "./src/lib/utils.js");\r\nconst dom = __webpack_require__(/*! ../../../lib/dom.js */ "./src/lib/dom.js");\r\nvar currentFileURL, videoDuration;\r\nconst overlayApp = new Vue({\r\n\tel: "#overlayApp",\r\n\tdata: {\r\n\t\thidden: true,\r\n\t\tcloseMsg: "Close"\r\n\t},\r\n\tmethods: {\r\n\t\tshow: function() {\r\n\t\t\tthis.hidden = false;\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.$el.style.opacity = "1";\r\n\t\t\t\tdom.query("#overlayApp .drag").draggable({\r\n\t\t\t\t\trestrict: true,\r\n\t\t\t\t\troot: this.$el\r\n\t\t\t\t});\r\n\r\n\t\t\t\tevents.emit("renderSleep");\r\n\t\t\t});\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tcurrentFileURL = undefined;\r\n\t\t\tvideoDuration = undefined;\r\n\r\n\t\t\tlet filenameEl = document.getElementById("overlayFilename");\r\n\t\t\tfilenameEl.innerText = "Choose a file...";\r\n\r\n\t\t\tlet sections = document.querySelectorAll("#overlayApp .section.disabled");\r\n\r\n\t\t\tfor (let section of sections) {\r\n\t\t\t\tsection.classList.add("disabled");\r\n\t\t\t}\r\n\r\n\t\t\tlet addButton = document.getElementById("addOverlay");\r\n\t\t\taddButton.classList.add("disabled");\r\n\r\n\t\t\tthis.hidden = true;\r\n\t\t\tevents.emit("renderFocus");\r\n\t\t},\r\n\t\tvalidateFormat: function(e) {\r\n\t\t\te.target.value = e.target.value.replace(/[^0-9.-]/g, "").replace(/(\\..*)\\./g, "$1").replace(/^0+/g, "").replace(/(?<!^)-/g, "");\r\n\t\t\tthis.validateMax(e);\r\n\t\t},\r\n\t\tvalidateAmount: function(e) {\r\n\t\t\tthis.validateMin(e);\r\n\t\t\tthis.validateMax(e);\r\n\t\t},\r\n\t\tvalidateMax: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet max = e.target.dataset.max;\r\n\r\n\t\t\tif (typeof videoDuration == "number") {\r\n\t\t\t\tif (e.target.id == "overlayStart") {\r\n\t\t\t\t\tmax = videoDuration;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (e.target.id == "overlayEnd") {\r\n\t\t\t\t\tmax = videoDuration;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (parseInt(value) > max) {\r\n\t\t\t\te.target.value = max.toString();\r\n\t\t\t}\r\n\t\t},\r\n\t\tvalidateMin: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet min = e.target.dataset.min;\r\n\r\n\t\t\tif (e.target.id == "overlayEnd") {\r\n\t\t\t\tlet start = parseInt(document.getElementById("overlayStart").value);\r\n\r\n\t\t\t\tmin = start;\r\n\t\t\t}\r\n\r\n\t\t\tif (parseInt(value) < min) {\r\n\t\t\t\te.target.value = min.toString();\r\n\t\t\t}\r\n\t\t},\r\n\t\ttoggleAmount: function(e) {\r\n\t\t\tif (e.target != document.activeElement) return;\r\n\t\t\tif (!e.target.value.length) {\r\n\t\t\t\te.target.value = 1;\r\n\t\t\t}\r\n\r\n\t\t\tlet isDown = e.wheelDeltaY < 0;\r\n\t\t\tlet value = parseInt(e.target.value);\r\n\t\t\tif (isDown) {\r\n\t\t\t\tvalue--;\r\n\t\t\t} else {\r\n\t\t\t\tvalue++;\r\n\t\t\t}\r\n\r\n\t\t\te.target.value = value.toString();\r\n\t\t\tthis.validateAmount(e);\r\n\t\t},\r\n\t\tcheckFile: function() {\r\n\t\t\tlet fileEl = document.getElementById("overlayInput");\r\n\t\t\tlet filenameEl = document.getElementById("overlayFilename");\r\n\t\t\tlet file = fileEl.files[0];\r\n\t\t\tif (!file) return;\r\n\t\t\tfilenameEl.innerText = file.name;\r\n\t\t\tlet fileURL = URL.createObjectURL(file);\r\n\t\t\tif (fileURL) {\r\n\t\t\t\tcurrentFileURL = fileURL;\r\n\r\n\t\t\t\t//Get data\r\n\t\t\t\tconst video = document.createElement("video");\r\n\t\t\t\tvideo.crossOrigin = "anonymous"\r\n\t\t\t\tvideo.controls = true;\r\n\t\t\t\tvideo.muted = true;\r\n\t\t\t\tvideo.src = fileURL;\r\n\t\t\t\tvideo.load();\r\n\t\t\t\tvideo.addEventListener("loadedmetadata", () => {\r\n\t\t\t\t\tvideoDuration = video.duration;\r\n\t\t\t\t\tvideo.remove();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tlet sections = document.querySelectorAll("#overlayApp .section.disabled");\r\n\r\n\t\t\t\tfor (let section of sections) {\r\n\t\t\t\t\tsection.classList.remove("disabled");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet addButton = document.getElementById("addOverlay");\r\n\t\t\t\taddButton.classList.remove("disabled");\r\n\t\t\t}\r\n\t\t},\r\n\t\tvalidate: function() {\r\n\t\t\tif (!currentFileURL) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet frameCount = document.getElementById("overlayFrameCount").value;\r\n\t\t\tlet frameRate = document.getElementById("overlayFrameRate").value;\r\n\t\t\tlet start = document.getElementById("overlayStart").value;\r\n\t\t\tlet end = document.getElementById("overlayEnd").value;\r\n\t\t\tlet quality = document.getElementById("overlayQuality").value;\r\n\r\n\t\t\tframeCount = frameCount.length ? parseInt(frameCount) : undefined;\r\n\t\t\tframeRate = frameRate.length ? parseInt(frameRate) : undefined;\r\n\t\t\tstart = start.length ? parseInt(start) : undefined;\r\n\t\t\tend = end.length ? parseInt(end) : undefined;\r\n\t\t\tquality = quality.length ? parseInt(quality) / 100 : undefined;\r\n\r\n\t\t\tlet options = {\r\n\t\t\t\tframeCount: frameCount,\r\n\t\t\t\tframeRate: frameRate,\r\n\t\t\t\tstart: start,\r\n\t\t\t\tend: end,\r\n\t\t\t\tquality: quality\r\n\t\t\t};\r\n\r\n\t\t\tevents.emit("extractFrames", currentFileURL, options);\r\n\t\t\tthis.hide();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = overlayApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/overlay.js?')},"./src/client/js/vue/pane.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst utils = __webpack_require__(/*! ../../../lib/utils.js */ "./src/lib/utils.js");\r\nconst dom = __webpack_require__(/*! ../../../lib/dom.js */ "./src/lib/dom.js");\r\nconst config = __webpack_require__(/*! ../../../lib/config.js */ "./src/lib/config.js");\r\n\r\nconst skinningInputIds = ["skinPositionX", "skinPositionY", "skinScaleX", "skinScaleY", "skinAngle"];\r\n\r\nconst paneApp = new Vue({\r\n\tel: "#paneApp",\r\n\tdata: {\r\n\t\thideJoints: false,\r\n\t\thideProperties: true,\r\n\t\thideHistory: true,\r\n\t\tshowLength: !config.animation.linear\r\n\t},\r\n\tmethods: {\r\n\t\thandleFocusOut: function(e) {\r\n\t\t\tlet el = e.target;\r\n\r\n\t\t\tif (!el.value.length || !el.value) {\r\n\t\t\t\tel.value = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (el._lastValue != el.value) {\r\n\t\t\t\tif (skinningInputIds.includes(el.id)) {\r\n\t\t\t\t\tevents.emit("jointSkinningInputChange");\r\n\t\t\t\t}else if (el.id == "jointZIndex") {\r\n\t\t\t\t\tevents.emit("jointZIndexInputChange");\r\n\t\t\t\t}else if (el.id == "jointName") {\r\n\t\t\t\t\tevents.emit("jointNameInputChange");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tel._lastValue = el.value;\r\n\t\t},\r\n\t\thandleInput: function() {\r\n\t\t\tevents.emit("jointNameInputChange", true);\r\n\t\t},\r\n\t\tvalidateFormat: function(e) {\r\n\t\t\te.target.value = e.target.value.replace(/[^0-9.-]/g, "").replace(/(\\..*)\\./g, "$1").replace(/^0+/g, "").replace(/(?<!^)-/g, "");\r\n\r\n\t\t\tif (e.target.id == "jointX" || e.target.id == "jointY") {\r\n\t\t\t\tevents.emit("jointPositionInputChange");\r\n\t\t\t} else if (e.target.id == "jointAngle") {\r\n\t\t\t\tevents.emit("jointAngleInputChange");\r\n\t\t\t} else if (e.target.id == "jointLength") {\r\n\t\t\t\tevents.emit("jointLengthInputChange");\r\n\t\t\t} else if (e.target.id == "jointZIndex") {\r\n\t\t\t\tevents.emit("jointZIndexInputChange");\r\n\t\t\t}\r\n\r\n\t\t\tif (skinningInputIds.includes(e.target.id)) {\r\n\t\t\t\tevents.emit("jointSkinningInputChange", true);\r\n\t\t\t}\r\n\t\t},\r\n\t\ttoggleAmount: function(e) {\r\n\t\t\tif (e.target != document.activeElement) return;\r\n\t\t\te.preventDefault();\r\n\t\t\tif (!e.target.value.length) {\r\n\t\t\t\te.target.value = 1;\r\n\t\t\t}\r\n\r\n\t\t\tlet isDown = e.wheelDeltaY < 0;\r\n\t\t\tlet value = parseFloat(e.target.value);\r\n\t\t\tlet weight = 1;\r\n\t\t\tif (e.target.id == "skinScaleX" || e.target.id == "skinScaleY") {\r\n\t\t\t\tweight = 0.1;\r\n\t\t\t}\r\n\r\n\t\t\tif (isDown) {\r\n\t\t\t\tvalue -= weight;\r\n\t\t\t} else {\r\n\t\t\t\tvalue += weight;\r\n\t\t\t}\r\n\r\n\t\t\te.target.value = value.toFixed(2);\r\n\r\n\t\t\tif (e.target.id == "jointX" || e.target.id == "jointY") {\r\n\t\t\t\tevents.emit("jointPositionInputChange");\r\n\t\t\t} else if (e.target.id == "jointAngle") {\r\n\t\t\t\tevents.emit("jointAngleInputChange");\r\n\t\t\t} else if (e.target.id == "jointLength") {\r\n\t\t\t\tevents.emit("jointLengthInputChange");\r\n\t\t\t} else if (e.target.id == "jointZIndex") {\r\n\t\t\t\tevents.emit("jointZIndexInputChange", true);\r\n\t\t\t\te.target.value = parseInt(e.target.value);\r\n\t\t\t}\r\n\r\n\t\t\tif (skinningInputIds.includes(e.target.id)) {\r\n\t\t\t\tevents.emit("jointSkinningInputChange", true);\r\n\t\t\t}\r\n\t\t},\r\n\t\tshowJoints: function() {\r\n\t\t\tthis.hideJoints = false;\r\n\t\t\tthis.hideProperties = true;\r\n\t\t\tthis.hideHistory = true;\r\n\r\n\t\t\tdom.query("#jointsTab").addClass("active");\r\n\t\t\tdom.query("#propertiesTab").removeClass("active");\r\n\t\t\tdom.query("#historyTab").removeClass("active");\r\n\r\n\t\t\tdom.query("#jointApp").removeClass("hidden");\r\n\t\t\tdom.query("#propertyApp").addClass("hidden");\r\n\t\t\tdom.query("#historyApp").addClass("hidden");\r\n\t\t},\r\n\t\tshowProperties: function() {\r\n\t\t\tthis.hideProperties = false;\r\n\t\t\tthis.hideJoints = true;\r\n\t\t\tthis.hideHistory = true;\r\n\r\n\t\t\tdom.query("#jointsTab").removeClass("active");\r\n\t\t\tdom.query("#propertiesTab").addClass("active");\r\n\t\t\tdom.query("#historyTab").removeClass("active");\r\n\r\n\t\t\tdom.query("#jointApp").addClass("hidden");\r\n\t\t\tdom.query("#propertyApp").removeClass("hidden");\r\n\t\t\tdom.query("#historyApp").addClass("hidden");\r\n\t\t},\r\n\t\tshowHistory: function() {\r\n\t\t\tthis.hideHistory = false;\r\n\t\t\tthis.hideJoints = true;\r\n\t\t\tthis.hideProperties = true;\r\n\r\n\t\t\tdom.query("#jointsTab").removeClass("active");\r\n\t\t\tdom.query("#propertiesTab").removeClass("active");\r\n\t\t\tdom.query("#historyTab").addClass("active");\r\n\r\n\t\t\tdom.query("#jointApp").addClass("hidden");\r\n\t\t\tdom.query("#propertyApp").addClass("hidden");\r\n\t\t\tdom.query("#historyApp").removeClass("hidden");\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = paneApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/pane.js?')},"./src/client/js/vue/save.js":function(module,exports,__webpack_require__){eval('const events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst dom = __webpack_require__(/*! ../../../lib/dom.js */ "./src/lib/dom.js");\r\nconst randomTitle = __webpack_require__(/*! ../random.title.js */ "./src/client/js/random.title.js");\r\n\r\nconst saveApp = new Vue({\r\n\tel: "#saveApp",\r\n\tdata: {\r\n\t\thidden: true,\r\n\t\tcloseMsg: "Close",\r\n\t\tdefaultTitle: randomTitle.generate()\r\n\t},\r\n\tmethods: {\r\n\t\tshow: function() {\r\n\t\t\tthis.defaultTitle = randomTitle.generate();\r\n\r\n\t\t\tthis.hidden = false;\r\n\r\n\t\t\tthis.$nextTick(() => {\r\n\t\t\t\tthis.$el.style.opacity = "1";\r\n\r\n\t\t\t\tdom.query("#saveApp .drag").draggable({\r\n\t\t\t\t\trestrict: true,\r\n\t\t\t\t\troot: this.$el\r\n\t\t\t\t});\r\n\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tlet filenameInput = document.getElementById("saveFilename");\r\n\t\t\t\t\tfilenameInput.focus();\r\n\t\t\t\t}, 100);\r\n\r\n\t\t\t\tevents.emit("renderSleep");\r\n\t\t\t});\r\n\t\t},\r\n\t\thide: function() {\r\n\t\t\tthis.hidden = true;\r\n\t\t\tevents.emit("renderFocus");\r\n\t\t},\r\n\t\tcheckFilename: function(e) {\r\n\t\t\tlet downloadButton = document.getElementById("download");\r\n\t\t\tif (!e.target.value.length) {\r\n\t\t\t\tdownloadButton.classList.add("disabled");\r\n\t\t\t} else {\r\n\t\t\t\tdownloadButton.classList.remove("disabled");\r\n\t\t\t}\r\n\t\t},\r\n\t\tvalidate: function() {\r\n\t\t\tlet filename = document.getElementById("saveFilename").value;\r\n\t\t\tif (!filename.length) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tevents.emit("saveProject", filename);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nmodule.exports = saveApp;\n\n//# sourceURL=webpack:///./src/client/js/vue/save.js?')},"./src/client/js/vue/timeline.js":function(module,exports,__webpack_require__){eval('const clonedeep = __webpack_require__(/*! lodash.clonedeep */ "./node_modules/lodash.clonedeep/index.js");\r\nconst events = __webpack_require__(/*! ../../../lib/events.js */ "./src/lib/events.js");\r\nconst mouse = __webpack_require__(/*! ../../../lib/mouse.js */ "./src/lib/mouse.js");\r\nconst config = __webpack_require__(/*! ../../../lib/config.js */ "./src/lib/config.js");\r\nconst utils = __webpack_require__(/*! ../../../lib/utils.js */ "./src/lib/utils.js");\r\nconst vector = __webpack_require__(/*! ../../../lib/vector.js */ "./src/lib/vector.js");\r\nconst rigModel = __webpack_require__(/*! ../rig.model.js */ "./src/client/js/rig.model.js");\r\nconst contextMenuApp = __webpack_require__(/*! ./contextMenu.js */ "./src/client/js/vue/contextMenu.js");\r\nconst history = __webpack_require__(/*! ../history.js */ "./src/client/js/history.js");\r\nvar lastActiveJointId, lastActiveJointSub;\r\nvar timeline;\r\nvar selectedKeyframe, keyframeClipboard;\r\n\r\nconst timelineApp = new Vue({\r\n\tel: "#timelineApp",\r\n\tdata: {\r\n\t\thidden: false,\r\n\t\ttotalFrames: parseInt(document.getElementById("frameCount").value),\r\n\t\tanimationSpeed: parseInt(document.getElementById("animationSpeed").value),\r\n\t\tcurrentFrame: 0\r\n\t},\r\n\tmethods: {\r\n\t\tfixData: function() {\r\n\t\t\tthis.animationSpeed = parseInt(document.getElementById("animationSpeed").value);\r\n\t\t\tthis.totalFrames = parseInt(document.getElementById("frameCount").value);\r\n\t\t\ttimeline.hatchMark.spacing = timeline.canvas.width / this.totalFrames;\r\n\t\t\ttimeline.snap();\r\n\t\t\ttimeline.redraw();\r\n\r\n\t\t\tif (timeline.playbackHandle.end.mark >= this.totalFrames && this.totalFrames != 1) {\r\n\t\t\t\ttimeline.playbackHandle.end.mark = this.totalFrames - 1;\r\n\t\t\t\ttimeline.playbackHandle.end._x = timeline.markToX(timeline.playbackHandle.end.mark);\r\n\t\t\t\ttimeline.redraw();\r\n\t\t\t}\r\n\r\n\t\t\tlet configData = {\r\n\t\t\t\tframeCount: this.totalFrames,\r\n\t\t\t\tanimationSpeed: this.animationSpeed\r\n\t\t\t};\r\n\r\n\t\t\tlocalStorage.setItem(config.autosave.label + ".frames.config", JSON.stringify(configData));\r\n\t\t},\r\n\t\tvalidateFormat: function(e) {\r\n\t\t\ttimeline.redraw();\r\n\t\t\te.target.value = e.target.value.replace(/[^0-9.-]/g, "").replace(/(\\..*)\\./g, "$1").replace(/^0+/g, "").replace(/(?<!^)-/g, "");\r\n\r\n\t\t\tthis.validateMax(e);\r\n\t\t\tthis.fixData();\r\n\t\t},\r\n\t\tvalidateAmount: function(e) {\r\n\t\t\tthis.validateMin(e);\r\n\t\t\tthis.validateMax(e);\r\n\r\n\t\t\tthis.fixData();\r\n\t\t},\r\n\t\tvalidateMax: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet max = config.animation.frameCount.max;\r\n\t\t\tif (e.target.id == "animationSpeed") max = config.animation.speed.max;\r\n\t\t\tif (parseInt(value) > max) {\r\n\t\t\t\te.target.value = max.toString();\r\n\t\t\t}\r\n\r\n\t\t\tthis.fixData();\r\n\t\t},\r\n\t\tvalidateMin: function(e) {\r\n\t\t\tlet value = e.target.value;\r\n\t\t\tlet min = config.animation.frameCount.min;\r\n\t\t\tif (e.target.id == "animationSpeed") min = config.animation.speed.min;\r\n\t\t\tif (parseInt(value) < min) {\r\n\t\t\t\te.target.value = min.toString();\r\n\t\t\t}\r\n\r\n\t\t\tthis.fixData();\r\n\t\t},\r\n\t\taddToHistory: function() {\r\n\t\t\tif (this.totalFrames != this._previousTotalFrames) {\r\n\t\t\t\thistory.add({\r\n\t\t\t\t\tlabel: "Change frame count",\r\n\t\t\t\t\tvalue: this.totalFrames,\r\n\t\t\t\t\tgroup: "input"\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tif (this.animationSpeed != this._previousAnimationSpeed) {\r\n\t\t\t\thistory.add({\r\n\t\t\t\t\tlabel: "Change animation speed",\r\n\t\t\t\t\tvalue: this.animationSpeed,\r\n\t\t\t\t\tgroup: "input"\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis._previousTotalFrames = this.totalFrames;\r\n\t\t\tthis._previousAnimationSpeed = this.animationSpeed;\r\n\t\t},\r\n\t\ttoggleAmount: function(e) {\r\n\t\t\tif (e.target != document.activeElement) return;\r\n\t\t\tlet isDown = e.wheelDeltaY < 0;\r\n\t\t\tlet value = parseInt(e.target.value);\r\n\t\t\tif (isDown) {\r\n\t\t\t\tvalue--;\r\n\t\t\t} else {\r\n\t\t\t\tvalue++;\r\n\t\t\t}\r\n\r\n\t\t\te.target.value = value.toString();\r\n\t\t\ttimelineApp.validateAmount(e);\r\n\t\t\tthis.fixData();\r\n\t\t},\r\n\t\tsetCurrentFrame: function(index) {\r\n\t\t\tthis.currentFrame = index;\r\n\t\t}\r\n\t}\r\n});\r\n\r\ntimelineApp._previousTotalFrames = timelineApp.totalFrames;\r\ntimelineApp._previousAnimationSpeed = timelineApp.animationSpeed;\r\ntimelineApp.$el.addEventListener("focusout", () => {\r\n\t//timelineApp.addToHistory();\r\n});\r\n\r\nfunction getFrames() {\r\n\tlet totalFrames = timelineApp.totalFrames;\r\n\tlet currentMark = timeline.state.currentMark;\r\n\r\n\t//Get the current frame\r\n\tlet currentFrame = null;\r\n\tfor (var i = parseInt(currentMark); i >= 0; i--) {\r\n\t\tlet key = rigModel.keyframes[i];\r\n\t\tif (key) {\r\n\t\t\tif (key.type == "head") {\r\n\t\t\t\tcurrentFrame = key.index;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//Get the next frame\r\n\tlet nextFrame = null;\r\n\tfor (var i = parseInt(currentMark) + 1; i < totalFrames; i++) {\r\n\t\tlet key = rigModel.keyframes[i];\r\n\t\tif (key) {\r\n\t\t\tif (key.type == "head") {\r\n\t\t\t\tnextFrame = key.index;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//Get the previous frame\r\n\tlet previousFrame = null;\r\n\tfor (var i = currentFrame - 1; i >= 0; i--) {\r\n\t\tlet key = rigModel.keyframes[i];\r\n\t\tif (key) {\r\n\t\t\tif (key.type == "head") {\r\n\t\t\t\tpreviousFrame = key.index;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcurrent: currentFrame,\r\n\t\tnext: nextFrame,\r\n\t\tprevious: previousFrame\r\n\t};\r\n}\r\n\r\nfunction mouseInside(el) {\r\n\tel = document.getElementById(el.id);\r\n\tif (el) {\r\n\t\tlet bounds = el.getBoundingClientRect();\r\n\t\treturn mouse.x >= bounds.x && mouse.x <= bounds.x + bounds.width && mouse.y >= bounds.y && mouse.y <= bounds.y + bounds.height;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nclass Timeline {\r\n\tconstructor() {\r\n\t\tthis.canvas = document.getElementById("timelineGraph");\r\n\t\tthis.context = this.canvas.getContext("2d");\r\n\r\n\t\tthis.buttons = {\r\n\t\t\tprevious: document.getElementById("lastFrame"),\r\n\t\t\tplay: document.getElementById("playStop"),\r\n\t\t\tnext: document.getElementById("nextFrame"),\r\n\t\t\tadd: document.getElementById("addKeyframe"),\r\n\t\t\tdelete: document.getElementById("deleteKeyframe"),\r\n\t\t\tzoomIn: document.getElementById("zoomInTimeline"),\r\n\t\t\tzoomOut: document.getElementById("zoomOutTimeline"),\r\n\t\t\tminimize: document.getElementById("minimize"),\r\n\t\t\tscrollbar: document.getElementById("timelineScrollbar")\r\n\t\t};\r\n\r\n\t\tthis.state = {\r\n\t\t\tisPlaying: false,\r\n\t\t\tisDragging: false,\r\n\t\t\tisMinimized: false,\r\n\t\t\tcurrentMark: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\t\t\tnextFrame: null,\r\n\t\t\tpreviousFrame: null,\r\n\t\t\t_x: 0\r\n\t\t};\r\n\r\n\t\tthis.hatchMark = {\r\n\t\t\tspacing: this.canvas.width / (timelineApp.totalFrames),\r\n\t\t\theight: 4\r\n\t\t};\r\n\r\n\t\tthis.scrollbar = {};\r\n\r\n\t\tthis.playbackHandle = {\r\n\t\t\tstart: {\r\n\t\t\t\tmark: 0,\r\n\t\t\t\t_x: 0\r\n\t\t\t},\r\n\t\t\tend: {\r\n\t\t\t\tmark: timelineApp.totalFrames - 1,\r\n\t\t\t\t_x: 0\r\n\t\t\t},\r\n\t\t\twidth: 2,\r\n\t\t\toffset: 6\r\n\t\t}\r\n\r\n\t\tthis.bounds = this.canvas.getBoundingClientRect();\r\n\r\n\t\tthis.loop = null;\r\n\r\n\t\tthis.addButtonEvents();\r\n\t\tthis.addMouseEvents();\r\n\t\tthis.addKeyboardEvents();\r\n\t\tthis.updateSize();\r\n\r\n\t\taddEventListener("resize", () => {\r\n\t\t\tthis.updateSize();\r\n\t\t\tthis.scrollbar.left = utils.clamp(this.scrollbar.left, 0, this.canvas.width - this.scrollbar.minWidth);\r\n\t\t\tthis.scrollbar.right = utils.clamp(this.scrollbar.right, this.scrollbar.minWidth, this.canvas.width);\r\n\t\t\tthis.scrollbar.width = this.scrollbar.right - this.scrollbar.left;\r\n\t\t\tthis.redraw();\r\n\t\t});\r\n\r\n\t\taddEventListener("load", (e) => {\r\n\t\t\tthis.updateSize();\r\n\t\t\tthis.redraw();\r\n\t\t});\r\n\r\n\t\tthis.scrollbar = {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0,\r\n\t\t\twidth: this.canvas.width,\r\n\t\t\theight: undefined,\r\n\t\t\tcolor: config.render.timeline.scrollbar.color.default,\r\n\t\t\tleft: 0,\r\n\t\t\tright: this.canvas.width,\r\n\t\t\tminWidth: 50,\r\n\t\t\tzoomSensitivity: 10\r\n\t\t};\r\n\r\n\t\tthis._timelineHeight = undefined;\r\n\t}\r\n\r\n\tstoreSelectedKeyframe() {\r\n\t\tlet keys = Object.keys(rigModel.keyframes);\r\n\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\tlet key = keys[i];\r\n\t\t\tlet frame = rigModel.keyframes[key];\r\n\r\n\t\t\tif (frame.index == this.state.currentMark) {\r\n\t\t\t\tframe.selected = true;\r\n\t\t\t} else {\r\n\t\t\t\tframe.selected = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tmarkToX(mark, ignoreLimits) {\r\n\t\tlet scrollState = utils.map(this.scrollbar.left, 0, this.canvas.width, 0, this.canvas.width * this.scrollbar.zoomSensitivity);\r\n\t\tlet scrollIndex = Math.round(utils.clamp(scrollState - this.hatchMark.spacing / 2, 0, Number.MAX_SAFE_INTEGER) / this.hatchMark.spacing);\r\n\t\tlet snap = scrollState % this.hatchMark.spacing;\r\n\t\tlet x = ((mark - scrollIndex) * this.hatchMark.spacing + this.hatchMark.spacing / 2) - snap;\r\n\r\n\t\treturn ignoreLimits ? x : utils.clamp(x, this.hatchMark.spacing / 2, this.canvas.width - this.hatchMark.spacing / 2);\r\n\t}\r\n\r\n\txToMark(x) {\r\n\t\tlet scrollState = utils.map(this.scrollbar.left, 0, this.canvas.width, 0, this.canvas.width * this.scrollbar.zoomSensitivity);\r\n\t\tlet scrollIndex = Math.round(utils.clamp(scrollState - this.hatchMark.spacing / 2, 0, Number.MAX_SAFE_INTEGER) / this.hatchMark.spacing);\r\n\t\tlet snap = scrollState % this.hatchMark.spacing;\r\n\t\tlet mark = Math.round((x + snap + this.hatchMark.spacing / 2) / this.hatchMark.spacing) - 1 + scrollIndex;\r\n\t\treturn utils.clamp(mark, 0, timelineApp.totalFrames - 1);\r\n\t}\r\n\r\n\taddKeyboardEvents() {\r\n\t\taddEventListener("keydown", event => {\r\n\t\t\tlet keys = Object.keys(rigModel.keyframes);\r\n\t\t\tthis.storeSelectedKeyframe();\r\n\r\n\t\t\tif (event.ctrlKey) {\r\n\t\t\t\tif (event.keyCode == 67) {\r\n\t\t\t\t\trigModel.copiedKeyframe = clonedeep(rigModel.getKeyframe("selected", true));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (event.keyCode == 86) {\r\n\t\t\t\t\tlet copiedKeyframe = rigModel.copiedKeyframe;\r\n\t\t\t\t\tif (copiedKeyframe) {\r\n\t\t\t\t\t\trigModel.setKeyframe(this.state.currentMark, {\r\n\t\t\t\t\t\t\tposition: vector(this.state.currentMark * this.hatchMark.spacing + this.hatchMark.spacing / 2, 0),\r\n\t\t\t\t\t\t\tlocked: this.state.currentMark == 0 ? true : false,\r\n\t\t\t\t\t\t\tid: utils.uid(),\r\n\t\t\t\t\t\t\tjoints: copiedKeyframe.joints\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\taddMouseEvents() {\r\n\t\tthis.canvas.addEventListener("contextmenu", event => {\r\n\t\t\tlet mouseX = mouse.x - this.bounds.x;\r\n\t\t\tlet mouseY = mouse.y - this.bounds.y;\r\n\t\t\tif (mouseInside(this.canvas)) {\r\n\t\t\t\tthis.storeSelectedKeyframe();\r\n\r\n\t\t\t\tlet offsetX = mouse.x + contextMenuApp.width > innerWidth ? -contextMenuApp.width : 0;\r\n\t\t\t\tlet offsetY = mouse.y + contextMenuApp.height > innerHeight ? -contextMenuApp.height : 0;\r\n\t\t\t\tcontextMenuApp.show(mouse.x + offsetX, mouse.y + offsetY);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tlet dragging = false;\r\n\t\tlet activeDrag = null;\r\n\t\tlet activeKeyframe;\r\n\t\tlet scrollbarDragStartX = 0;\r\n\t\tlet mouseX, mouseY;\r\n\t\tlet onScrollbar, onTimeline, onKeyframe, onScrollbarLeft, onScrollbarRight, onPlaybackHandle;\r\n\r\n\t\tconst dragStart = () => {\r\n\t\t\tif (!mouseInside(this.canvas)) return;\r\n\t\t\tdragging = true;\r\n\t\t\tevents.emit("renderSleep");\r\n\r\n\t\t\tif (this.playbackHandle.end.mark >= timelineApp.totalFrames && timelineApp.totalFrames != 1) {\r\n\t\t\t\tthis.playbackHandle.end.mark = timelineApp.totalFrames - 1;\r\n\t\t\t\tthis.playbackHandle.end._x = this.markToX(this.playbackHandle.end.mark);\r\n\t\t\t\tthis.redraw();\r\n\t\t\t}\r\n\r\n\t\t\t//Which area is getting dragged?\r\n\t\t\tif (dragging && !activeDrag) {\r\n\t\t\t\tif (onScrollbar) {\r\n\t\t\t\t\tscrollbarDragStartX = this.scrollbar.left - mouseX;\r\n\t\t\t\t\tactiveDrag = "scrollbar";\r\n\t\t\t\t} else if (onTimeline) {\r\n\t\t\t\t\tactiveDrag = "timeline";\r\n\t\t\t\t\tlet playbackHandleStartX = this.markToX(this.playbackHandle.start.mark, true);\r\n\t\t\t\t\tlet playbackHandleEndX = this.markToX(this.playbackHandle.end.mark, true);\r\n\t\t\t\t\tlet playbackHandleArea = this.playbackHandle.width / 2 + this.playbackHandle.offset / 2;\r\n\t\t\t\t\tif (mouseX >= playbackHandleStartX - playbackHandleArea && mouseX <= playbackHandleStartX + playbackHandleArea) {\r\n\t\t\t\t\t\tactiveDrag = "playbackHandleStart";\r\n\t\t\t\t\t} else if (mouseX >= playbackHandleEndX - playbackHandleArea && mouseX <= playbackHandleEndX + playbackHandleArea) {\r\n\t\t\t\t\t\tactiveDrag = "playbackHandleEnd";\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (onKeyframe) {\r\n\t\t\t\t\tactiveDrag = "keyframe";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (activeDrag == "timeline") {\r\n\t\t\t\tthis.state.isDragging = true;\r\n\t\t\t\tthis.state._x = utils.clamp(mouseX, this.hatchMark.spacing / 2, this.canvas.width - this.hatchMark.spacing / 2);\r\n\t\t\t\tlet mark = this.xToMark(mouseX);\r\n\t\t\t\tif (mark >= 0 && mark <= timelineApp.totalFrames) this.setCurrentMark(mark);\r\n\t\t\t}\r\n\r\n\t\t\tcontextMenuApp.hide();\r\n\t\t}\r\n\r\n\t\tconst dragEnd = () => {\r\n\t\t\tdragging = false;\r\n\t\t\tevents.emit("renderFocus");\r\n\r\n\t\t\tif (activeDrag == "playbackHandleStart" || activeDrag == "playbackHandleEnd") {\r\n\t\t\t\tlet configData = {\r\n\t\t\t\t\tstart: this.playbackHandle.start.mark,\r\n\t\t\t\t\tend: this.playbackHandle.end.mark\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlocalStorage.setItem(config.autosave.label + ".playback.config", JSON.stringify(configData));\r\n\t\t\t}\r\n\r\n\t\t\tactiveDrag = null;\r\n\r\n\t\t\t//Fix sub keyframes by resetting the head keyframe\r\n\t\t\tif (activeKeyframe) {\r\n\t\t\t\tlet mark = this.xToMark(this.state._x);\r\n\r\n\t\t\t\tthis.setCurrentMark(mark);\r\n\t\t\t\trigModel.deleteKeyframe(activeKeyframe.id);\r\n\r\n\t\t\t\tlet newFrame = rigModel.setKeyframe(mark, {\r\n\t\t\t\t\tposition: activeKeyframe.position,\r\n\t\t\t\t\tjoints: activeKeyframe.joints,\r\n\t\t\t\t\tlocked: mark == 0 ? true : false\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis.scrollbar.color = config.render.timeline.scrollbar.color.default;\r\n\r\n\t\t\tthis.snap();\r\n\t\t\tthis.state.isDragging = false;\r\n\t\t\tthis.playbackHandle.start.isDragging = false;\r\n\t\t\tthis.playbackHandle.end.isDragging = false;\r\n\t\t\tactiveKeyframe = null;\r\n\t\t\tthis.canvas.style.cursor = "default";\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\tconst drag = () => {\r\n\t\t\tmouseX = mouse.x - this.bounds.x;\r\n\t\t\tmouseY = mouse.y - this.bounds.y;\r\n\t\t\tif (!dragging) {\r\n\t\t\t\tif (mouseY < 0 || mouseY > this.canvas.height || mouseX < 0 || mouseX > this.canvas.width) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tonScrollbar = mouseY >= 0 && mouseY <= this.scrollbar.height;\r\n\t\t\tonTimeline = mouseY >= this.scrollbar.height && mouseY <= this.scrollbar.height + this._timelineHeight;\r\n\t\t\tonKeyframe = mouseY >= this.scrollbar.height + this._timelineHeight && mouseY <= this.canvas.height;\r\n\r\n\t\t\tlet resizeAreaSize = 10;\r\n\t\t\tif (!activeDrag) {\r\n\t\t\t\tonScrollbarLeft = mouseX <= this.scrollbar.left + resizeAreaSize;\r\n\t\t\t\tonScrollbarRight = mouseX >= this.scrollbar.right - resizeAreaSize;\r\n\t\t\t}\r\n\r\n\t\t\t//Cursor\r\n\t\t\tlet onScrollbarResize = mouseX >= this.scrollbar.left && mouseX <= this.scrollbar.right && (onScrollbarLeft || onScrollbarRight) && onScrollbar;\r\n\t\t\tlet playbackHandleStartX = this.markToX(this.playbackHandle.start.mark, true);\r\n\t\t\tlet playbackHandleEndX = this.markToX(this.playbackHandle.end.mark, true);\r\n\t\t\tlet playbackHandleArea = this.playbackHandle.width / 2 + this.playbackHandle.offset / 2;\r\n\t\t\tonPlaybackHandle = ((mouseX >= playbackHandleStartX - playbackHandleArea && mouseX <= playbackHandleStartX + playbackHandleArea) || (mouseX >= playbackHandleEndX - playbackHandleArea && mouseX <= playbackHandleEndX + playbackHandleArea)) && onTimeline;\r\n\t\t\tif (onScrollbarResize || onPlaybackHandle) {\r\n\t\t\t\tthis.canvas.style.cursor = "ew-resize";\r\n\t\t\t} else {\r\n\t\t\t\tthis.canvas.style.cursor = "default";\r\n\t\t\t}\r\n\r\n\t\t\t//Check if head keyframes are getting hovered\r\n\t\t\tif (onKeyframe) {\r\n\t\t\t\tlet keys = Object.keys(rigModel.keyframes);\r\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\t\t\tlet frame = rigModel.keyframes[keys[i]];\r\n\t\t\t\t\tif (frame.type == "head") {\r\n\t\t\t\t\t\tlet frameX = frame.render.position.x;\r\n\t\t\t\t\t\tlet frameY = frame.render.position.y;\r\n\t\t\t\t\t\tlet frameSize = frame.render.size;\r\n\t\t\t\t\t\tif (mouseX <= frameX + frameSize && mouseX >= frameX - frameSize && mouseY <= frameY + frameSize && mouseY && mouseY >= frameY - frameSize) {\r\n\t\t\t\t\t\t\tframe.hovered = true;\r\n\t\t\t\t\t\t\tframe.render.color = config.render.keyframe.color.hovered;\r\n\t\t\t\t\t\t\tthis.canvas.style.cursor = "pointer";\r\n\t\t\t\t\t\t\tthis.redraw();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tframe.hovered = false;\r\n\t\t\t\t\t\t\tframe.render.color = config.render.keyframe.color.default;\r\n\t\t\t\t\t\t\tthis.redraw();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//Change scrollbar color when hovered\r\n\t\t\tif (onScrollbar) {\r\n\t\t\t\tif (mouseX >= this.scrollbar.left && mouseX <= this.scrollbar.right) {\r\n\t\t\t\t\tthis.scrollbar.color = config.render.timeline.scrollbar.color.hovered;\r\n\t\t\t\t\tthis.redraw();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.scrollbar.color = config.render.timeline.scrollbar.color.default;\r\n\t\t\t\t\tthis.redraw();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.scrollbar.color = config.render.timeline.scrollbar.color.default;\r\n\t\t\t\tthis.redraw();\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (dragging) {\r\n\t\t\t\t//Scrollbar drag\r\n\t\t\t\tif (activeDrag == "scrollbar") {\r\n\t\t\t\t\tif (onScrollbarLeft) {\r\n\t\t\t\t\t\tthis.scrollbar.left = utils.clamp(mouseX, 0, this.scrollbar.right - this.scrollbar.minWidth);\r\n\t\t\t\t\t\tthis.scrollbar.width = this.scrollbar.right - this.scrollbar.left;\r\n\t\t\t\t\t\tthis.canvas.style.cursor = "ew-resize";\r\n\t\t\t\t\t} else if (onScrollbarRight) {\r\n\t\t\t\t\t\tthis.scrollbar.right = utils.clamp(mouseX, this.scrollbar.left + this.scrollbar.minWidth, this.canvas.width);\r\n\t\t\t\t\t\tthis.scrollbar.width = this.scrollbar.right - this.scrollbar.left;\r\n\t\t\t\t\t\tthis.canvas.style.cursor = "ew-resize";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!onScrollbarLeft && !onScrollbarRight) {\r\n\t\t\t\t\t\tthis.scrollbar.left = utils.clamp(mouseX + scrollbarDragStartX, 0, this.canvas.width - this.scrollbar.width);\r\n\t\t\t\t\t\tthis.scrollbar.right = this.scrollbar.left + this.scrollbar.width;\r\n\t\t\t\t\t\tthis.canvas.style.cursor = "default";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.snap();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//Timeline drag\r\n\t\t\t\tif (activeDrag == "timeline" || activeDrag == "keyframe") {\r\n\t\t\t\t\tthis.state.isDragging = true;\r\n\t\t\t\t\tthis.state._x = utils.clamp(mouseX, this.hatchMark.spacing / 2, this.canvas.width - this.hatchMark.spacing / 2);\r\n\t\t\t\t\tlet mark = this.xToMark(mouseX);\r\n\t\t\t\t\tif (mark >= 0 && mark <= timelineApp.totalFrames) this.setCurrentMark(mark);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (activeDrag == "playbackHandleStart") {\r\n\t\t\t\t\tthis.playbackHandle.start.isDragging = true;\r\n\t\t\t\t\tthis.playbackHandle.start._x = utils.clamp(mouseX, this.hatchMark.spacing / 2, this.playbackHandle.end._x - this.playbackHandle.width / 2 - this.hatchMark.spacing);\r\n\t\t\t\t\tlet mark = this.xToMark(mouseX);\r\n\t\t\t\t\tmark = utils.clamp(mark, 0, this.playbackHandle.end.mark - 1);\r\n\t\t\t\t\tif (mark >= 0 && mark <= timelineApp.totalFrames) {\r\n\t\t\t\t\t\tthis.playbackHandle.start.mark = mark;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.canvas.style.cursor = "ew-resize";\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (activeDrag == "playbackHandleEnd") {\r\n\t\t\t\t\tthis.playbackHandle.end.isDragging = true;\r\n\t\t\t\t\tthis.playbackHandle.end._x = utils.clamp(mouseX, this.playbackHandle.start._x + this.playbackHandle.width / 2 + this.hatchMark.spacing, this.canvas.width - this.hatchMark.spacing / 2);\r\n\t\t\t\t\tlet mark = this.xToMark(mouseX);\r\n\t\t\t\t\tmark = utils.clamp(mark, this.playbackHandle.start.mark + 1, timelineApp.totalFrames - 1);\r\n\t\t\t\t\tif (mark >= 0 && mark <= timelineApp.totalFrames) {\r\n\t\t\t\t\t\tthis.playbackHandle.end.mark = mark;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.canvas.style.cursor = "ew-resize";\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//Keyframe drag\r\n\t\t\t\tif (activeDrag == "keyframe") {\r\n\t\t\t\t\tif (!activeKeyframe) {\r\n\t\t\t\t\t\tlet keys = Object.keys(rigModel.keyframes);\r\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\t\t\t\t\tlet frame = rigModel.keyframes[keys[i]];\r\n\r\n\t\t\t\t\t\t\tif (!frame) continue;\r\n\t\t\t\t\t\t\tif (frame.locked) continue;\r\n\t\t\t\t\t\t\tif (frame.hovered) activeKeyframe = frame;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.state._x = utils.clamp(mouseX, this.hatchMark.spacing / 2, this.canvas.width - this.hatchMark.spacing / 2);\r\n\t\t\t\t\t\tactiveKeyframe.render.position.x = this.state._x;\r\n\t\t\t\t\t\tactiveKeyframe.dragged = true;\r\n\t\t\t\t\t\tactiveKeyframe.render.color = config.render.keyframe.color.active;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.redraw();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.redraw();\r\n\r\n\t\taddEventListener("mouseup", dragEnd);\r\n\t\taddEventListener("mousedown", dragStart);\r\n\t\taddEventListener("mousemove", drag);\r\n\t}\r\n\r\n\taddButtonEvents() {\r\n\t\t//Previous mark button\r\n\t\tthis.buttons.previous.addEventListener("click", () => {\r\n\t\t\tlet pos = this.state.currentMark > 0 ? this.state.currentMark - 1 : this.state.currentMark;\r\n\t\t\tthis.setCurrentMark(pos);\r\n\t\t});\r\n\r\n\t\t//Next mark button\r\n\t\tthis.buttons.next.addEventListener("click", () => {\r\n\t\t\tlet pos = this.state.currentMark < timelineApp.totalFrames - 1 ? this.state.currentMark + 1 : this.state.currentMark;\r\n\t\t\tthis.setCurrentMark(pos);\r\n\t\t});\r\n\r\n\t\t//Play/Stop button\r\n\t\tthis.buttons.play.addEventListener("click", () => {\r\n\t\t\tif (this.state.isPlaying) {\r\n\t\t\t\tthis.stop();\r\n\t\t\t} else {\r\n\t\t\t\tthis.play();\r\n\t\t\t}\r\n\r\n\t\t\tthis.redraw();\r\n\t\t});\r\n\r\n\t\t//Add keyframe button\r\n\t\tthis.buttons.add.addEventListener("click", () => {\r\n\t\t\tlet clone = rigModel.clone();\r\n\t\t\tlet keyframe = clone[this.state.currentMark];\r\n\t\t\tlet joints;\r\n\r\n\t\t\tif (keyframe) {\r\n\t\t\t\tjoints = keyframe.joints;\r\n\t\t\t}\r\n\r\n\t\t\trigModel.setKeyframe(this.state.currentMark, {\r\n\t\t\t\tlocked: this.state.currentMark == 0 ? true : false,\r\n\t\t\t\tjoints: joints\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\t//Delete keyframe button\r\n\t\tthis.buttons.delete.addEventListener("click", () => {\r\n\t\t\tevents.emit("deleteKeyframe");\r\n\t\t});\r\n\r\n\t\tlet holdInterval;\r\n\r\n\r\n\t\t//Zoom in\r\n\t\tthis.buttons.zoomIn.addEventListener("mousedown", () => {\r\n\t\t\tevents.emit("checkMouseHold", "zoomIn");\r\n\t\t});\r\n\r\n\t\tthis.buttons.zoomOut.addEventListener("mousedown", () => {\r\n\t\t\tevents.emit("checkMouseHold", "zoomOut");\r\n\t\t});\r\n\r\n\t\tevents.on("checkMouseHold", button => {\r\n\t\t\tholdInterval = setInterval(() => {\r\n\t\t\t\tif (!mouse.pressed) {\r\n\t\t\t\t\tclearInterval(holdInterval);\r\n\t\t\t\t\tholdInterval = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tevents.emit("mousehold", button);\r\n\t\t\t\t}\r\n\t\t\t}, 1000 / 60);\r\n\t\t});\r\n\r\n\t\tevents.on("mousehold", button => {\r\n\t\t\tif (button == "zoomIn") {\r\n\t\t\t\tlet lerpWeight = utils.map(this.scrollbar.width, 0, this.canvas.width, 0.1, 0.001);\r\n\t\t\t\tlet currentX = this.markToX(this.state.currentMark, true);\r\n\t\t\t\tthis.scrollbar.left = utils.lerp(this.scrollbar.left, currentX - this.scrollbar.minWidth / 2, lerpWeight);\r\n\t\t\t\tthis.scrollbar.right = utils.lerp(this.scrollbar.right, currentX + this.scrollbar.minWidth / 2, lerpWeight);\r\n\r\n\t\t\t} else if (button == "zoomOut") {\r\n\t\t\t\tlet lerpWeight = utils.map(this.scrollbar.width, 0, this.canvas.width, 0.001, 0.1);\r\n\t\t\t\tthis.scrollbar.left = utils.lerp(this.scrollbar.left, 0, lerpWeight);\r\n\t\t\t\tthis.scrollbar.right = utils.lerp(this.scrollbar.right, this.canvas.width, lerpWeight);\r\n\t\t\t}\r\n\r\n\t\t\tthis.scrollbar.width = this.scrollbar.right - this.scrollbar.left;\r\n\r\n\t\t\tthis.snap();\r\n\t\t\tthis.redraw();\r\n\t\t});\r\n\r\n\t\t//Minimize / Maximize\r\n\t\tthis.buttons.minimize.addEventListener("click", () => {\r\n\t\t\tif (!this.state.isMinimized) {\r\n\t\t\t\tthis.minimize();\r\n\t\t\t} else {\r\n\t\t\t\tthis.maximize();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tsnap() {\r\n\t\t//Keyframes\r\n\t\tlet keys = Object.keys(rigModel.keyframes);\r\n\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\tlet key = keys[i];\r\n\t\t\tlet frame = rigModel.keyframes[key];\r\n\t\t\tlet keyframeX = this.markToX(frame.index, true);\r\n\t\t\tframe.render.position.x = keyframeX;\r\n\t\t}\r\n\r\n\t\tthis.state._x = this.markToX(this.state.currentMark, true);\r\n\r\n\t\tthis.playbackHandle.start._x = this.markToX(this.playbackHandle.start.mark, true);\r\n\t\tthis.playbackHandle.end._x = this.markToX(this.playbackHandle.end.mark, true);\r\n\r\n\t\tthis.redraw();\r\n\t}\r\n\r\n\tupdateState(updateRig) {\r\n\t\t//Updating the state and the rig...\r\n\r\n\t\tupdateRig = typeof updateRig == "undefined" ? true : updateRig;\r\n\r\n\t\t//Update the timeline state\r\n\t\tlet frames = getFrames();\r\n\t\tthis.state.currentFrame = frames.current;\r\n\t\tthis.state.nextFrame = frames.next;\r\n\t\tthis.state.previousFrame = frames.previous;\r\n\r\n\t\t//Update rig model\r\n\t\tif (updateRig) {\r\n\t\t\t//Get the current keyframe\r\n\t\t\tlet frame = rigModel.keyframes[this.state.currentMark];\r\n\t\t\tframe = !frame ? rigModel.keyframes[this.state.currentFrame] : frame;\r\n\r\n\t\t\tif (typeof frame == "object") {\r\n\t\t\t\t//Set the rig model\'s joints to current frame\'s joints\r\n\t\t\t\trigModel.joints = frame.joints;\r\n\r\n\t\t\t\t//Set the active joint\r\n\t\t\t\tlet activeJoint = rigModel.joints.find(j => j.id === frame.activeJointId);\r\n\t\t\t\trigModel.activeJoint = activeJoint || rigModel.joints[rigModel.joints.length - 1];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tredraw() {\r\n\t\tthis.clear();\r\n\t\tthis.draw();\r\n\t}\r\n\r\n\tclear() {\r\n\t\tthis.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\t}\r\n\r\n\tdraw() {\r\n\t\tlet timelineGraphParent = this.canvas.parentNode;\r\n\t\tif (this.canvas.width != timelineGraphParent.offsetWidth || this.canvas.height != timelineGraphParent.offsetHeight) {\r\n\t\t\tthis.canvas.width = timelineGraphParent.offsetWidth;\r\n\t\t\tthis.canvas.height = timelineGraphParent.offsetHeight;\r\n\t\t}\r\n\r\n\t\t//Drawing the timeline...\r\n\t\tthis.scrollbar.height = this.canvas.height * 0.25;\r\n\t\tthis._timelineHeight = this.canvas.height * 0.4;\r\n\r\n\t\tlet timelineColor = "rgba(0, 0, 0, 0.15)";\r\n\t\tlet chamfer = 4;\r\n\r\n\t\tlet positionState = utils.map(this.scrollbar.left, 0, this.canvas.width, 0, this.canvas.width * this.scrollbar.zoomSensitivity);\r\n\t\tlet zoomState = this.canvas.width + utils.map(this.scrollbar.width, 0, this.canvas.width, this.canvas.width * this.scrollbar.zoomSensitivity, 0);\r\n\r\n\t\tlet hatchMarkCount = timelineApp.totalFrames;\r\n\t\tlet hatchMarkColor = "rgba(255, 255, 255, 0.25)";\r\n\t\tlet hatchMarkGap = Math.floor(utils.clamp(timelineApp.totalFrames, (zoomState / 15), Number.MAX_SAFE_INTEGER) / (zoomState / 15)) * 5;\r\n\r\n\t\tlet scrollbarIndex = Math.round((positionState - this.hatchMark.spacing / 2) / this.hatchMark.spacing);\r\n\t\tlet scrollbarIndexRight = Math.round((utils.map(this.scrollbar.right, 0, this.canvas.width, 0, this.canvas.width * this.scrollbar.zoomSensitivity) - this.hatchMark.spacing / 2) / this.hatchMark.spacing);\r\n\r\n\t\tlet handleX = this.markToX(this.state.currentMark, true);\r\n\t\thandleX = this.state.isDragging ? this.state._x : handleX;\r\n\t\tlet handleWidth = 10;\r\n\t\tlet handleHeight = this._timelineHeight - this.hatchMark.height;\r\n\t\tlet handleText = this.state.currentMark + 1;\r\n\r\n\t\t//Scrollbar\r\n\t\tthis.createRect(this.scrollbar.left, this.scrollbar.y, this.scrollbar.right - this.scrollbar.left, this.scrollbar.height - 5, this.scrollbar.color, chamfer);\r\n\r\n\t\t//Background\r\n\t\tthis.createRect(0, this.scrollbar.height, this.canvas.width, this._timelineHeight, timelineColor, chamfer);\r\n\r\n\t\tthis.context.save();\r\n\t\tthis.context.clip();\r\n\r\n\t\t//Hatch marks\r\n\r\n\t\tthis.hatchMark.spacing = zoomState / hatchMarkCount;\r\n\t\tfor (var i = 0; i < hatchMarkCount; i++) {\r\n\t\t\tif (i < scrollbarIndex || i > scrollbarIndexRight) continue;\r\n\r\n\t\t\tlet offsetHeight = (i + 1) % hatchMarkGap == 0 ? 2 : 0;\r\n\t\t\tlet x = this.hatchMark.spacing * i + this.hatchMark.spacing / 2 - positionState;\r\n\t\t\tlet y = this.scrollbar.height + this._timelineHeight - this.hatchMark.height - offsetHeight;\r\n\t\t\tlet width = 1;\r\n\t\t\tlet height = this.scrollbar.height + this._timelineHeight - y;\r\n\r\n\t\t\tthis.createRect(x - width / 2, y, width, height, hatchMarkColor);\r\n\r\n\t\t\tif (offsetHeight) {\r\n\t\t\t\tlet onHandle = x >= handleX - handleWidth / 2 && x <= handleX + handleWidth / 2;\r\n\t\t\t\t//Only draw the numbers if it\'s not on top of the handle\r\n\t\t\t\tif (!onHandle) {\r\n\t\t\t\t\tthis.text(i + 1, x, y - 1, hatchMarkColor);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//Handle\r\n\t\tthis.context.beginPath();\r\n\t\tthis.context.moveTo(handleX - handleWidth / 2, this.scrollbar.height);\r\n\t\tthis.context.lineTo(handleX + handleWidth / 2, this.scrollbar.height);\r\n\t\tthis.context.lineTo(handleX + handleWidth / 2, this.scrollbar.height + handleHeight - 5);\r\n\t\tthis.context.lineTo(handleX, this.scrollbar.height + handleHeight);\r\n\t\tthis.context.lineTo(handleX - handleWidth / 2, this.scrollbar.height + handleHeight - 5);\r\n\t\tthis.context.closePath();\r\n\t\tthis.context.fillStyle = config.accent;\r\n\t\tthis.context.fill();\r\n\t\tthis.text(handleText, handleX + handleWidth, handleHeight / 2 + 8 + this.scrollbar.height, config.accent, "left");\r\n\r\n\t\t//Adjust playback start handle\r\n\t\tlet restrictedColor = "rgba(0, 0, 0, 0.15)";\r\n\t\tlet startX = this.markToX(this.playbackHandle.start.mark, true);\r\n\t\tstartX = this.playbackHandle.start.isDragging ? this.playbackHandle.start._x : startX;\r\n\t\tthis.createRect(startX - this.playbackHandle.width / 2, this.scrollbar.height, this.playbackHandle.width, this._timelineHeight, config.accent);\r\n\t\tthis.createRect(0, this.scrollbar.height, startX, this._timelineHeight, restrictedColor);\r\n\r\n\t\t//Adjust playback end handle\r\n\t\tlet endX = this.markToX(this.playbackHandle.end.mark, true);\r\n\t\tendX = this.playbackHandle.end.isDragging ? this.playbackHandle.end._x : endX;\r\n\t\tthis.createRect(endX - this.playbackHandle.width / 2, this.scrollbar.height, this.playbackHandle.width, this._timelineHeight, config.accent);\r\n\t\tthis.createRect(endX, this.scrollbar.height, this.canvas.width - endX, this._timelineHeight, restrictedColor);\r\n\r\n\t\tthis.context.restore();\r\n\r\n\t\t//Keyframes\r\n\t\tlet keyframes = Object.keys(rigModel.keyframes);\r\n\t\tfor (let key of keyframes) {\r\n\t\t\tlet frame = rigModel.keyframes[key];\r\n\t\t\tframe.render.position.y = this.scrollbar.height + this._timelineHeight + frame.render.size + 5;\r\n\t\t\tlet keyframeX = this.markToX(frame.index, true);\r\n\t\t\tframe.render.position.x = frame.dragged ? mouse.x - this.bounds.x : keyframeX;\r\n\t\t\tif (frame.type == "head") {\r\n\t\t\t\tthis.createKeyframe(frame.render.position.x, frame.render.position.y, frame.render.size, frame.render.color);\r\n\t\t\t} else {\r\n\t\t\t\t//this.createKeyframe(frame.render.position.x, frame.render.position.y, frame.render.size, "blue");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ttext(text, x, y, color, textAlign) {\r\n\t\tthis.context.beginPath();\r\n\t\tthis.context.fillStyle = color;\r\n\t\tthis.context.font = "12px Catamaran";\r\n\t\tthis.context.textAlign = textAlign || "center";\r\n\t\tthis.context.textBaseline = "bottom";\r\n\t\tthis.context.fillText(text, x, y);\r\n\t}\r\n\r\n\tcreateRect(x, y, width, height, color, chamfer) {\r\n\t\tchamfer = chamfer || 0;\r\n\t\tthis.context.beginPath();\r\n\t\tthis.context.moveTo(x + chamfer, y);\r\n\t\tthis.context.lineTo(x + width - chamfer, y);\r\n\t\tthis.context.quadraticCurveTo(x + width, y, x + width, y + chamfer);\r\n\t\tthis.context.lineTo(x + width, y + height - chamfer);\r\n\t\tthis.context.quadraticCurveTo(x + width, y + height, x + width - chamfer, y + height);\r\n\t\tthis.context.lineTo(x + chamfer, y + height);\r\n\t\tthis.context.quadraticCurveTo(x, y + height, x, y + height - chamfer);\r\n\t\tthis.context.lineTo(x, y + chamfer);\r\n\t\tthis.context.quadraticCurveTo(x, y, x + chamfer, y);\r\n\t\tthis.context.closePath();\r\n\t\tthis.context.fillStyle = color;\r\n\t\tthis.context.fill();\r\n\t}\r\n\r\n\tcreateLine(x1, y1, x2, y2, color) {\r\n\t\tthis.context.beginPath();\r\n\t\tthis.context.moveTo(x1, y1);\r\n\t\tthis.context.lineTo(x2, y2);\r\n\t\tthis.context.strokeStyle = color;\r\n\t\tthis.context.stroke();\r\n\t}\r\n\r\n\tcreateKeyframe(x, y, size, color) {\r\n\t\tthis.context.beginPath();\r\n\t\tthis.context.moveTo(x, y - size / 2);\r\n\t\tthis.context.lineTo(x + size / 2, y);\r\n\t\tthis.context.lineTo(x, y + size / 2);\r\n\t\tthis.context.lineTo(x - size / 2, y);\r\n\t\tthis.context.closePath();\r\n\t\tthis.context.fillStyle = color;\r\n\t\tthis.context.fill();\r\n\t}\r\n\r\n\tsetCurrentMark(index, updateRig) {\r\n\t\tthis.state.currentMark = index;\r\n\t\ttimelineApp.setCurrentFrame(this.state.currentMark);\r\n\t\tthis.updateState(updateRig);\r\n\t\tthis.redraw();\r\n\t\tevents.emit("timelineSeeked");\r\n\t}\r\n\r\n\tplay() {\r\n\t\t//Animation\r\n\t\tthis.loop = setInterval(() => {\r\n\t\t\tif (this.state.currentMark < this.playbackHandle.start.mark) {\r\n\t\t\t\tthis.setCurrentMark(this.playbackHandle.start.mark - 1);\r\n\t\t\t}\r\n\r\n\t\t\tlet pos = this.state.currentMark < this.playbackHandle.end.mark ? this.state.currentMark + 1 : this.playbackHandle.start.mark;\r\n\t\t\tthis.setCurrentMark(pos);\r\n\t\t}, 1000 / timelineApp.animationSpeed);\r\n\t\tthis.state.isPlaying = true;\r\n\t\tthis.buttons.play.firstChild.src = "assets/svg/round-square.svg";\r\n\t\tdocument.getElementById("propertyApp").classList.add("disabled");\r\n\t}\r\n\r\n\tstop() {\r\n\t\tclearInterval(this.loop);\r\n\t\tthis.state.isPlaying = false;\r\n\t\tthis.buttons.play.firstChild.src = "assets/svg/play.svg";\r\n\t\tdocument.getElementById("propertyApp").classList.remove("disabled");\r\n\t\tevents.emit("timelineSeeked");\r\n\t}\r\n\r\n\tupdateSize() {\r\n\t\tlet _res = () => {\r\n\t\t\tlet parentBounds = this.canvas.parentNode.getBoundingClientRect();\r\n\t\t\tthis.canvas.width = parentBounds.width;\r\n\t\t\tthis.canvas.height = parentBounds.height;\r\n\t\t\tthis.bounds = this.canvas.getBoundingClientRect();\r\n\t\t\tthis.redraw();\r\n\t\t};\r\n\r\n\t\t_res();\r\n\r\n\t\tsetTimeout(_res, 100);\r\n\t}\r\n\r\n\tminimize() {\r\n\t\tlet height = timelineApp.$el.offsetHeight;\r\n\t\tlet body = document.querySelector("#timelineApp div.row-b");\r\n\r\n\t\ttimelineApp.$el.style.transform = `translateY(${height - body.offsetTop - 2}px)`;\r\n\r\n\t\tthis.buttons.minimize.style.transform = "translateY(-40px) rotate(0deg)";\r\n\r\n\t\tthis.state.isMinimized = true;\r\n\t}\r\n\r\n\tmaximize() {\r\n\t\tlet height = timelineApp.$el.offsetHeight;\r\n\t\ttimelineApp.$el.style.transform = `translateY(${0}px)`;\r\n\r\n\t\tthis.buttons.minimize.style.transform = "translateY(-40px) rotate(180deg)";\r\n\r\n\t\tthis.state.isMinimized = false;\r\n\t}\r\n}\r\n\r\ntimeline = new Timeline();\r\n\r\nutils.loadJSONData(config.autosave.label + ".frames.config", data => {\r\n\tlet frameCountEl = document.getElementById("frameCount");\r\n\tlet animationSpeedEl = document.getElementById("animationSpeed");\r\n\tif (typeof data.frameCount == "number") {\r\n\t\tframeCountEl.value = data.frameCount;\r\n\t}\r\n\r\n\tif (typeof data.animationSpeed == "number") {\r\n\t\tanimationSpeedEl.value = data.animationSpeed;\r\n\t}\r\n\r\n\ttimelineApp.fixData();\r\n});\r\n\r\nutils.loadJSONData(config.autosave.label + ".playback.config", data => {\r\n\tif (typeof data.start == "number") {\r\n\t\ttimeline.playbackHandle.start.mark = data.start;\r\n\t}\r\n\r\n\tif (typeof data.end == "number") {\r\n\t\ttimeline.playbackHandle.end.mark = data.end;\r\n\t}\r\n\r\n\ttimeline.redraw();\r\n});\r\n\r\nmodule.exports = {\r\n\tapp: timelineApp,\r\n\tgraph: timeline\r\n};\n\n//# sourceURL=webpack:///./src/client/js/vue/timeline.js?')},"./src/client/js/vue/vue.js":function(module,exports,__webpack_require__){eval('const timeline = __webpack_require__(/*! ./timeline.js */ "./src/client/js/vue/timeline.js");\r\nconst contextMenu = __webpack_require__(/*! ./contextMenu.js */ "./src/client/js/vue/contextMenu.js");\r\nconst overlayApp = __webpack_require__(/*! ./overlay.js */ "./src/client/js/vue/overlay.js");\r\nconst overlayConfigApp = __webpack_require__(/*! ./overlay.config.js */ "./src/client/js/vue/overlay.config.js");\r\nconst fileApp = __webpack_require__(/*! ./file.js */ "./src/client/js/vue/file.js");\r\nconst saveApp = __webpack_require__(/*! ./save.js */ "./src/client/js/vue/save.js");\r\nconst loadApp = __webpack_require__(/*! ./load.js */ "./src/client/js/vue/load.js");\r\nconst optionApp = __webpack_require__(/*! ./option.js */ "./src/client/js/vue/option.js");\r\nconst paneApp = __webpack_require__(/*! ./pane.js */ "./src/client/js/vue/pane.js");\r\nconst cropApp = __webpack_require__(/*! ./crop.js */ "./src/client/js/vue/crop.js");\r\nconst spritesheetExportApp = __webpack_require__(/*! ./export.spritesheet.js */ "./src/client/js/vue/export.spritesheet.js");\r\nconst framesExportApp = __webpack_require__(/*! ./export.frames.js */ "./src/client/js/vue/export.frames.js");\r\nconst GIFExportApp = __webpack_require__(/*! ./export.gif.js */ "./src/client/js/vue/export.gif.js");\r\nconst apps = {\r\n\ttimeline: timeline,\r\n\tcontextMenuApp: contextMenu,\r\n\tfileApp: fileApp,\r\n\tsaveApp: saveApp,\r\n\tloadApp: loadApp,\r\n\toptionApp: optionApp,\r\n\toverlayApp: overlayApp,\r\n\toverlayConfigApp: overlayConfigApp,\r\n\tpaneApp: paneApp,\r\n\tcropApp: cropApp,\r\n\tspritesheetExportApp: spritesheetExportApp,\r\n\tframesExportApp: framesExportApp,\r\n\tGIFExportApp: GIFExportApp\r\n};\r\n\r\nmodule.exports = apps;\n\n//# sourceURL=webpack:///./src/client/js/vue/vue.js?')},"./src/client/lib/camera.js":function(module,exports){eval('function lerp(start, stop, per) {\r\n\treturn per * (stop - start) + start;\r\n}\r\n\r\n/*\r\n*Modified version of robashton\'s camera\r\n*Repository link:\r\n*https://github.com/robashton/camera\r\n*/\r\n\r\nclass Camera2D {\r\n\tconstructor(context, options) {\r\n\t\toptions = options || {};\r\n\t\tthis.movement = {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0\r\n\t\t};\r\n\r\n\t\tthis.viewport = {\r\n\t\t\tleft: 0,\r\n\t\t\tright: 0,\r\n\t\t\ttop: 0,\r\n\t\t\tbottom: 0,\r\n\t\t\twidth: 0,\r\n\t\t\theight: 0,\r\n\t\t\tscale: [1.0, 1.0]\r\n\t\t};\r\n\r\n\t\tthis.distance = 0;\r\n\t\tthis.context = context || null;\r\n\t\tthis.fieldOfView = options.fieldOfView || Math.PI / 4.0;\r\n\t\tthis.moveSpeed = options.moveSpeed || 1;\r\n\t\tthis.zoomSpeed = options.zoomSpeed || 1;\r\n\t\tthis.scaleSpeed = options.scaleSpeed || 1;\r\n\t}\r\n\r\n\tsetContext(context) {\r\n\t\tthis.context = context;\r\n\t\tthis.updateViewport();\r\n\t}\r\n\r\n\tsetMoveSpeed(speed) {\r\n\t\tthis.moveSpeed = speed;\r\n\t}\r\n\r\n\tsetZoomSpeed(speed) {\r\n\t\tthis.zoomSpeed = speed;\r\n\t}\r\n\r\n\tsetScaleSpeed(speed) {\r\n\t\tthis.scaleSpeed = speed;\r\n\t}\r\n\r\n\tbegin(f) {\r\n\t\tif (typeof f != "function") return;\r\n\t\tthis.context.save();\r\n\t\tthis.applyScale();\r\n\t\tthis.applyTranslation();\r\n\t\tf(this);\r\n\t\tthis.context.restore();\r\n\t}\r\n\r\n\tapplyScale() {\r\n\t\tthis.context.scale(this.viewport.scale[0], this.viewport.scale[1]);\r\n\t}\r\n\r\n\tapplyTranslation() {\r\n\t\tthis.context.translate(-this.viewport.left, -this.viewport.top);\r\n\t}\r\n\r\n\tupdateViewport() {\r\n\t\tthis.aspectRatio = this.context.canvas.width / this.context.canvas.height;\r\n\t\tthis.viewport.width = lerp(this.viewport.width, this.distance * Math.tan(this.fieldOfView), this.scaleSpeed);\r\n\t\tthis.viewport.height = lerp(this.viewport.height, this.viewport.width / this.aspectRatio, this.scaleSpeed);\r\n\t\tthis.viewport.left = this.movement.x - (this.viewport.width / 2);\r\n\t\tthis.viewport.top = this.movement.y - (this.viewport.height / 2);\r\n\t\tthis.viewport.right = this.viewport.left + this.viewport.width;\r\n\t\tthis.viewport.bottom = this.viewport.top + this.viewport.height;\r\n\t\tthis.viewport.scale[0] = this.context.canvas.width / this.viewport.width;\r\n\t\tthis.viewport.scale[1] = this.context.canvas.height / this.viewport.height;\r\n\t}\r\n\r\n\tzoomTo(z) {\r\n\t\tthis.distance = lerp(this.distance, z, this.zoomSpeed);\r\n\t\tthis.updateViewport();\r\n\t}\r\n\r\n\tmoveTo(x, y) {\r\n\t\tthis.movement.x = lerp(this.movement.x, x, this.moveSpeed);\r\n\t\tthis.movement.y = lerp(this.movement.y, y, this.moveSpeed);\r\n\t\tthis.updateViewport();\r\n\t}\r\n\r\n\tscreenToWorld(x, y, obj) {\r\n\t\tobj = obj || {\r\n\t\t\tx: (x / this.viewport.scale[0]) + this.viewport.left,\r\n\t\t\ty: (y / this.viewport.scale[1]) + this.viewport.top\r\n\t\t};\r\n\t\treturn obj;\r\n\t}\r\n\r\n\tworldToScreen(x, y, obj) {\r\n\t\tobj = obj || {\r\n\t\t\tx: (x - this.viewport.left) * (this.viewport.scale[0]),\r\n\t\t\ty: (y - this.viewport.top) * (this.viewport.scale[1])\r\n\t\t};\r\n\t\treturn obj;\r\n\t}\r\n}\r\n\r\nmodule.exports = {\r\n\tcreate: function (context, options) {\r\n\t\treturn new Camera2D(context, options)\r\n\t}\r\n};\n\n//# sourceURL=webpack:///./src/client/lib/camera.js?')},"./src/lib/config.js":function(module,exports){eval('/*Possible export formats\r\n*GIF\r\n*Spritesheet\r\n*Frames\r\n*/\r\n\r\nmodule.exports = {\r\n\taccent: "#5984d2",\r\n\trender: {\r\n\t\tjoint: {\r\n\t\t\tradius: 3,\r\n\t\t\tcolor: {\r\n\t\t\t\tselected: "#ff565a",\r\n\t\t\t\tmoving: "#b5babe",\r\n\t\t\t\tdefault: "#dce0e4"\r\n\t\t\t}\r\n\t\t},\r\n\t\tsegment: {\r\n\t\t\twidth: 1.5,\r\n\t\t\tcolor: "#c7cbce"\r\n\t\t},\r\n\t\tkeyframe: {\r\n\t\t\tsize: 6,\r\n\t\t\tcolor: {\r\n\t\t\t\tdefault: "#ff4258",\r\n\t\t\t\thovered: "#ee2b47",\r\n\t\t\t\tactive: "#e31d42"\r\n\t\t\t}\r\n\t\t},\r\n\t\ttimeline: {\r\n\t\t\tscrollbar: {\r\n\t\t\t\tcolor: {\r\n\t\t\t\t\tdefault: "rgba(240, 230, 250, 0.045)",\r\n\t\t\t\t\thovered: "rgba(240, 230, 250, 0.06)",\r\n\t\t\t\t\tactive: "rgba(240, 230, 250, 0.075)"\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tworld: {\r\n\t\tbackground: "#1a1c1f",\r\n\t\tzoom: 200,\r\n\t\tminZoom: 100,\r\n\t\tmaxZoom: 1500\r\n\t},\r\n\tanimation: {\r\n\t\tframeCount: {\r\n\t\t\tmin: 1,\r\n\t\t\tmax: 600\r\n\t\t},\r\n\t\tspeed: {\r\n\t\t\tmin: 1,\r\n\t\t\tmax: 60\r\n\t\t},\r\n\t\tautoAddKeyframe: true\r\n\t},\r\n\triggingMode: "forwardKinematics",\r\n\tautosave: {\r\n\t\tlabel: "rigme.model",\r\n\t\tenabled: true,\r\n\t\tthreshold: 1\r\n\t},\r\n\tanimateSkin: true\r\n};\n\n//# sourceURL=webpack:///./src/lib/config.js?')},"./src/lib/dom.js":function(module,exports,__webpack_require__){eval('const mouse = __webpack_require__(/*! ./mouse.js */ "./src/lib/mouse.js");\r\nconst utils = __webpack_require__(/*! ./utils.js */ "./src/lib/utils.js");\r\n\r\nlet _draggableElements = [];\r\n\r\nlet _isDragging = false;\r\nlet _activeDragEl = null,\r\n\t_activeDragElBounds;\r\nlet _dragStartPosition = {};\r\n\r\nvar _drag = event => {\r\n\tif (_isDragging) {\r\n\t\tif (_activeDragEl) {\r\n\t\t\tevent.preventDefault();\r\n\t\t\tlet movement = {\r\n\t\t\t\tx: _dragStartPosition.x - event.clientX,\r\n\t\t\t\ty: _dragStartPosition.y - event.clientY\r\n\t\t\t};\r\n\r\n\t\t\tlet pos = {\r\n\t\t\t\tx: _activeDragEl.offsetLeft - movement.x,\r\n\t\t\t\ty: _activeDragEl.offsetTop - movement.y\r\n\t\t\t}\r\n\r\n\t\t\tif (_activeDragEl._restrictDrag) {\r\n\t\t\t\tpos.x = utils.clamp(pos.x, 0, innerWidth - _activeDragElBounds.width);\r\n\r\n\t\t\t\tpos.y = utils.clamp(pos.y, 0, innerHeight - _activeDragElBounds.height);\r\n\t\t\t}\r\n\r\n\t\t\tif (pos.x < innerWidth - _activeDragElBounds.width && pos.x > 0) {\r\n\t\t\t\t_dragStartPosition.x = event.clientX;\r\n\t\t\t\t_activeDragEl.style.left = pos.x + "px";\r\n\t\t\t}\r\n\r\n\t\t\tif (pos.x >= innerWidth - _activeDragElBounds.width) {\r\n\t\t\t\t_activeDragEl.style.left = (innerWidth - _activeDragElBounds.width) + "px";\r\n\t\t\t}\r\n\r\n\t\t\tif (pos.x <= 0) {\r\n\t\t\t\t_activeDragEl.style.left = "0px";\r\n\t\t\t}\r\n\r\n\t\t\tif (pos.y < innerHeight - _activeDragElBounds.height && pos.y > 0) {\r\n\t\t\t\t_dragStartPosition.y = event.clientY;\r\n\t\t\t\t_activeDragEl.style.top = pos.y + "px";\r\n\t\t\t}\r\n\r\n\t\t\tif (pos.y >= innerHeight - _activeDragElBounds.height) {\r\n\t\t\t\t_activeDragEl.style.top = (innerHeight - _activeDragElBounds.height) + "px";\r\n\t\t\t}\r\n\r\n\t\t\tif (pos.y <= 0) {\r\n\t\t\t\t_activeDragEl.style.top = "0px";\r\n\t\t\t}\r\n\r\n\t\t\tif (typeof _activeDragEl._drag == "function") _activeDragEl._drag(event);\r\n\t\t}\r\n\t}\r\n\r\n\tif (!mouse.pressed) {\r\n\t\t_dragEnd();\r\n\t}\r\n};\r\n\r\nvar _dragStart = event => {\r\n\tif (!_draggableElements.includes(event.target._dragRoot)) return;\r\n\tevent.preventDefault();\r\n\r\n\t_isDragging = true;\r\n\t_activeDragEl = event.target._dragRoot;\r\n\t_activeDragElBounds = _activeDragEl.getBoundingClientRect();\r\n\r\n\t_dragStartPosition.x = event.clientX;\r\n\t_dragStartPosition.y = event.clientY;\r\n\r\n\t/*let children = _activeDragEl.querySelectorAll("*");\r\n\tfor (var i = 0; i < children.length; i++) {\r\n\t\tlet child = children[i];\r\n\t\tlet style = getComputedStyle(child);\r\n\t\tchild._userSelect = style.getPropertyValue("user-select");\r\n\t\tchild._pointerEvents = style.getPropertyValue("pointer-events");\r\n\t\tif (child.getAttribute("disabled")) child._disabled = true;\r\n\t}\r\n\r\n\tfor (var i = 0; i < children.length; i++) {\r\n\t\tlet child = children[i];\r\n\t\tchild.style.pointerEvents = "none";\r\n\t\tchild.style.userSelect = "none";\r\n\t}*/\r\n\r\n\tif (typeof _activeDragEl._dragStart == "function") _activeDragEl._dragStart(event);\r\n};\r\n\r\nvar _dragEnd = event => {\r\n\tif (_activeDragEl) {\r\n\t\tif (typeof _activeDragEl._dragEnd == "function") _activeDragEl._dragEnd(event);\r\n\r\n\t\t/*let children = _activeDragEl.querySelectorAll("*");\r\n\t\tfor (var i = 0; i < children.length; i++) {\r\n\t\t\tlet child = children[i];\r\n\t\t\tchild.style.pointerEvents = child._pointerEvents;\r\n\t\t\tchild.style.userSelect = child._userSelect;\r\n\t\t\tif (child._disabled) child.setAttribute("disabled", "");\r\n\t\t}*/\r\n\t}\r\n\r\n\t_isDragging = false;\r\n\t_activeDragEl = null;\r\n};\r\n\r\naddEventListener("mousemove", _drag);\r\naddEventListener("mousedown", _dragStart);\r\naddEventListener("mouseup", _dragEnd);\r\n\r\nclass DOM {\r\n\tquery(selector, multiple) {\r\n\t\tif (typeof selector == "object") {\r\n\t\t\treturn new Element(selector);\r\n\t\t}\r\n\r\n\t\tlet searchEl = !this.node ? document : this.node;\r\n\r\n\t\tif (!multiple) {\r\n\t\t\treturn new Element(searchEl.querySelector(selector));\r\n\t\t}\r\n\r\n\t\tlet el = searchEl.querySelectorAll(selector);\r\n\t\tlet res = [];\r\n\r\n\t\tfor (var i = 0; i < el.length; i++) {\r\n\t\t\tlet element = new Element(el[i]);\r\n\t\t\tres.push(element);\r\n\t\t}\r\n\r\n\t\tlet nodeList = new NodeList(res);\r\n\r\n\t\treturn nodeList;\r\n\t}\r\n\r\n\tcreate(tag) {\r\n\t\tlet el = document.createElement(tag);\r\n\t\tlet element = new Element(el);\r\n\t\tif (this.node) {\r\n\t\t\tthis.node.appendChild(el);\r\n\t\t}\r\n\r\n\t\treturn element;\r\n\t}\r\n}\r\n\r\nclass NodeList {\r\n\tconstructor(elements) {\r\n\t\tthis.elements = elements || [];\r\n\t}\r\n\r\n\ton(event, f) {\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tel.on(event, f);\r\n\t\t}\r\n\t}\r\n\r\n\tappend(_el) {\r\n\t\tif (_el instanceof NodeList) {\r\n\t\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\t\tlet el = this.elements[i];\r\n\t\t\t\tfor (var j = 0; j < _el.elements.length; j++) {\r\n\t\t\t\t\tel.append(_el.elements[j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\t\tlet el = this.elements[i];\r\n\t\t\t\tel.append(_el);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvalue(str) {\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tel.value(str);\r\n\t\t}\r\n\t}\r\n\r\n\tquery(selector) {\r\n\t\tlet res = [];\r\n\t\tif (typeof selector == "string") {\r\n\t\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\t\tlet el = this.elements[i];\r\n\t\t\t\tif (el.node.matches(selector)) {\r\n\t\t\t\t\tres.push(el);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (typeof selector == "object") {\r\n\t\t\tlet element = new Element(selector);\r\n\t\t\tres.push(element);\r\n\t\t}\r\n\r\n\t\tlet nodeList = new NodeList(res);\r\n\r\n\t\treturn nodeList;\r\n\t}\r\n\r\n\ttext(txt, overwrite) {\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tel.text(txt, overwrite);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\thtml(html, overwrite) {\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tel.html(html, overwrite);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\taddClass() {\r\n\t\tlet args = [];\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tel.addClass(...args);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tremoveClass() {\r\n\t\tlet args = [];\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tel.removeClass(...args);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\ttoggleClass() {\r\n\t\tlet args = [];\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tel.toggleClass(...args);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\texcept(selector) {\r\n\t\tlet res = [];\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tif (!el.node.matches(selector)) {\r\n\t\t\t\tres.push(el);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet nodeList = new NodeList(res);\r\n\r\n\t\treturn nodeList;\r\n\t}\r\n\r\n\tdraggable(options) {\r\n\t\toptions = options || {};\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i].node;\r\n\t\t\tel.draggable(options);\r\n\t\t}\r\n\t}\r\n\r\n\tcss() {\r\n\t\tlet args = [];\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tel.css(...args);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprop() {\r\n\t\tlet args = [];\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tel.prop(...args);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tattr() {\r\n\t\tlet args = [];\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tel.attr(...args);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tremove() {\r\n\t\tfor (var i = 0; i < this.elements.length; i++) {\r\n\t\t\tlet el = this.elements[i];\r\n\t\t\tthis.elements.splice(this.elements.indexOf(el), 1);\r\n\t\t\tel.remove();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Element extends DOM {\r\n\tconstructor(el) {\r\n\t\tsuper();\r\n\t\tthis.node = el;\r\n\t}\r\n\r\n\tdraggable(options) {\r\n\t\toptions = options || {};\r\n\t\tthis.node._dragRoot = options.root || this.node;\r\n\t\tthis.node._dragRoot._restrictDrag = options.restrict;\r\n\t\tthis.node._dragRoot._dragStart = options.dragStart;\r\n\t\tthis.node._dragRoot._dragEnd = options.dragEnd;\r\n\t\tthis.node._dragRoot._drag = options.drag;\r\n\r\n\t\tif (!_draggableElements.includes(this.node._dragRoot)) {\r\n\t\t\t_draggableElements.push(this.node._dragRoot);\r\n\t\t}\r\n\t}\r\n\r\n\tremove() {\r\n\t\tif (this.node.parentNode) {\r\n\t\t\tthis.node.parentNode.removeChild(this.node);\r\n\t\t} else {\r\n\t\t\ttry {\r\n\t\t\t\tthis.node.remove();\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconsole.warn("Couldn\'t remove element");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ttext(txt, overwrite) {\r\n\t\tif (txt) {\r\n\t\t\tif (overwrite) this.node.innerText = txt;\r\n\t\t\telse this.node.innerText += txt;\r\n\t\t}\r\n\r\n\t\treturn this.node.innerText;\r\n\t}\r\n\r\n\thtml(html, overwrite) {\r\n\t\tif (html) {\r\n\t\t\tif (overwrite) this.node.innerHTML = html;\r\n\t\t\telse this.node.innerHTML += html;\r\n\t\t}\r\n\r\n\t\treturn this.node.innerHTML;\r\n\t}\r\n\r\n\taddClass() {\r\n\t\tlet args = [];\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\r\n\t\tthis.node.classList.add(...args);\r\n\t}\r\n\r\n\tremoveClass() {\r\n\t\tlet args = [];\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\r\n\t\tthis.node.classList.remove(...args);\r\n\t}\r\n\r\n\ttoggleClass() {\r\n\t\tlet args = [];\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\r\n\t\tthis.node.classList.toggle(...args);\r\n\t}\r\n\r\n\thasClass(token) {\r\n\t\treturn this.node.classList.contains(token);\r\n\t}\r\n\r\n\tcss(styleObject) {\r\n\t\tif (typeof styleObject == "object") {\r\n\t\t\tlet keys = Object.keys(styleObject);\r\n\t\t\tfor (var j = 0; j < keys.length; j++) {\r\n\t\t\t\tlet key = keys[j];\r\n\t\t\t\tlet value = styleObject[key];\r\n\t\t\t\tthis.node.style[key] = value;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (arguments.length == 2) {\r\n\t\t\t\tthis.node.style[arguments[0]] = arguments[1];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprop(propsObject) {\r\n\t\tif (typeof propsObject == "object") {\r\n\t\t\tlet keys = Object.keys(propsObject);\r\n\t\t\tfor (var j = 0; j < keys.length; j++) {\r\n\t\t\t\tlet key = keys[j];\r\n\t\t\t\tlet value = propsObject[key];\r\n\t\t\t\tthis.node[key] = value;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (arguments.length) {\r\n\t\t\t\tlet arg1 = arguments[0];\r\n\t\t\t\tlet arg2 = arguments[1];\r\n\t\t\t\tif (typeof arg2 != "undefined") this.node[arg1] = arg2;\r\n\t\t\t\treturn this.node[arg1];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tattr(attributesObject) {\r\n\t\tif (typeof attributesObject == "object") {\r\n\t\t\tlet keys = Object.keys(attributesObject);\r\n\t\t\tfor (var j = 0; j < keys.length; j++) {\r\n\t\t\t\tlet key = keys[j];\r\n\t\t\t\tlet value = attributesObject[key];\r\n\t\t\t\tthis.node.setAttribute(key, value);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (arguments.length) {\r\n\t\t\t\tlet arg1 = arguments[0];\r\n\t\t\t\tlet arg2 = arguments[1];\r\n\t\t\t\tif (typeof arg2 != "undefined") this.node.setAttribute(arg1, arg2);\r\n\t\t\t\treturn this.node.getAttribute(arg1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tappend(el) {\r\n\t\tif (el instanceof NodeList) {\r\n\t\t\tfor (var i = 0; i < el.elements.length; i++) {\r\n\t\t\t\tthis.node.appendChild(el.elements[i].node);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (el.node) {\r\n\t\t\t\tthis.node.appendChild(el.node);\r\n\t\t\t} else {\r\n\t\t\t\tthis.node.appendChild(el);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tvalue(str) {\r\n\t\tif (str) this.prop("value", str);\r\n\t\treturn this.node.value;\r\n\t}\r\n\r\n\ton(event, f) {\r\n\t\tthis.node.addEventListener(event, f);\r\n\t}\r\n}\r\n\r\nconst dom = new DOM;\r\n\r\nmodule.exports = dom;\n\n//# sourceURL=webpack:///./src/lib/dom.js?')},"./src/lib/events.js":function(module,exports,__webpack_require__){eval('const utils = __webpack_require__(/*! ./utils.js */ "./src/lib/utils.js");\r\nvar _once = false;\r\n\r\nclass Events {\r\n\tconstructor() {\r\n\t\tthis.emits = {};\r\n\t\tthis.listeners = [];\r\n\t\tthis.maxListeners = 100;\r\n\t}\r\n\r\n\tsetMaxListeners(n) {\r\n\t\tthis.maxListeners = n;\r\n\t}\r\n\r\n\tremoveListener(find, value) {\r\n\t\tlet listener = this.listeners.find(l => l[find] === value);\r\n\r\n\t\tif (!value) {\r\n\t\t\tlistener = find;\r\n\t\t}\r\n\r\n\t\tif (listener) {\r\n\t\t\tfor(var i = 0; i < this.listeners.length; i++){\r\n\t\t\t\tif (this.listeners[i].id === listener.id) {\r\n\t\t\t\t\tthis.listeners.splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\temit(name) {\r\n\t\tif (!name) return;\r\n\r\n\t\tlet args = [];\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\r\n\t\targs.shift();\r\n\r\n\t\tthis.emits[name] = args;\r\n\r\n\t\tlet listeners = [];\r\n\r\n\t\tfor (var i = 0; i < this.listeners.length; i++) {\r\n\t\t\tlet listener = this.listeners[i];\r\n\t\t\tif (listener.name === name) {\r\n\t\t\t\tlisteners.push(listener);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < listeners.length; i++) {\r\n\t\t\tlet listener = listeners[i];\r\n\t\t\tif (typeof listener.method == "function") {\r\n\t\t\t\tlistener.method(...args);\r\n\r\n\t\t\t\tif (listener.once) {\r\n\t\t\t\t\tthis.removeListener("id", listener.id);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\ton(name, f) {\r\n\t\tif (!name || !f || typeof f != "function") return;\r\n\r\n\t\tlet listener = {\r\n\t\t\tid: utils.uid(),\r\n\t\t\tname: name,\r\n\t\t\tmethod: f,\r\n\t\t\tonce: _once\r\n\t\t};\r\n\r\n\t\tthis.listeners.push(listener);\r\n\r\n\t\tif (this.listeners.length >= this.maxListeners) {\r\n\t\t\tthis.listeners.shift();\r\n\t\t\tconsole.warn("Reached the max number of listeners.")\r\n\t\t}\r\n\r\n\t\treturn listener;\r\n\t}\r\n\r\n\tonce(name, f) {\r\n\t\t_once = true;\r\n\t\tlet listener = this.on(name, f);\r\n\t\t_once = false;\r\n\r\n\t\treturn listener;\r\n\t}\r\n}\r\n\r\nconst events = new Events();\r\n\r\nmodule.exports = events;\n\n//# sourceURL=webpack:///./src/lib/events.js?')},"./src/lib/key.js":function(module,exports){eval('class Key {\r\n\tconstructor() {\r\n\t\tthis.code = null;\r\n\t\tthis.name = null;\r\n\t\tthis.activeKeys = {};\r\n\t}\r\n\r\n\tcheck(code) {\r\n\t\tif (typeof code == "number") return code in this.activeKeys;\r\n\r\n\t\tlet values = Object.values(this.activeKeys);\r\n\t\treturn values.includes(code);\r\n\t}\r\n\r\n\ton(name, f) {\r\n\t\tif (typeof f != "function") return;\r\n\t\taddEventListener(name, f);\r\n\t}\r\n}\r\n\r\nconst key = new Key();\r\n\r\nkey.on("keydown", function (event) {\r\n\tkey.code = event.keyCode;\r\n\tkey.name = event.code;\r\n\r\n\tkey.activeKeys[key.code] = key.name;\r\n});\r\n\r\nkey.on("keyup", function (event) {\r\n\tkey.code = event.keyCode;\r\n\tkey.name = event.code;\r\n\r\n\tdelete key.activeKeys[key.code];\r\n});\r\n\r\nmodule.exports = key;\n\n//# sourceURL=webpack:///./src/lib/key.js?')},"./src/lib/mouse.js":function(module,exports){eval('class Mouse {\r\n\tconstructor() {\r\n\t\tthis.x = 0;\r\n\t\tthis.y = 0;\r\n\t\tthis.speedX = 0;\r\n\t\tthis.speedY = 0;\r\n\t\tthis.pressed = false;\r\n\t\tthis.dragged = false;\r\n\t\tthis.scrolled = false;\r\n\t\tthis.scrollTop = false;\r\n\t}\r\n\r\n\ton(name, f) {\r\n\t\tif (typeof f != "function") return;\r\n\t\taddEventListener(name, f);\r\n\t}\r\n}\r\n\r\nconst mouse = new Mouse();\r\n\r\nmouse.on("mousedown", function() {\r\n\tmouse.pressed = true;\r\n});\r\n\r\nmouse.on("mouseup", function() {\r\n\tmouse.pressed = false;\r\n\tmouse.dragged = false;\r\n});\r\n\r\nmouse.on("mousemove", function(event) {\r\n\tmouse.x = event.clientX;\r\n\tmouse.y = event.clientY;\r\n\r\n\tmouse.speedX = event.movementX;\r\n\tmouse.speedY = event.movementY;\r\n\r\n\tif (mouse.pressed) {\r\n\t\tmouse.dragged = true;\r\n\t} else {\r\n\t\tmouse.dragged = false;\r\n\t}\r\n});\r\n\r\nmouse.on("mousewheel", function() {\r\n\tmouse.scrolled = true;\r\n\r\n\tif (event.wheelDelta > 0) {\r\n\t\tmouse.scrollTop = true;\r\n\t} else {\r\n\t\tmouse.scrollTop = false;\r\n\t}\r\n\r\n\tsetTimeout(function() {\r\n\t\tmouse.scrolled = false;\r\n\t}, 100);\r\n});\r\n\r\nmodule.exports = mouse;\n\n//# sourceURL=webpack:///./src/lib/mouse.js?')},"./src/lib/utils.js":function(module,exports){eval('const _ids = [];\r\nlet _idLength = 6;\r\n\r\nmodule.exports = {\r\n\tloadImage: function(url) {\r\n\t\tlet img = new Image();\r\n\t\timg.crossOrigin = "anonymous";\r\n\t\timg.src = url;\r\n\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\timg.onload = () => {\r\n\t\t\t\tconst _canvas = document.createElement("canvas");\r\n\t\t\t\tconst _context = _canvas.getContext("2d");\r\n\t\t\t\tlet size = this.scaleSize(img.width, img.height, 360, 240);\r\n\t\t\t\t_canvas.width = size.width;\r\n\t\t\t\t_canvas.height = size.height;\r\n\t\t\t\t_context.drawImage(img, 0, 0, _canvas.width, _canvas.height);\r\n\t\t\t\tlet dataURL = _canvas.toDataURL("image/png");\r\n\r\n\t\t\t\tresolve({\r\n\t\t\t\t\turl: dataURL,\r\n\t\t\t\t\twidth: _canvas.width,\r\n\t\t\t\t\theight: _canvas.height,\r\n\t\t\t\t\timage: _canvas\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\tuid: function() {\r\n\t\tlet chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";\r\n\t\tlet id = "";\r\n\r\n\t\tfunction generateId() {\r\n\t\t\tid = "";\r\n\t\t\tfor (var i = 0; i < _idLength; i++) {\r\n\t\t\t\tid += chars[Math.floor(Math.random() * chars.length)];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tgenerateId();\r\n\r\n\t\tlet start = performance.now();\r\n\t\twhile (_ids.includes(id)) {\r\n\t\t\tif (performance.now() - start > 20) {\r\n\t\t\t\t_idLength++;\r\n\t\t\t}\r\n\t\t\tgenerateId();\r\n\t\t}\r\n\r\n\t\t_ids.push(id);\r\n\t\treturn id;\r\n\t},\r\n\tlerp: function(start, stop, weight) {\r\n\t\treturn weight * (stop - start) + start;\r\n\t},\r\n\tdist: function(x1, y1, x2, y2) {\r\n\t\treturn Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\r\n\t},\r\n\tmap: function(n, start1, stop1, start2, stop2) {\r\n\t\treturn (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\r\n\t},\r\n\trandom: function() {\r\n\t\tif (arguments.length == 2 && typeof arguments[0] == "number" && typeof arguments[1] == "number") {\r\n\t\t\treturn Math.random() * (arguments[1] - arguments[0]) + arguments[0];\r\n\t\t} else if (arguments.length == 1 && typeof arguments[0] == "number") {\r\n\t\t\treturn Math.random() * arguments[0];\r\n\t\t} else if (Array.isArray(arguments[0])) {\r\n\t\t\treturn arguments[0][Math.floor(Math.random() * arguments[0].length)];\r\n\t\t} else if (arguments.length > 2) {\r\n\t\t\tlet args = [...arguments];\r\n\t\t\treturn args[Math.floor(Math.random() * args.length)];\r\n\t\t}\r\n\t},\r\n\tclamp: function(n, min, max) {\r\n\t\tlet val = n < min ? min : n;\r\n\t\tval = val > max ? max : val;\r\n\t\treturn val;\r\n\t},\r\n\tgetRandomColor: function() {\r\n\t\treturn this.random([\r\n\t\t\t"#ff3b3b",\r\n\t\t\t"#ff763b",\r\n\t\t\t"#ffdb3b",\r\n\t\t\t"#c4ff3b",\r\n\t\t\t"#76ff3b",\r\n\t\t\t"#3bff8d",\r\n\t\t\t"#3bc1ff",\r\n\t\t\t"#3b48ff",\r\n\t\t\t"#963bff",\r\n\t\t\t"#de3bff",\r\n\t\t\t"#ff3b96"\r\n\t\t]);\r\n\t},\r\n\tloadJSONData: function(name, f) {\r\n\t\tlet storageData = localStorage.getItem(name);\r\n\r\n\t\tif (storageData) {\r\n\t\t\tlet data;\r\n\t\t\tlet error = false;\r\n\t\t\ttry {\r\n\t\t\t\tdata = JSON.parse(storageData);\r\n\t\t\t} catch (e) {\r\n\t\t\t\terror = true;\r\n\t\t\t\tconsole.warn("Couldn\'t load autosaved data.");\r\n\t\t\t}\r\n\r\n\t\t\tif (data && !error) {\r\n\t\t\t\tif (typeof f == "function") f(data);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tdegrees: function(radians) {\r\n\t\treturn radians * (180 / Math.PI);\r\n\t},\r\n\tradians: function(degrees) {\r\n\t\treturn degrees * (Math.PI / 180);\r\n\t},\r\n\tscaleSize: function(width, height, scaleWidth, scaleHeight) {\r\n\t\tconst ratio = Math.min(scaleWidth / width, scaleHeight / height);\r\n\t\treturn {\r\n\t\t\twidth: width * ratio,\r\n\t\t\theight: height * ratio\r\n\t\t};\r\n\t}\r\n};\n\n//# sourceURL=webpack:///./src/lib/utils.js?')},"./src/lib/vector.js":function(module,exports){eval('function random(min, max) {\r\n\treturn Math.random() * (max - min) + min;\r\n}\r\n\r\nclass Vector {\r\n\tconstructor() {\r\n\t\tlet x = typeof arguments[0] == "object" ? arguments[0].x : arguments[0];\r\n\t\tlet y = typeof arguments[0] == "object" ? arguments[0].y : arguments[1];\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t}\r\n\r\n\tadd() {\r\n\t\tlet x = typeof arguments[0] == "object" ? arguments[0].x : arguments[0];\r\n\t\tlet y = typeof arguments[0] == "object" ? arguments[0].y : arguments[1];\r\n\t\tthis.x += x || 0;\r\n\t\tthis.y += y || 0;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tsub() {\r\n\t\tlet x = typeof arguments[0] == "object" ? arguments[0].x : arguments[0];\r\n\t\tlet y = typeof arguments[0] == "object" ? arguments[0].y : arguments[1];\r\n\t\tthis.x -= x || 0;\r\n\t\tthis.y -= y || 0;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tmult(n) {\r\n\t\tthis.x *= n;\r\n\t\tthis.y *= n;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tdiv(n) {\r\n\t\tthis.x /= n;\r\n\t\tthis.y /= n;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tset() {\r\n\t\tlet x = typeof arguments[0] == "object" ? arguments[0].x : arguments[0];\r\n\t\tlet y = typeof arguments[0] == "object" ? arguments[0].y : arguments[1];\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tequals() {\r\n\t\tlet x = typeof arguments[0] == "object" ? arguments[0].x : arguments[0];\r\n\t\tlet y = typeof arguments[0] == "object" ? arguments[0].y : arguments[1];\r\n\t\treturn this.x == x && this.y == y;\r\n\t}\r\n\r\n\treset() {\r\n\t\tthis.x = 0;\r\n\t\tthis.y = 0;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tlimit(n) {\r\n\t\tn = n || 1;\r\n\t\tif (this.getMag() >= n) this.setMag(n);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tlerp(v, weight) {\r\n\t\tweight = weight || 0.1;\r\n\t\tif (typeof v.x == "number") this.x = weight * (v.x - this.x) + this.x;\r\n\t\tif (typeof v.y == "number") this.y = weight * (v.y - this.y) + this.y;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tdist() {\r\n\t\tlet x = typeof arguments[0] == "object" ? arguments[0].x : arguments[0];\r\n\t\tlet y = typeof arguments[0] == "object" ? arguments[0].y : arguments[1];\r\n\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));\r\n\t}\r\n\r\n\theading() {\r\n\t\tlet x = typeof arguments[0] == "object" ? arguments[0].x : arguments[0];\r\n\t\tlet y = typeof arguments[0] == "object" ? arguments[0].y : arguments[1];\r\n\t\tif (!arguments.length) return Math.atan2(this.y, this.x);\r\n\t\treturn Math.atan2(y - this.y, x - this.x);\r\n\t}\r\n\r\n\tnorm() {\r\n\t\tlet mag = this.getMag();\r\n\t\tif (mag != 0) this.mult(1 / mag, 1 / mag);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tcopy() {\r\n\t\treturn new Vector(this.x, this.y);\r\n\t}\r\n\r\n\tsetMag(n) {\r\n\t\tlet mag = this.getMag();\r\n\t\tmag = mag == 0 ? 0.001 : mag;\r\n\t\tthis.x *= (1 / mag) * n;\r\n\t\tthis.y *= (1 / mag) * n;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tgetMag() {\r\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\r\n\t}\r\n\r\n\trandom2D(n) {\r\n\t\tn = typeof n != "number" ? 1 : n;\r\n\r\n\t\tthis.x = random(-n, n);\r\n\t\tthis.y = random(-n, n);\r\n\t\tthis.setMag(n);\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nmodule.exports = function(x, y) {\r\n\treturn new Vector(x, y);\r\n};\n\n//# sourceURL=webpack:///./src/lib/vector.js?')}});